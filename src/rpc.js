/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const lnrpc = $root.lnrpc = (() => {

    /**
     * Namespace lnrpc.
     * @exports lnrpc
     * @namespace
     */
    const lnrpc = {};

    lnrpc.Lightning = (function() {

        /**
         * Constructs a new Lightning service.
         * @memberof lnrpc
         * @classdesc Represents a Lightning
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Lightning(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Lightning.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Lightning;

        /**
         * Creates new Lightning service using the specified rpc implementation.
         * @function create
         * @memberof lnrpc.Lightning
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Lightning} RPC service. Useful where requests and/or responses are streamed.
         */
        Lightning.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link lnrpc.Lightning#walletBalance}.
         * @memberof lnrpc.Lightning
         * @typedef WalletBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.WalletBalanceResponse} [response] WalletBalanceResponse
         */

        /**
         * Calls WalletBalance.
         * @function walletBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IWalletBalanceRequest} request WalletBalanceRequest message or plain object
         * @param {lnrpc.Lightning.WalletBalanceCallback} callback Node-style callback called with the error, if any, and WalletBalanceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.walletBalance = function walletBalance(request, callback) {
            return this.rpcCall(walletBalance, $root.lnrpc.WalletBalanceRequest, $root.lnrpc.WalletBalanceResponse, request, callback);
        }, "name", { value: "WalletBalance" });

        /**
         * Calls WalletBalance.
         * @function walletBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IWalletBalanceRequest} request WalletBalanceRequest message or plain object
         * @returns {Promise<lnrpc.WalletBalanceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#channelBalance}.
         * @memberof lnrpc.Lightning
         * @typedef ChannelBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelBalanceResponse} [response] ChannelBalanceResponse
         */

        /**
         * Calls ChannelBalance.
         * @function channelBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBalanceRequest} request ChannelBalanceRequest message or plain object
         * @param {lnrpc.Lightning.ChannelBalanceCallback} callback Node-style callback called with the error, if any, and ChannelBalanceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.channelBalance = function channelBalance(request, callback) {
            return this.rpcCall(channelBalance, $root.lnrpc.ChannelBalanceRequest, $root.lnrpc.ChannelBalanceResponse, request, callback);
        }, "name", { value: "ChannelBalance" });

        /**
         * Calls ChannelBalance.
         * @function channelBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBalanceRequest} request ChannelBalanceRequest message or plain object
         * @returns {Promise<lnrpc.ChannelBalanceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getTransactions}.
         * @memberof lnrpc.Lightning
         * @typedef GetTransactionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.TransactionDetails} [response] TransactionDetails
         */

        /**
         * Calls GetTransactions.
         * @function getTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @param {lnrpc.Lightning.GetTransactionsCallback} callback Node-style callback called with the error, if any, and TransactionDetails
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getTransactions = function getTransactions(request, callback) {
            return this.rpcCall(getTransactions, $root.lnrpc.GetTransactionsRequest, $root.lnrpc.TransactionDetails, request, callback);
        }, "name", { value: "GetTransactions" });

        /**
         * Calls GetTransactions.
         * @function getTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @returns {Promise<lnrpc.TransactionDetails>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#estimateFee}.
         * @memberof lnrpc.Lightning
         * @typedef EstimateFeeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.EstimateFeeResponse} [response] EstimateFeeResponse
         */

        /**
         * Calls EstimateFee.
         * @function estimateFee
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IEstimateFeeRequest} request EstimateFeeRequest message or plain object
         * @param {lnrpc.Lightning.EstimateFeeCallback} callback Node-style callback called with the error, if any, and EstimateFeeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.estimateFee = function estimateFee(request, callback) {
            return this.rpcCall(estimateFee, $root.lnrpc.EstimateFeeRequest, $root.lnrpc.EstimateFeeResponse, request, callback);
        }, "name", { value: "EstimateFee" });

        /**
         * Calls EstimateFee.
         * @function estimateFee
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IEstimateFeeRequest} request EstimateFeeRequest message or plain object
         * @returns {Promise<lnrpc.EstimateFeeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendCoins}.
         * @memberof lnrpc.Lightning
         * @typedef SendCoinsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendCoinsResponse} [response] SendCoinsResponse
         */

        /**
         * Calls SendCoins.
         * @function sendCoins
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendCoinsRequest} request SendCoinsRequest message or plain object
         * @param {lnrpc.Lightning.SendCoinsCallback} callback Node-style callback called with the error, if any, and SendCoinsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendCoins = function sendCoins(request, callback) {
            return this.rpcCall(sendCoins, $root.lnrpc.SendCoinsRequest, $root.lnrpc.SendCoinsResponse, request, callback);
        }, "name", { value: "SendCoins" });

        /**
         * Calls SendCoins.
         * @function sendCoins
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendCoinsRequest} request SendCoinsRequest message or plain object
         * @returns {Promise<lnrpc.SendCoinsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listUnspent}.
         * @memberof lnrpc.Lightning
         * @typedef ListUnspentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListUnspentResponse} [response] ListUnspentResponse
         */

        /**
         * Calls ListUnspent.
         * @function listUnspent
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListUnspentRequest} request ListUnspentRequest message or plain object
         * @param {lnrpc.Lightning.ListUnspentCallback} callback Node-style callback called with the error, if any, and ListUnspentResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listUnspent = function listUnspent(request, callback) {
            return this.rpcCall(listUnspent, $root.lnrpc.ListUnspentRequest, $root.lnrpc.ListUnspentResponse, request, callback);
        }, "name", { value: "ListUnspent" });

        /**
         * Calls ListUnspent.
         * @function listUnspent
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListUnspentRequest} request ListUnspentRequest message or plain object
         * @returns {Promise<lnrpc.ListUnspentResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeTransactions}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeTransactionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Transaction} [response] Transaction
         */

        /**
         * Calls SubscribeTransactions.
         * @function subscribeTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @param {lnrpc.Lightning.SubscribeTransactionsCallback} callback Node-style callback called with the error, if any, and Transaction
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeTransactions = function subscribeTransactions(request, callback) {
            return this.rpcCall(subscribeTransactions, $root.lnrpc.GetTransactionsRequest, $root.lnrpc.Transaction, request, callback);
        }, "name", { value: "SubscribeTransactions" });

        /**
         * Calls SubscribeTransactions.
         * @function subscribeTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @returns {Promise<lnrpc.Transaction>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendMany}.
         * @memberof lnrpc.Lightning
         * @typedef SendManyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendManyResponse} [response] SendManyResponse
         */

        /**
         * Calls SendMany.
         * @function sendMany
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendManyRequest} request SendManyRequest message or plain object
         * @param {lnrpc.Lightning.SendManyCallback} callback Node-style callback called with the error, if any, and SendManyResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendMany = function sendMany(request, callback) {
            return this.rpcCall(sendMany, $root.lnrpc.SendManyRequest, $root.lnrpc.SendManyResponse, request, callback);
        }, "name", { value: "SendMany" });

        /**
         * Calls SendMany.
         * @function sendMany
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendManyRequest} request SendManyRequest message or plain object
         * @returns {Promise<lnrpc.SendManyResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#newAddress}.
         * @memberof lnrpc.Lightning
         * @typedef NewAddressCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NewAddressResponse} [response] NewAddressResponse
         */

        /**
         * Calls NewAddress.
         * @function newAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewAddressRequest} request NewAddressRequest message or plain object
         * @param {lnrpc.Lightning.NewAddressCallback} callback Node-style callback called with the error, if any, and NewAddressResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.newAddress = function newAddress(request, callback) {
            return this.rpcCall(newAddress, $root.lnrpc.NewAddressRequest, $root.lnrpc.NewAddressResponse, request, callback);
        }, "name", { value: "NewAddress" });

        /**
         * Calls NewAddress.
         * @function newAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewAddressRequest} request NewAddressRequest message or plain object
         * @returns {Promise<lnrpc.NewAddressResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#signMessage}.
         * @memberof lnrpc.Lightning
         * @typedef SignMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SignMessageResponse} [response] SignMessageResponse
         */

        /**
         * Calls SignMessage.
         * @function signMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISignMessageRequest} request SignMessageRequest message or plain object
         * @param {lnrpc.Lightning.SignMessageCallback} callback Node-style callback called with the error, if any, and SignMessageResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.signMessage = function signMessage(request, callback) {
            return this.rpcCall(signMessage, $root.lnrpc.SignMessageRequest, $root.lnrpc.SignMessageResponse, request, callback);
        }, "name", { value: "SignMessage" });

        /**
         * Calls SignMessage.
         * @function signMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISignMessageRequest} request SignMessageRequest message or plain object
         * @returns {Promise<lnrpc.SignMessageResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#verifyMessage}.
         * @memberof lnrpc.Lightning
         * @typedef VerifyMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.VerifyMessageResponse} [response] VerifyMessageResponse
         */

        /**
         * Calls VerifyMessage.
         * @function verifyMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IVerifyMessageRequest} request VerifyMessageRequest message or plain object
         * @param {lnrpc.Lightning.VerifyMessageCallback} callback Node-style callback called with the error, if any, and VerifyMessageResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.verifyMessage = function verifyMessage(request, callback) {
            return this.rpcCall(verifyMessage, $root.lnrpc.VerifyMessageRequest, $root.lnrpc.VerifyMessageResponse, request, callback);
        }, "name", { value: "VerifyMessage" });

        /**
         * Calls VerifyMessage.
         * @function verifyMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IVerifyMessageRequest} request VerifyMessageRequest message or plain object
         * @returns {Promise<lnrpc.VerifyMessageResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#connectPeer}.
         * @memberof lnrpc.Lightning
         * @typedef ConnectPeerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ConnectPeerResponse} [response] ConnectPeerResponse
         */

        /**
         * Calls ConnectPeer.
         * @function connectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IConnectPeerRequest} request ConnectPeerRequest message or plain object
         * @param {lnrpc.Lightning.ConnectPeerCallback} callback Node-style callback called with the error, if any, and ConnectPeerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.connectPeer = function connectPeer(request, callback) {
            return this.rpcCall(connectPeer, $root.lnrpc.ConnectPeerRequest, $root.lnrpc.ConnectPeerResponse, request, callback);
        }, "name", { value: "ConnectPeer" });

        /**
         * Calls ConnectPeer.
         * @function connectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IConnectPeerRequest} request ConnectPeerRequest message or plain object
         * @returns {Promise<lnrpc.ConnectPeerResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#disconnectPeer}.
         * @memberof lnrpc.Lightning
         * @typedef DisconnectPeerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DisconnectPeerResponse} [response] DisconnectPeerResponse
         */

        /**
         * Calls DisconnectPeer.
         * @function disconnectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDisconnectPeerRequest} request DisconnectPeerRequest message or plain object
         * @param {lnrpc.Lightning.DisconnectPeerCallback} callback Node-style callback called with the error, if any, and DisconnectPeerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.disconnectPeer = function disconnectPeer(request, callback) {
            return this.rpcCall(disconnectPeer, $root.lnrpc.DisconnectPeerRequest, $root.lnrpc.DisconnectPeerResponse, request, callback);
        }, "name", { value: "DisconnectPeer" });

        /**
         * Calls DisconnectPeer.
         * @function disconnectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDisconnectPeerRequest} request DisconnectPeerRequest message or plain object
         * @returns {Promise<lnrpc.DisconnectPeerResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPeers}.
         * @memberof lnrpc.Lightning
         * @typedef ListPeersCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPeersResponse} [response] ListPeersResponse
         */

        /**
         * Calls ListPeers.
         * @function listPeers
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPeersRequest} request ListPeersRequest message or plain object
         * @param {lnrpc.Lightning.ListPeersCallback} callback Node-style callback called with the error, if any, and ListPeersResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPeers = function listPeers(request, callback) {
            return this.rpcCall(listPeers, $root.lnrpc.ListPeersRequest, $root.lnrpc.ListPeersResponse, request, callback);
        }, "name", { value: "ListPeers" });

        /**
         * Calls ListPeers.
         * @function listPeers
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPeersRequest} request ListPeersRequest message or plain object
         * @returns {Promise<lnrpc.ListPeersResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribePeerEvents}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribePeerEventsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PeerEvent} [response] PeerEvent
         */

        /**
         * Calls SubscribePeerEvents.
         * @function subscribePeerEvents
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPeerEventSubscription} request PeerEventSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribePeerEventsCallback} callback Node-style callback called with the error, if any, and PeerEvent
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribePeerEvents = function subscribePeerEvents(request, callback) {
            return this.rpcCall(subscribePeerEvents, $root.lnrpc.PeerEventSubscription, $root.lnrpc.PeerEvent, request, callback);
        }, "name", { value: "SubscribePeerEvents" });

        /**
         * Calls SubscribePeerEvents.
         * @function subscribePeerEvents
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPeerEventSubscription} request PeerEventSubscription message or plain object
         * @returns {Promise<lnrpc.PeerEvent>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GetInfoResponse} [response] GetInfoResponse
         */

        /**
         * Calls GetInfo.
         * @function getInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetInfoRequest} request GetInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetInfoCallback} callback Node-style callback called with the error, if any, and GetInfoResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getInfo = function getInfo(request, callback) {
            return this.rpcCall(getInfo, $root.lnrpc.GetInfoRequest, $root.lnrpc.GetInfoResponse, request, callback);
        }, "name", { value: "GetInfo" });

        /**
         * Calls GetInfo.
         * @function getInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetInfoRequest} request GetInfoRequest message or plain object
         * @returns {Promise<lnrpc.GetInfoResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getRecoveryInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetRecoveryInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GetRecoveryInfoResponse} [response] GetRecoveryInfoResponse
         */

        /**
         * lncli: `getrecoveryinfo`
         * GetRecoveryInfo returns information concerning the recovery mode including
         * whether it's in a recovery mode, whether the recovery is finished, and the
         * progress made so far.
         * @function getRecoveryInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetRecoveryInfoRequest} request GetRecoveryInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetRecoveryInfoCallback} callback Node-style callback called with the error, if any, and GetRecoveryInfoResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getRecoveryInfo = function getRecoveryInfo(request, callback) {
            return this.rpcCall(getRecoveryInfo, $root.lnrpc.GetRecoveryInfoRequest, $root.lnrpc.GetRecoveryInfoResponse, request, callback);
        }, "name", { value: "GetRecoveryInfo" });

        /**
         * lncli: `getrecoveryinfo`
         * GetRecoveryInfo returns information concerning the recovery mode including
         * whether it's in a recovery mode, whether the recovery is finished, and the
         * progress made so far.
         * @function getRecoveryInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetRecoveryInfoRequest} request GetRecoveryInfoRequest message or plain object
         * @returns {Promise<lnrpc.GetRecoveryInfoResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#pendingChannels}.
         * @memberof lnrpc.Lightning
         * @typedef PendingChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PendingChannelsResponse} [response] PendingChannelsResponse
         */

        /**
         * Calls PendingChannels.
         * @function pendingChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPendingChannelsRequest} request PendingChannelsRequest message or plain object
         * @param {lnrpc.Lightning.PendingChannelsCallback} callback Node-style callback called with the error, if any, and PendingChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.pendingChannels = function pendingChannels(request, callback) {
            return this.rpcCall(pendingChannels, $root.lnrpc.PendingChannelsRequest, $root.lnrpc.PendingChannelsResponse, request, callback);
        }, "name", { value: "PendingChannels" });

        /**
         * Calls PendingChannels.
         * @function pendingChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPendingChannelsRequest} request PendingChannelsRequest message or plain object
         * @returns {Promise<lnrpc.PendingChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listChannels}.
         * @memberof lnrpc.Lightning
         * @typedef ListChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListChannelsResponse} [response] ListChannelsResponse
         */

        /**
         * Calls ListChannels.
         * @function listChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListChannelsRequest} request ListChannelsRequest message or plain object
         * @param {lnrpc.Lightning.ListChannelsCallback} callback Node-style callback called with the error, if any, and ListChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listChannels = function listChannels(request, callback) {
            return this.rpcCall(listChannels, $root.lnrpc.ListChannelsRequest, $root.lnrpc.ListChannelsResponse, request, callback);
        }, "name", { value: "ListChannels" });

        /**
         * Calls ListChannels.
         * @function listChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListChannelsRequest} request ListChannelsRequest message or plain object
         * @returns {Promise<lnrpc.ListChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelEvents}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelEventsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelEventUpdate} [response] ChannelEventUpdate
         */

        /**
         * Calls SubscribeChannelEvents.
         * @function subscribeChannelEvents
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelEventSubscription} request ChannelEventSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelEventsCallback} callback Node-style callback called with the error, if any, and ChannelEventUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelEvents = function subscribeChannelEvents(request, callback) {
            return this.rpcCall(subscribeChannelEvents, $root.lnrpc.ChannelEventSubscription, $root.lnrpc.ChannelEventUpdate, request, callback);
        }, "name", { value: "SubscribeChannelEvents" });

        /**
         * Calls SubscribeChannelEvents.
         * @function subscribeChannelEvents
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelEventSubscription} request ChannelEventSubscription message or plain object
         * @returns {Promise<lnrpc.ChannelEventUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#closedChannels}.
         * @memberof lnrpc.Lightning
         * @typedef ClosedChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ClosedChannelsResponse} [response] ClosedChannelsResponse
         */

        /**
         * Calls ClosedChannels.
         * @function closedChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IClosedChannelsRequest} request ClosedChannelsRequest message or plain object
         * @param {lnrpc.Lightning.ClosedChannelsCallback} callback Node-style callback called with the error, if any, and ClosedChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.closedChannels = function closedChannels(request, callback) {
            return this.rpcCall(closedChannels, $root.lnrpc.ClosedChannelsRequest, $root.lnrpc.ClosedChannelsResponse, request, callback);
        }, "name", { value: "ClosedChannels" });

        /**
         * Calls ClosedChannels.
         * @function closedChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IClosedChannelsRequest} request ClosedChannelsRequest message or plain object
         * @returns {Promise<lnrpc.ClosedChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#openChannelSync}.
         * @memberof lnrpc.Lightning
         * @typedef OpenChannelSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelPoint} [response] ChannelPoint
         */

        /**
         * Calls OpenChannelSync.
         * @function openChannelSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @param {lnrpc.Lightning.OpenChannelSyncCallback} callback Node-style callback called with the error, if any, and ChannelPoint
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.openChannelSync = function openChannelSync(request, callback) {
            return this.rpcCall(openChannelSync, $root.lnrpc.OpenChannelRequest, $root.lnrpc.ChannelPoint, request, callback);
        }, "name", { value: "OpenChannelSync" });

        /**
         * Calls OpenChannelSync.
         * @function openChannelSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @returns {Promise<lnrpc.ChannelPoint>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#openChannel}.
         * @memberof lnrpc.Lightning
         * @typedef OpenChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.OpenStatusUpdate} [response] OpenStatusUpdate
         */

        /**
         * Calls OpenChannel.
         * @function openChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @param {lnrpc.Lightning.OpenChannelCallback} callback Node-style callback called with the error, if any, and OpenStatusUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.openChannel = function openChannel(request, callback) {
            return this.rpcCall(openChannel, $root.lnrpc.OpenChannelRequest, $root.lnrpc.OpenStatusUpdate, request, callback);
        }, "name", { value: "OpenChannel" });

        /**
         * Calls OpenChannel.
         * @function openChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @returns {Promise<lnrpc.OpenStatusUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#fundingStateStep}.
         * @memberof lnrpc.Lightning
         * @typedef FundingStateStepCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.FundingStateStepResp} [response] FundingStateStepResp
         */

        /**
         * Calls FundingStateStep.
         * @function fundingStateStep
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFundingTransitionMsg} request FundingTransitionMsg message or plain object
         * @param {lnrpc.Lightning.FundingStateStepCallback} callback Node-style callback called with the error, if any, and FundingStateStepResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.fundingStateStep = function fundingStateStep(request, callback) {
            return this.rpcCall(fundingStateStep, $root.lnrpc.FundingTransitionMsg, $root.lnrpc.FundingStateStepResp, request, callback);
        }, "name", { value: "FundingStateStep" });

        /**
         * Calls FundingStateStep.
         * @function fundingStateStep
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFundingTransitionMsg} request FundingTransitionMsg message or plain object
         * @returns {Promise<lnrpc.FundingStateStepResp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#channelAcceptor}.
         * @memberof lnrpc.Lightning
         * @typedef ChannelAcceptorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelAcceptRequest} [response] ChannelAcceptRequest
         */

        /**
         * Calls ChannelAcceptor.
         * @function channelAcceptor
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelAcceptResponse} request ChannelAcceptResponse message or plain object
         * @param {lnrpc.Lightning.ChannelAcceptorCallback} callback Node-style callback called with the error, if any, and ChannelAcceptRequest
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.channelAcceptor = function channelAcceptor(request, callback) {
            return this.rpcCall(channelAcceptor, $root.lnrpc.ChannelAcceptResponse, $root.lnrpc.ChannelAcceptRequest, request, callback);
        }, "name", { value: "ChannelAcceptor" });

        /**
         * Calls ChannelAcceptor.
         * @function channelAcceptor
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelAcceptResponse} request ChannelAcceptResponse message or plain object
         * @returns {Promise<lnrpc.ChannelAcceptRequest>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#closeChannel}.
         * @memberof lnrpc.Lightning
         * @typedef CloseChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.CloseStatusUpdate} [response] CloseStatusUpdate
         */

        /**
         * Calls CloseChannel.
         * @function closeChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ICloseChannelRequest} request CloseChannelRequest message or plain object
         * @param {lnrpc.Lightning.CloseChannelCallback} callback Node-style callback called with the error, if any, and CloseStatusUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.closeChannel = function closeChannel(request, callback) {
            return this.rpcCall(closeChannel, $root.lnrpc.CloseChannelRequest, $root.lnrpc.CloseStatusUpdate, request, callback);
        }, "name", { value: "CloseChannel" });

        /**
         * Calls CloseChannel.
         * @function closeChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ICloseChannelRequest} request CloseChannelRequest message or plain object
         * @returns {Promise<lnrpc.CloseStatusUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#abandonChannel}.
         * @memberof lnrpc.Lightning
         * @typedef AbandonChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.AbandonChannelResponse} [response] AbandonChannelResponse
         */

        /**
         * Calls AbandonChannel.
         * @function abandonChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IAbandonChannelRequest} request AbandonChannelRequest message or plain object
         * @param {lnrpc.Lightning.AbandonChannelCallback} callback Node-style callback called with the error, if any, and AbandonChannelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.abandonChannel = function abandonChannel(request, callback) {
            return this.rpcCall(abandonChannel, $root.lnrpc.AbandonChannelRequest, $root.lnrpc.AbandonChannelResponse, request, callback);
        }, "name", { value: "AbandonChannel" });

        /**
         * Calls AbandonChannel.
         * @function abandonChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IAbandonChannelRequest} request AbandonChannelRequest message or plain object
         * @returns {Promise<lnrpc.AbandonChannelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendPayment}.
         * @memberof lnrpc.Lightning
         * @typedef SendPaymentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * Calls SendPayment.
         * @function sendPayment
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @param {lnrpc.Lightning.SendPaymentCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendPayment = function sendPayment(request, callback) {
            return this.rpcCall(sendPayment, $root.lnrpc.SendRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendPayment" });

        /**
         * Calls SendPayment.
         * @function sendPayment
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendPaymentSync}.
         * @memberof lnrpc.Lightning
         * @typedef SendPaymentSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * Calls SendPaymentSync.
         * @function sendPaymentSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @param {lnrpc.Lightning.SendPaymentSyncCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendPaymentSync = function sendPaymentSync(request, callback) {
            return this.rpcCall(sendPaymentSync, $root.lnrpc.SendRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendPaymentSync" });

        /**
         * Calls SendPaymentSync.
         * @function sendPaymentSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendToRoute}.
         * @memberof lnrpc.Lightning
         * @typedef SendToRouteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * Calls SendToRoute.
         * @function sendToRoute
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @param {lnrpc.Lightning.SendToRouteCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendToRoute = function sendToRoute(request, callback) {
            return this.rpcCall(sendToRoute, $root.lnrpc.SendToRouteRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendToRoute" });

        /**
         * Calls SendToRoute.
         * @function sendToRoute
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendToRouteSync}.
         * @memberof lnrpc.Lightning
         * @typedef SendToRouteSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * Calls SendToRouteSync.
         * @function sendToRouteSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @param {lnrpc.Lightning.SendToRouteSyncCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendToRouteSync = function sendToRouteSync(request, callback) {
            return this.rpcCall(sendToRouteSync, $root.lnrpc.SendToRouteRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendToRouteSync" });

        /**
         * Calls SendToRouteSync.
         * @function sendToRouteSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#addInvoice}.
         * @memberof lnrpc.Lightning
         * @typedef AddInvoiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.AddInvoiceResponse} [response] AddInvoiceResponse
         */

        /**
         * Calls AddInvoice.
         * @function addInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoice} request Invoice message or plain object
         * @param {lnrpc.Lightning.AddInvoiceCallback} callback Node-style callback called with the error, if any, and AddInvoiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.addInvoice = function addInvoice(request, callback) {
            return this.rpcCall(addInvoice, $root.lnrpc.Invoice, $root.lnrpc.AddInvoiceResponse, request, callback);
        }, "name", { value: "AddInvoice" });

        /**
         * Calls AddInvoice.
         * @function addInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoice} request Invoice message or plain object
         * @returns {Promise<lnrpc.AddInvoiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listInvoices}.
         * @memberof lnrpc.Lightning
         * @typedef ListInvoicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListInvoiceResponse} [response] ListInvoiceResponse
         */

        /**
         * Calls ListInvoices.
         * @function listInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListInvoiceRequest} request ListInvoiceRequest message or plain object
         * @param {lnrpc.Lightning.ListInvoicesCallback} callback Node-style callback called with the error, if any, and ListInvoiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listInvoices = function listInvoices(request, callback) {
            return this.rpcCall(listInvoices, $root.lnrpc.ListInvoiceRequest, $root.lnrpc.ListInvoiceResponse, request, callback);
        }, "name", { value: "ListInvoices" });

        /**
         * Calls ListInvoices.
         * @function listInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListInvoiceRequest} request ListInvoiceRequest message or plain object
         * @returns {Promise<lnrpc.ListInvoiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#lookupInvoice}.
         * @memberof lnrpc.Lightning
         * @typedef LookupInvoiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Invoice} [response] Invoice
         */

        /**
         * Calls LookupInvoice.
         * @function lookupInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPaymentHash} request PaymentHash message or plain object
         * @param {lnrpc.Lightning.LookupInvoiceCallback} callback Node-style callback called with the error, if any, and Invoice
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.lookupInvoice = function lookupInvoice(request, callback) {
            return this.rpcCall(lookupInvoice, $root.lnrpc.PaymentHash, $root.lnrpc.Invoice, request, callback);
        }, "name", { value: "LookupInvoice" });

        /**
         * Calls LookupInvoice.
         * @function lookupInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPaymentHash} request PaymentHash message or plain object
         * @returns {Promise<lnrpc.Invoice>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeInvoices}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeInvoicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Invoice} [response] Invoice
         */

        /**
         * Calls SubscribeInvoices.
         * @function subscribeInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoiceSubscription} request InvoiceSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeInvoicesCallback} callback Node-style callback called with the error, if any, and Invoice
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeInvoices = function subscribeInvoices(request, callback) {
            return this.rpcCall(subscribeInvoices, $root.lnrpc.InvoiceSubscription, $root.lnrpc.Invoice, request, callback);
        }, "name", { value: "SubscribeInvoices" });

        /**
         * Calls SubscribeInvoices.
         * @function subscribeInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoiceSubscription} request InvoiceSubscription message or plain object
         * @returns {Promise<lnrpc.Invoice>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#decodePayReq}.
         * @memberof lnrpc.Lightning
         * @typedef DecodePayReqCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PayReq} [response] PayReq
         */

        /**
         * Calls DecodePayReq.
         * @function decodePayReq
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPayReqString} request PayReqString message or plain object
         * @param {lnrpc.Lightning.DecodePayReqCallback} callback Node-style callback called with the error, if any, and PayReq
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.decodePayReq = function decodePayReq(request, callback) {
            return this.rpcCall(decodePayReq, $root.lnrpc.PayReqString, $root.lnrpc.PayReq, request, callback);
        }, "name", { value: "DecodePayReq" });

        /**
         * Calls DecodePayReq.
         * @function decodePayReq
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPayReqString} request PayReqString message or plain object
         * @returns {Promise<lnrpc.PayReq>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPayments}.
         * @memberof lnrpc.Lightning
         * @typedef ListPaymentsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPaymentsResponse} [response] ListPaymentsResponse
         */

        /**
         * Calls ListPayments.
         * @function listPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPaymentsRequest} request ListPaymentsRequest message or plain object
         * @param {lnrpc.Lightning.ListPaymentsCallback} callback Node-style callback called with the error, if any, and ListPaymentsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPayments = function listPayments(request, callback) {
            return this.rpcCall(listPayments, $root.lnrpc.ListPaymentsRequest, $root.lnrpc.ListPaymentsResponse, request, callback);
        }, "name", { value: "ListPayments" });

        /**
         * Calls ListPayments.
         * @function listPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPaymentsRequest} request ListPaymentsRequest message or plain object
         * @returns {Promise<lnrpc.ListPaymentsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#deleteAllPayments}.
         * @memberof lnrpc.Lightning
         * @typedef DeleteAllPaymentsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DeleteAllPaymentsResponse} [response] DeleteAllPaymentsResponse
         */

        /**
         * Calls DeleteAllPayments.
         * @function deleteAllPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteAllPaymentsRequest} request DeleteAllPaymentsRequest message or plain object
         * @param {lnrpc.Lightning.DeleteAllPaymentsCallback} callback Node-style callback called with the error, if any, and DeleteAllPaymentsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.deleteAllPayments = function deleteAllPayments(request, callback) {
            return this.rpcCall(deleteAllPayments, $root.lnrpc.DeleteAllPaymentsRequest, $root.lnrpc.DeleteAllPaymentsResponse, request, callback);
        }, "name", { value: "DeleteAllPayments" });

        /**
         * Calls DeleteAllPayments.
         * @function deleteAllPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteAllPaymentsRequest} request DeleteAllPaymentsRequest message or plain object
         * @returns {Promise<lnrpc.DeleteAllPaymentsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#describeGraph}.
         * @memberof lnrpc.Lightning
         * @typedef DescribeGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelGraph} [response] ChannelGraph
         */

        /**
         * Calls DescribeGraph.
         * @function describeGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelGraphRequest} request ChannelGraphRequest message or plain object
         * @param {lnrpc.Lightning.DescribeGraphCallback} callback Node-style callback called with the error, if any, and ChannelGraph
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.describeGraph = function describeGraph(request, callback) {
            return this.rpcCall(describeGraph, $root.lnrpc.ChannelGraphRequest, $root.lnrpc.ChannelGraph, request, callback);
        }, "name", { value: "DescribeGraph" });

        /**
         * Calls DescribeGraph.
         * @function describeGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelGraphRequest} request ChannelGraphRequest message or plain object
         * @returns {Promise<lnrpc.ChannelGraph>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNodeMetrics}.
         * @memberof lnrpc.Lightning
         * @typedef GetNodeMetricsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NodeMetricsResponse} [response] NodeMetricsResponse
         */

        /**
         * Calls GetNodeMetrics.
         * @function getNodeMetrics
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeMetricsRequest} request NodeMetricsRequest message or plain object
         * @param {lnrpc.Lightning.GetNodeMetricsCallback} callback Node-style callback called with the error, if any, and NodeMetricsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNodeMetrics = function getNodeMetrics(request, callback) {
            return this.rpcCall(getNodeMetrics, $root.lnrpc.NodeMetricsRequest, $root.lnrpc.NodeMetricsResponse, request, callback);
        }, "name", { value: "GetNodeMetrics" });

        /**
         * Calls GetNodeMetrics.
         * @function getNodeMetrics
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeMetricsRequest} request NodeMetricsRequest message or plain object
         * @returns {Promise<lnrpc.NodeMetricsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getChanInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetChanInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelEdge} [response] ChannelEdge
         */

        /**
         * Calls GetChanInfo.
         * @function getChanInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanInfoRequest} request ChanInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetChanInfoCallback} callback Node-style callback called with the error, if any, and ChannelEdge
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getChanInfo = function getChanInfo(request, callback) {
            return this.rpcCall(getChanInfo, $root.lnrpc.ChanInfoRequest, $root.lnrpc.ChannelEdge, request, callback);
        }, "name", { value: "GetChanInfo" });

        /**
         * Calls GetChanInfo.
         * @function getChanInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanInfoRequest} request ChanInfoRequest message or plain object
         * @returns {Promise<lnrpc.ChannelEdge>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNodeInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetNodeInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NodeInfo} [response] NodeInfo
         */

        /**
         * Calls GetNodeInfo.
         * @function getNodeInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeInfoRequest} request NodeInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetNodeInfoCallback} callback Node-style callback called with the error, if any, and NodeInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNodeInfo = function getNodeInfo(request, callback) {
            return this.rpcCall(getNodeInfo, $root.lnrpc.NodeInfoRequest, $root.lnrpc.NodeInfo, request, callback);
        }, "name", { value: "GetNodeInfo" });

        /**
         * Calls GetNodeInfo.
         * @function getNodeInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeInfoRequest} request NodeInfoRequest message or plain object
         * @returns {Promise<lnrpc.NodeInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#queryRoutes}.
         * @memberof lnrpc.Lightning
         * @typedef QueryRoutesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.QueryRoutesResponse} [response] QueryRoutesResponse
         */

        /**
         * Calls QueryRoutes.
         * @function queryRoutes
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IQueryRoutesRequest} request QueryRoutesRequest message or plain object
         * @param {lnrpc.Lightning.QueryRoutesCallback} callback Node-style callback called with the error, if any, and QueryRoutesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.queryRoutes = function queryRoutes(request, callback) {
            return this.rpcCall(queryRoutes, $root.lnrpc.QueryRoutesRequest, $root.lnrpc.QueryRoutesResponse, request, callback);
        }, "name", { value: "QueryRoutes" });

        /**
         * Calls QueryRoutes.
         * @function queryRoutes
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IQueryRoutesRequest} request QueryRoutesRequest message or plain object
         * @returns {Promise<lnrpc.QueryRoutesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNetworkInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetNetworkInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NetworkInfo} [response] NetworkInfo
         */

        /**
         * Calls GetNetworkInfo.
         * @function getNetworkInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INetworkInfoRequest} request NetworkInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetNetworkInfoCallback} callback Node-style callback called with the error, if any, and NetworkInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNetworkInfo = function getNetworkInfo(request, callback) {
            return this.rpcCall(getNetworkInfo, $root.lnrpc.NetworkInfoRequest, $root.lnrpc.NetworkInfo, request, callback);
        }, "name", { value: "GetNetworkInfo" });

        /**
         * Calls GetNetworkInfo.
         * @function getNetworkInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INetworkInfoRequest} request NetworkInfoRequest message or plain object
         * @returns {Promise<lnrpc.NetworkInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#stopDaemon}.
         * @memberof lnrpc.Lightning
         * @typedef StopDaemonCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.StopResponse} [response] StopResponse
         */

        /**
         * Calls StopDaemon.
         * @function stopDaemon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IStopRequest} request StopRequest message or plain object
         * @param {lnrpc.Lightning.StopDaemonCallback} callback Node-style callback called with the error, if any, and StopResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.stopDaemon = function stopDaemon(request, callback) {
            return this.rpcCall(stopDaemon, $root.lnrpc.StopRequest, $root.lnrpc.StopResponse, request, callback);
        }, "name", { value: "StopDaemon" });

        /**
         * Calls StopDaemon.
         * @function stopDaemon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IStopRequest} request StopRequest message or plain object
         * @returns {Promise<lnrpc.StopResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelGraph}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GraphTopologyUpdate} [response] GraphTopologyUpdate
         */

        /**
         * Calls SubscribeChannelGraph.
         * @function subscribeChannelGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGraphTopologySubscription} request GraphTopologySubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelGraphCallback} callback Node-style callback called with the error, if any, and GraphTopologyUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelGraph = function subscribeChannelGraph(request, callback) {
            return this.rpcCall(subscribeChannelGraph, $root.lnrpc.GraphTopologySubscription, $root.lnrpc.GraphTopologyUpdate, request, callback);
        }, "name", { value: "SubscribeChannelGraph" });

        /**
         * Calls SubscribeChannelGraph.
         * @function subscribeChannelGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGraphTopologySubscription} request GraphTopologySubscription message or plain object
         * @returns {Promise<lnrpc.GraphTopologyUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#debugLevel}.
         * @memberof lnrpc.Lightning
         * @typedef DebugLevelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DebugLevelResponse} [response] DebugLevelResponse
         */

        /**
         * Calls DebugLevel.
         * @function debugLevel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDebugLevelRequest} request DebugLevelRequest message or plain object
         * @param {lnrpc.Lightning.DebugLevelCallback} callback Node-style callback called with the error, if any, and DebugLevelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.debugLevel = function debugLevel(request, callback) {
            return this.rpcCall(debugLevel, $root.lnrpc.DebugLevelRequest, $root.lnrpc.DebugLevelResponse, request, callback);
        }, "name", { value: "DebugLevel" });

        /**
         * Calls DebugLevel.
         * @function debugLevel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDebugLevelRequest} request DebugLevelRequest message or plain object
         * @returns {Promise<lnrpc.DebugLevelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#feeReport}.
         * @memberof lnrpc.Lightning
         * @typedef FeeReportCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.FeeReportResponse} [response] FeeReportResponse
         */

        /**
         * Calls FeeReport.
         * @function feeReport
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFeeReportRequest} request FeeReportRequest message or plain object
         * @param {lnrpc.Lightning.FeeReportCallback} callback Node-style callback called with the error, if any, and FeeReportResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.feeReport = function feeReport(request, callback) {
            return this.rpcCall(feeReport, $root.lnrpc.FeeReportRequest, $root.lnrpc.FeeReportResponse, request, callback);
        }, "name", { value: "FeeReport" });

        /**
         * Calls FeeReport.
         * @function feeReport
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFeeReportRequest} request FeeReportRequest message or plain object
         * @returns {Promise<lnrpc.FeeReportResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#updateChannelPolicy}.
         * @memberof lnrpc.Lightning
         * @typedef UpdateChannelPolicyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PolicyUpdateResponse} [response] PolicyUpdateResponse
         */

        /**
         * Calls UpdateChannelPolicy.
         * @function updateChannelPolicy
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPolicyUpdateRequest} request PolicyUpdateRequest message or plain object
         * @param {lnrpc.Lightning.UpdateChannelPolicyCallback} callback Node-style callback called with the error, if any, and PolicyUpdateResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.updateChannelPolicy = function updateChannelPolicy(request, callback) {
            return this.rpcCall(updateChannelPolicy, $root.lnrpc.PolicyUpdateRequest, $root.lnrpc.PolicyUpdateResponse, request, callback);
        }, "name", { value: "UpdateChannelPolicy" });

        /**
         * Calls UpdateChannelPolicy.
         * @function updateChannelPolicy
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPolicyUpdateRequest} request PolicyUpdateRequest message or plain object
         * @returns {Promise<lnrpc.PolicyUpdateResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#forwardingHistory}.
         * @memberof lnrpc.Lightning
         * @typedef ForwardingHistoryCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ForwardingHistoryResponse} [response] ForwardingHistoryResponse
         */

        /**
         * Calls ForwardingHistory.
         * @function forwardingHistory
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IForwardingHistoryRequest} request ForwardingHistoryRequest message or plain object
         * @param {lnrpc.Lightning.ForwardingHistoryCallback} callback Node-style callback called with the error, if any, and ForwardingHistoryResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.forwardingHistory = function forwardingHistory(request, callback) {
            return this.rpcCall(forwardingHistory, $root.lnrpc.ForwardingHistoryRequest, $root.lnrpc.ForwardingHistoryResponse, request, callback);
        }, "name", { value: "ForwardingHistory" });

        /**
         * Calls ForwardingHistory.
         * @function forwardingHistory
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IForwardingHistoryRequest} request ForwardingHistoryRequest message or plain object
         * @returns {Promise<lnrpc.ForwardingHistoryResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#exportChannelBackup}.
         * @memberof lnrpc.Lightning
         * @typedef ExportChannelBackupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelBackup} [response] ChannelBackup
         */

        /**
         * Calls ExportChannelBackup.
         * @function exportChannelBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IExportChannelBackupRequest} request ExportChannelBackupRequest message or plain object
         * @param {lnrpc.Lightning.ExportChannelBackupCallback} callback Node-style callback called with the error, if any, and ChannelBackup
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.exportChannelBackup = function exportChannelBackup(request, callback) {
            return this.rpcCall(exportChannelBackup, $root.lnrpc.ExportChannelBackupRequest, $root.lnrpc.ChannelBackup, request, callback);
        }, "name", { value: "ExportChannelBackup" });

        /**
         * Calls ExportChannelBackup.
         * @function exportChannelBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IExportChannelBackupRequest} request ExportChannelBackupRequest message or plain object
         * @returns {Promise<lnrpc.ChannelBackup>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#exportAllChannelBackups}.
         * @memberof lnrpc.Lightning
         * @typedef ExportAllChannelBackupsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChanBackupSnapshot} [response] ChanBackupSnapshot
         */

        /**
         * Calls ExportAllChannelBackups.
         * @function exportAllChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupExportRequest} request ChanBackupExportRequest message or plain object
         * @param {lnrpc.Lightning.ExportAllChannelBackupsCallback} callback Node-style callback called with the error, if any, and ChanBackupSnapshot
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.exportAllChannelBackups = function exportAllChannelBackups(request, callback) {
            return this.rpcCall(exportAllChannelBackups, $root.lnrpc.ChanBackupExportRequest, $root.lnrpc.ChanBackupSnapshot, request, callback);
        }, "name", { value: "ExportAllChannelBackups" });

        /**
         * Calls ExportAllChannelBackups.
         * @function exportAllChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupExportRequest} request ChanBackupExportRequest message or plain object
         * @returns {Promise<lnrpc.ChanBackupSnapshot>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#verifyChanBackup}.
         * @memberof lnrpc.Lightning
         * @typedef VerifyChanBackupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.VerifyChanBackupResponse} [response] VerifyChanBackupResponse
         */

        /**
         * Calls VerifyChanBackup.
         * @function verifyChanBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupSnapshot} request ChanBackupSnapshot message or plain object
         * @param {lnrpc.Lightning.VerifyChanBackupCallback} callback Node-style callback called with the error, if any, and VerifyChanBackupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.verifyChanBackup = function verifyChanBackup(request, callback) {
            return this.rpcCall(verifyChanBackup, $root.lnrpc.ChanBackupSnapshot, $root.lnrpc.VerifyChanBackupResponse, request, callback);
        }, "name", { value: "VerifyChanBackup" });

        /**
         * Calls VerifyChanBackup.
         * @function verifyChanBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupSnapshot} request ChanBackupSnapshot message or plain object
         * @returns {Promise<lnrpc.VerifyChanBackupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#restoreChannelBackups}.
         * @memberof lnrpc.Lightning
         * @typedef RestoreChannelBackupsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.RestoreBackupResponse} [response] RestoreBackupResponse
         */

        /**
         * Calls RestoreChannelBackups.
         * @function restoreChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IRestoreChanBackupRequest} request RestoreChanBackupRequest message or plain object
         * @param {lnrpc.Lightning.RestoreChannelBackupsCallback} callback Node-style callback called with the error, if any, and RestoreBackupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.restoreChannelBackups = function restoreChannelBackups(request, callback) {
            return this.rpcCall(restoreChannelBackups, $root.lnrpc.RestoreChanBackupRequest, $root.lnrpc.RestoreBackupResponse, request, callback);
        }, "name", { value: "RestoreChannelBackups" });

        /**
         * Calls RestoreChannelBackups.
         * @function restoreChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IRestoreChanBackupRequest} request RestoreChanBackupRequest message or plain object
         * @returns {Promise<lnrpc.RestoreBackupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelBackups}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelBackupsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChanBackupSnapshot} [response] ChanBackupSnapshot
         */

        /**
         * Calls SubscribeChannelBackups.
         * @function subscribeChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBackupSubscription} request ChannelBackupSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelBackupsCallback} callback Node-style callback called with the error, if any, and ChanBackupSnapshot
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelBackups = function subscribeChannelBackups(request, callback) {
            return this.rpcCall(subscribeChannelBackups, $root.lnrpc.ChannelBackupSubscription, $root.lnrpc.ChanBackupSnapshot, request, callback);
        }, "name", { value: "SubscribeChannelBackups" });

        /**
         * Calls SubscribeChannelBackups.
         * @function subscribeChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBackupSubscription} request ChannelBackupSubscription message or plain object
         * @returns {Promise<lnrpc.ChanBackupSnapshot>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#bakeMacaroon}.
         * @memberof lnrpc.Lightning
         * @typedef BakeMacaroonCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.BakeMacaroonResponse} [response] BakeMacaroonResponse
         */

        /**
         * Calls BakeMacaroon.
         * @function bakeMacaroon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IBakeMacaroonRequest} request BakeMacaroonRequest message or plain object
         * @param {lnrpc.Lightning.BakeMacaroonCallback} callback Node-style callback called with the error, if any, and BakeMacaroonResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.bakeMacaroon = function bakeMacaroon(request, callback) {
            return this.rpcCall(bakeMacaroon, $root.lnrpc.BakeMacaroonRequest, $root.lnrpc.BakeMacaroonResponse, request, callback);
        }, "name", { value: "BakeMacaroon" });

        /**
         * Calls BakeMacaroon.
         * @function bakeMacaroon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IBakeMacaroonRequest} request BakeMacaroonRequest message or plain object
         * @returns {Promise<lnrpc.BakeMacaroonResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listMacaroonIDs}.
         * @memberof lnrpc.Lightning
         * @typedef ListMacaroonIDsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListMacaroonIDsResponse} [response] ListMacaroonIDsResponse
         */

        /**
         * Calls ListMacaroonIDs.
         * @function listMacaroonIDs
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListMacaroonIDsRequest} request ListMacaroonIDsRequest message or plain object
         * @param {lnrpc.Lightning.ListMacaroonIDsCallback} callback Node-style callback called with the error, if any, and ListMacaroonIDsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listMacaroonIDs = function listMacaroonIDs(request, callback) {
            return this.rpcCall(listMacaroonIDs, $root.lnrpc.ListMacaroonIDsRequest, $root.lnrpc.ListMacaroonIDsResponse, request, callback);
        }, "name", { value: "ListMacaroonIDs" });

        /**
         * Calls ListMacaroonIDs.
         * @function listMacaroonIDs
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListMacaroonIDsRequest} request ListMacaroonIDsRequest message or plain object
         * @returns {Promise<lnrpc.ListMacaroonIDsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#deleteMacaroonID}.
         * @memberof lnrpc.Lightning
         * @typedef DeleteMacaroonIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DeleteMacaroonIDResponse} [response] DeleteMacaroonIDResponse
         */

        /**
         * Calls DeleteMacaroonID.
         * @function deleteMacaroonID
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteMacaroonIDRequest} request DeleteMacaroonIDRequest message or plain object
         * @param {lnrpc.Lightning.DeleteMacaroonIDCallback} callback Node-style callback called with the error, if any, and DeleteMacaroonIDResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.deleteMacaroonID = function deleteMacaroonID(request, callback) {
            return this.rpcCall(deleteMacaroonID, $root.lnrpc.DeleteMacaroonIDRequest, $root.lnrpc.DeleteMacaroonIDResponse, request, callback);
        }, "name", { value: "DeleteMacaroonID" });

        /**
         * Calls DeleteMacaroonID.
         * @function deleteMacaroonID
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteMacaroonIDRequest} request DeleteMacaroonIDRequest message or plain object
         * @returns {Promise<lnrpc.DeleteMacaroonIDResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPermissions}.
         * @memberof lnrpc.Lightning
         * @typedef ListPermissionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPermissionsResponse} [response] ListPermissionsResponse
         */

        /**
         * Calls ListPermissions.
         * @function listPermissions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPermissionsRequest} request ListPermissionsRequest message or plain object
         * @param {lnrpc.Lightning.ListPermissionsCallback} callback Node-style callback called with the error, if any, and ListPermissionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPermissions = function listPermissions(request, callback) {
            return this.rpcCall(listPermissions, $root.lnrpc.ListPermissionsRequest, $root.lnrpc.ListPermissionsResponse, request, callback);
        }, "name", { value: "ListPermissions" });

        /**
         * Calls ListPermissions.
         * @function listPermissions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPermissionsRequest} request ListPermissionsRequest message or plain object
         * @returns {Promise<lnrpc.ListPermissionsResponse>} Promise
         * @variation 2
         */

        return Lightning;
    })();

    lnrpc.Utxo = (function() {

        /**
         * Properties of an Utxo.
         * @memberof lnrpc
         * @interface IUtxo
         * @property {lnrpc.AddressType|null} [addressType] Utxo addressType
         * @property {string|null} [address] Utxo address
         * @property {number|Long|null} [amountSat] Utxo amountSat
         * @property {string|null} [pkScript] Utxo pkScript
         * @property {lnrpc.IOutPoint|null} [outpoint] Utxo outpoint
         * @property {number|Long|null} [confirmations] Utxo confirmations
         */

        /**
         * Constructs a new Utxo.
         * @memberof lnrpc
         * @classdesc Represents an Utxo.
         * @implements IUtxo
         * @constructor
         * @param {lnrpc.IUtxo=} [properties] Properties to set
         */
        function Utxo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Utxo addressType.
         * @member {lnrpc.AddressType} addressType
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.addressType = 0;

        /**
         * Utxo address.
         * @member {string} address
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.address = "";

        /**
         * Utxo amountSat.
         * @member {number|Long} amountSat
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.amountSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Utxo pkScript.
         * @member {string} pkScript
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.pkScript = "";

        /**
         * Utxo outpoint.
         * @member {lnrpc.IOutPoint|null|undefined} outpoint
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.outpoint = null;

        /**
         * Utxo confirmations.
         * @member {number|Long} confirmations
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.confirmations = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Utxo instance using the specified properties.
         * @function create
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.IUtxo=} [properties] Properties to set
         * @returns {lnrpc.Utxo} Utxo instance
         */
        Utxo.create = function create(properties) {
            return new Utxo(properties);
        };

        /**
         * Encodes the specified Utxo message. Does not implicitly {@link lnrpc.Utxo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.IUtxo} message Utxo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Utxo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addressType != null && Object.hasOwnProperty.call(message, "addressType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.addressType);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
            if (message.amountSat != null && Object.hasOwnProperty.call(message, "amountSat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amountSat);
            if (message.pkScript != null && Object.hasOwnProperty.call(message, "pkScript"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.pkScript);
            if (message.outpoint != null && Object.hasOwnProperty.call(message, "outpoint"))
                $root.lnrpc.OutPoint.encode(message.outpoint, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.confirmations != null && Object.hasOwnProperty.call(message, "confirmations"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.confirmations);
            return writer;
        };

        /**
         * Encodes the specified Utxo message, length delimited. Does not implicitly {@link lnrpc.Utxo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.IUtxo} message Utxo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Utxo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Utxo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Utxo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Utxo} Utxo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Utxo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Utxo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addressType = reader.int32();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                case 3:
                    message.amountSat = reader.int64();
                    break;
                case 4:
                    message.pkScript = reader.string();
                    break;
                case 5:
                    message.outpoint = $root.lnrpc.OutPoint.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.confirmations = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Utxo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Utxo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Utxo} Utxo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Utxo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Utxo message.
         * @function verify
         * @memberof lnrpc.Utxo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Utxo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addressType != null && message.hasOwnProperty("addressType"))
                switch (message.addressType) {
                default:
                    return "addressType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                if (!$util.isInteger(message.amountSat) && !(message.amountSat && $util.isInteger(message.amountSat.low) && $util.isInteger(message.amountSat.high)))
                    return "amountSat: integer|Long expected";
            if (message.pkScript != null && message.hasOwnProperty("pkScript"))
                if (!$util.isString(message.pkScript))
                    return "pkScript: string expected";
            if (message.outpoint != null && message.hasOwnProperty("outpoint")) {
                let error = $root.lnrpc.OutPoint.verify(message.outpoint);
                if (error)
                    return "outpoint." + error;
            }
            if (message.confirmations != null && message.hasOwnProperty("confirmations"))
                if (!$util.isInteger(message.confirmations) && !(message.confirmations && $util.isInteger(message.confirmations.low) && $util.isInteger(message.confirmations.high)))
                    return "confirmations: integer|Long expected";
            return null;
        };

        /**
         * Creates an Utxo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Utxo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Utxo} Utxo
         */
        Utxo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Utxo)
                return object;
            let message = new $root.lnrpc.Utxo();
            switch (object.addressType) {
            case "WITNESS_PUBKEY_HASH":
            case 0:
                message.addressType = 0;
                break;
            case "NESTED_PUBKEY_HASH":
            case 1:
                message.addressType = 1;
                break;
            case "UNUSED_WITNESS_PUBKEY_HASH":
            case 2:
                message.addressType = 2;
                break;
            case "UNUSED_NESTED_PUBKEY_HASH":
            case 3:
                message.addressType = 3;
                break;
            }
            if (object.address != null)
                message.address = String(object.address);
            if (object.amountSat != null)
                if ($util.Long)
                    (message.amountSat = $util.Long.fromValue(object.amountSat)).unsigned = false;
                else if (typeof object.amountSat === "string")
                    message.amountSat = parseInt(object.amountSat, 10);
                else if (typeof object.amountSat === "number")
                    message.amountSat = object.amountSat;
                else if (typeof object.amountSat === "object")
                    message.amountSat = new $util.LongBits(object.amountSat.low >>> 0, object.amountSat.high >>> 0).toNumber();
            if (object.pkScript != null)
                message.pkScript = String(object.pkScript);
            if (object.outpoint != null) {
                if (typeof object.outpoint !== "object")
                    throw TypeError(".lnrpc.Utxo.outpoint: object expected");
                message.outpoint = $root.lnrpc.OutPoint.fromObject(object.outpoint);
            }
            if (object.confirmations != null)
                if ($util.Long)
                    (message.confirmations = $util.Long.fromValue(object.confirmations)).unsigned = false;
                else if (typeof object.confirmations === "string")
                    message.confirmations = parseInt(object.confirmations, 10);
                else if (typeof object.confirmations === "number")
                    message.confirmations = object.confirmations;
                else if (typeof object.confirmations === "object")
                    message.confirmations = new $util.LongBits(object.confirmations.low >>> 0, object.confirmations.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Utxo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.Utxo} message Utxo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Utxo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addressType = options.enums === String ? "WITNESS_PUBKEY_HASH" : 0;
                object.address = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amountSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amountSat = options.longs === String ? "0" : 0;
                object.pkScript = "";
                object.outpoint = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.confirmations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.confirmations = options.longs === String ? "0" : 0;
            }
            if (message.addressType != null && message.hasOwnProperty("addressType"))
                object.addressType = options.enums === String ? $root.lnrpc.AddressType[message.addressType] : message.addressType;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                if (typeof message.amountSat === "number")
                    object.amountSat = options.longs === String ? String(message.amountSat) : message.amountSat;
                else
                    object.amountSat = options.longs === String ? $util.Long.prototype.toString.call(message.amountSat) : options.longs === Number ? new $util.LongBits(message.amountSat.low >>> 0, message.amountSat.high >>> 0).toNumber() : message.amountSat;
            if (message.pkScript != null && message.hasOwnProperty("pkScript"))
                object.pkScript = message.pkScript;
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                object.outpoint = $root.lnrpc.OutPoint.toObject(message.outpoint, options);
            if (message.confirmations != null && message.hasOwnProperty("confirmations"))
                if (typeof message.confirmations === "number")
                    object.confirmations = options.longs === String ? String(message.confirmations) : message.confirmations;
                else
                    object.confirmations = options.longs === String ? $util.Long.prototype.toString.call(message.confirmations) : options.longs === Number ? new $util.LongBits(message.confirmations.low >>> 0, message.confirmations.high >>> 0).toNumber() : message.confirmations;
            return object;
        };

        /**
         * Converts this Utxo to JSON.
         * @function toJSON
         * @memberof lnrpc.Utxo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Utxo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Utxo;
    })();

    lnrpc.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof lnrpc
         * @interface ITransaction
         * @property {string|null} [txHash] Transaction txHash
         * @property {number|Long|null} [amount] Transaction amount
         * @property {number|null} [numConfirmations] Transaction numConfirmations
         * @property {string|null} [blockHash] Transaction blockHash
         * @property {number|null} [blockHeight] Transaction blockHeight
         * @property {number|Long|null} [timeStamp] Transaction timeStamp
         * @property {number|Long|null} [totalFees] Transaction totalFees
         * @property {Array.<string>|null} [destAddresses] Transaction destAddresses
         * @property {string|null} [rawTxHex] Transaction rawTxHex
         * @property {string|null} [label] Transaction label
         */

        /**
         * Constructs a new Transaction.
         * @memberof lnrpc
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {lnrpc.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            this.destAddresses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transaction txHash.
         * @member {string} txHash
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.txHash = "";

        /**
         * Transaction amount.
         * @member {number|Long} amount
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Transaction numConfirmations.
         * @member {number} numConfirmations
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.numConfirmations = 0;

        /**
         * Transaction blockHash.
         * @member {string} blockHash
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.blockHash = "";

        /**
         * Transaction blockHeight.
         * @member {number} blockHeight
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.blockHeight = 0;

        /**
         * Transaction timeStamp.
         * @member {number|Long} timeStamp
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.timeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Transaction totalFees.
         * @member {number|Long} totalFees
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.totalFees = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Transaction destAddresses.
         * @member {Array.<string>} destAddresses
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.destAddresses = $util.emptyArray;

        /**
         * Transaction rawTxHex.
         * @member {string} rawTxHex
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.rawTxHex = "";

        /**
         * Transaction label.
         * @member {string} label
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.label = "";

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction=} [properties] Properties to set
         * @returns {lnrpc.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link lnrpc.Transaction.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txHash != null && Object.hasOwnProperty.call(message, "txHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txHash);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.numConfirmations != null && Object.hasOwnProperty.call(message, "numConfirmations"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numConfirmations);
            if (message.blockHash != null && Object.hasOwnProperty.call(message, "blockHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.blockHash);
            if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blockHeight);
            if (message.timeStamp != null && Object.hasOwnProperty.call(message, "timeStamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeStamp);
            if (message.totalFees != null && Object.hasOwnProperty.call(message, "totalFees"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.totalFees);
            if (message.destAddresses != null && message.destAddresses.length)
                for (let i = 0; i < message.destAddresses.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.destAddresses[i]);
            if (message.rawTxHex != null && Object.hasOwnProperty.call(message, "rawTxHex"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.rawTxHex);
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.label);
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link lnrpc.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Transaction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txHash = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.numConfirmations = reader.int32();
                    break;
                case 4:
                    message.blockHash = reader.string();
                    break;
                case 5:
                    message.blockHeight = reader.int32();
                    break;
                case 6:
                    message.timeStamp = reader.int64();
                    break;
                case 7:
                    message.totalFees = reader.int64();
                    break;
                case 8:
                    if (!(message.destAddresses && message.destAddresses.length))
                        message.destAddresses = [];
                    message.destAddresses.push(reader.string());
                    break;
                case 9:
                    message.rawTxHex = reader.string();
                    break;
                case 10:
                    message.label = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof lnrpc.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                if (!$util.isString(message.txHash))
                    return "txHash: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                if (!$util.isInteger(message.numConfirmations))
                    return "numConfirmations: integer expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (!$util.isInteger(message.timeStamp) && !(message.timeStamp && $util.isInteger(message.timeStamp.low) && $util.isInteger(message.timeStamp.high)))
                    return "timeStamp: integer|Long expected";
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (!$util.isInteger(message.totalFees) && !(message.totalFees && $util.isInteger(message.totalFees.low) && $util.isInteger(message.totalFees.high)))
                    return "totalFees: integer|Long expected";
            if (message.destAddresses != null && message.hasOwnProperty("destAddresses")) {
                if (!Array.isArray(message.destAddresses))
                    return "destAddresses: array expected";
                for (let i = 0; i < message.destAddresses.length; ++i)
                    if (!$util.isString(message.destAddresses[i]))
                        return "destAddresses: string[] expected";
            }
            if (message.rawTxHex != null && message.hasOwnProperty("rawTxHex"))
                if (!$util.isString(message.rawTxHex))
                    return "rawTxHex: string expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Transaction)
                return object;
            let message = new $root.lnrpc.Transaction();
            if (object.txHash != null)
                message.txHash = String(object.txHash);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.numConfirmations != null)
                message.numConfirmations = object.numConfirmations | 0;
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight | 0;
            if (object.timeStamp != null)
                if ($util.Long)
                    (message.timeStamp = $util.Long.fromValue(object.timeStamp)).unsigned = false;
                else if (typeof object.timeStamp === "string")
                    message.timeStamp = parseInt(object.timeStamp, 10);
                else if (typeof object.timeStamp === "number")
                    message.timeStamp = object.timeStamp;
                else if (typeof object.timeStamp === "object")
                    message.timeStamp = new $util.LongBits(object.timeStamp.low >>> 0, object.timeStamp.high >>> 0).toNumber();
            if (object.totalFees != null)
                if ($util.Long)
                    (message.totalFees = $util.Long.fromValue(object.totalFees)).unsigned = false;
                else if (typeof object.totalFees === "string")
                    message.totalFees = parseInt(object.totalFees, 10);
                else if (typeof object.totalFees === "number")
                    message.totalFees = object.totalFees;
                else if (typeof object.totalFees === "object")
                    message.totalFees = new $util.LongBits(object.totalFees.low >>> 0, object.totalFees.high >>> 0).toNumber();
            if (object.destAddresses) {
                if (!Array.isArray(object.destAddresses))
                    throw TypeError(".lnrpc.Transaction.destAddresses: array expected");
                message.destAddresses = [];
                for (let i = 0; i < object.destAddresses.length; ++i)
                    message.destAddresses[i] = String(object.destAddresses[i]);
            }
            if (object.rawTxHex != null)
                message.rawTxHex = String(object.rawTxHex);
            if (object.label != null)
                message.label = String(object.label);
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.destAddresses = [];
            if (options.defaults) {
                object.txHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.numConfirmations = 0;
                object.blockHash = "";
                object.blockHeight = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeStamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalFees = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFees = options.longs === String ? "0" : 0;
                object.rawTxHex = "";
                object.label = "";
            }
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                object.txHash = message.txHash;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                object.numConfirmations = message.numConfirmations;
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (typeof message.timeStamp === "number")
                    object.timeStamp = options.longs === String ? String(message.timeStamp) : message.timeStamp;
                else
                    object.timeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.timeStamp) : options.longs === Number ? new $util.LongBits(message.timeStamp.low >>> 0, message.timeStamp.high >>> 0).toNumber() : message.timeStamp;
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (typeof message.totalFees === "number")
                    object.totalFees = options.longs === String ? String(message.totalFees) : message.totalFees;
                else
                    object.totalFees = options.longs === String ? $util.Long.prototype.toString.call(message.totalFees) : options.longs === Number ? new $util.LongBits(message.totalFees.low >>> 0, message.totalFees.high >>> 0).toNumber() : message.totalFees;
            if (message.destAddresses && message.destAddresses.length) {
                object.destAddresses = [];
                for (let j = 0; j < message.destAddresses.length; ++j)
                    object.destAddresses[j] = message.destAddresses[j];
            }
            if (message.rawTxHex != null && message.hasOwnProperty("rawTxHex"))
                object.rawTxHex = message.rawTxHex;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof lnrpc.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transaction;
    })();

    lnrpc.GetTransactionsRequest = (function() {

        /**
         * Properties of a GetTransactionsRequest.
         * @memberof lnrpc
         * @interface IGetTransactionsRequest
         * @property {number|null} [startHeight] GetTransactionsRequest startHeight
         * @property {number|null} [endHeight] GetTransactionsRequest endHeight
         */

        /**
         * Constructs a new GetTransactionsRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetTransactionsRequest.
         * @implements IGetTransactionsRequest
         * @constructor
         * @param {lnrpc.IGetTransactionsRequest=} [properties] Properties to set
         */
        function GetTransactionsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTransactionsRequest startHeight.
         * @member {number} startHeight
         * @memberof lnrpc.GetTransactionsRequest
         * @instance
         */
        GetTransactionsRequest.prototype.startHeight = 0;

        /**
         * GetTransactionsRequest endHeight.
         * @member {number} endHeight
         * @memberof lnrpc.GetTransactionsRequest
         * @instance
         */
        GetTransactionsRequest.prototype.endHeight = 0;

        /**
         * Creates a new GetTransactionsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest=} [properties] Properties to set
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest instance
         */
        GetTransactionsRequest.create = function create(properties) {
            return new GetTransactionsRequest(properties);
        };

        /**
         * Encodes the specified GetTransactionsRequest message. Does not implicitly {@link lnrpc.GetTransactionsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest} message GetTransactionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransactionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.startHeight);
            if (message.endHeight != null && Object.hasOwnProperty.call(message, "endHeight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endHeight);
            return writer;
        };

        /**
         * Encodes the specified GetTransactionsRequest message, length delimited. Does not implicitly {@link lnrpc.GetTransactionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest} message GetTransactionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransactionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTransactionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransactionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetTransactionsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startHeight = reader.int32();
                    break;
                case 2:
                    message.endHeight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTransactionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransactionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTransactionsRequest message.
         * @function verify
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTransactionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                if (!$util.isInteger(message.startHeight))
                    return "startHeight: integer expected";
            if (message.endHeight != null && message.hasOwnProperty("endHeight"))
                if (!$util.isInteger(message.endHeight))
                    return "endHeight: integer expected";
            return null;
        };

        /**
         * Creates a GetTransactionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         */
        GetTransactionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetTransactionsRequest)
                return object;
            let message = new $root.lnrpc.GetTransactionsRequest();
            if (object.startHeight != null)
                message.startHeight = object.startHeight | 0;
            if (object.endHeight != null)
                message.endHeight = object.endHeight | 0;
            return message;
        };

        /**
         * Creates a plain object from a GetTransactionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.GetTransactionsRequest} message GetTransactionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTransactionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.startHeight = 0;
                object.endHeight = 0;
            }
            if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                object.startHeight = message.startHeight;
            if (message.endHeight != null && message.hasOwnProperty("endHeight"))
                object.endHeight = message.endHeight;
            return object;
        };

        /**
         * Converts this GetTransactionsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetTransactionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTransactionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTransactionsRequest;
    })();

    lnrpc.TransactionDetails = (function() {

        /**
         * Properties of a TransactionDetails.
         * @memberof lnrpc
         * @interface ITransactionDetails
         * @property {Array.<lnrpc.ITransaction>|null} [transactions] TransactionDetails transactions
         */

        /**
         * Constructs a new TransactionDetails.
         * @memberof lnrpc
         * @classdesc Represents a TransactionDetails.
         * @implements ITransactionDetails
         * @constructor
         * @param {lnrpc.ITransactionDetails=} [properties] Properties to set
         */
        function TransactionDetails(properties) {
            this.transactions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionDetails transactions.
         * @member {Array.<lnrpc.ITransaction>} transactions
         * @memberof lnrpc.TransactionDetails
         * @instance
         */
        TransactionDetails.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new TransactionDetails instance using the specified properties.
         * @function create
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails=} [properties] Properties to set
         * @returns {lnrpc.TransactionDetails} TransactionDetails instance
         */
        TransactionDetails.create = function create(properties) {
            return new TransactionDetails(properties);
        };

        /**
         * Encodes the specified TransactionDetails message. Does not implicitly {@link lnrpc.TransactionDetails.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails} message TransactionDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (let i = 0; i < message.transactions.length; ++i)
                    $root.lnrpc.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionDetails message, length delimited. Does not implicitly {@link lnrpc.TransactionDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails} message TransactionDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionDetails message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.TransactionDetails();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.lnrpc.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionDetails message.
         * @function verify
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (let i = 0; i < message.transactions.length; ++i) {
                    let error = $root.lnrpc.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         */
        TransactionDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.TransactionDetails)
                return object;
            let message = new $root.lnrpc.TransactionDetails();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".lnrpc.TransactionDetails.transactions: array expected");
                message.transactions = [];
                for (let i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".lnrpc.TransactionDetails.transactions: object expected");
                    message.transactions[i] = $root.lnrpc.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.TransactionDetails} message TransactionDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (let j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.lnrpc.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this TransactionDetails to JSON.
         * @function toJSON
         * @memberof lnrpc.TransactionDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionDetails;
    })();

    lnrpc.FeeLimit = (function() {

        /**
         * Properties of a FeeLimit.
         * @memberof lnrpc
         * @interface IFeeLimit
         * @property {number|Long|null} [fixed] FeeLimit fixed
         * @property {number|Long|null} [fixedMsat] FeeLimit fixedMsat
         * @property {number|Long|null} [percent] FeeLimit percent
         */

        /**
         * Constructs a new FeeLimit.
         * @memberof lnrpc
         * @classdesc Represents a FeeLimit.
         * @implements IFeeLimit
         * @constructor
         * @param {lnrpc.IFeeLimit=} [properties] Properties to set
         */
        function FeeLimit(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeLimit fixed.
         * @member {number|Long|null|undefined} fixed
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.fixed = null;

        /**
         * FeeLimit fixedMsat.
         * @member {number|Long|null|undefined} fixedMsat
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.fixedMsat = null;

        /**
         * FeeLimit percent.
         * @member {number|Long|null|undefined} percent
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.percent = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * FeeLimit limit.
         * @member {"fixed"|"fixedMsat"|"percent"|undefined} limit
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        Object.defineProperty(FeeLimit.prototype, "limit", {
            get: $util.oneOfGetter($oneOfFields = ["fixed", "fixedMsat", "percent"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FeeLimit instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit=} [properties] Properties to set
         * @returns {lnrpc.FeeLimit} FeeLimit instance
         */
        FeeLimit.create = function create(properties) {
            return new FeeLimit(properties);
        };

        /**
         * Encodes the specified FeeLimit message. Does not implicitly {@link lnrpc.FeeLimit.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit} message FeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeLimit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fixed != null && Object.hasOwnProperty.call(message, "fixed"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fixed);
            if (message.percent != null && Object.hasOwnProperty.call(message, "percent"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.percent);
            if (message.fixedMsat != null && Object.hasOwnProperty.call(message, "fixedMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fixedMsat);
            return writer;
        };

        /**
         * Encodes the specified FeeLimit message, length delimited. Does not implicitly {@link lnrpc.FeeLimit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit} message FeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeLimit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeLimit message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeLimit} FeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeLimit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeLimit();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fixed = reader.int64();
                    break;
                case 3:
                    message.fixedMsat = reader.int64();
                    break;
                case 2:
                    message.percent = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeLimit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeLimit} FeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeLimit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeLimit message.
         * @function verify
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeLimit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.fixed != null && message.hasOwnProperty("fixed")) {
                properties.limit = 1;
                if (!$util.isInteger(message.fixed) && !(message.fixed && $util.isInteger(message.fixed.low) && $util.isInteger(message.fixed.high)))
                    return "fixed: integer|Long expected";
            }
            if (message.fixedMsat != null && message.hasOwnProperty("fixedMsat")) {
                if (properties.limit === 1)
                    return "limit: multiple values";
                properties.limit = 1;
                if (!$util.isInteger(message.fixedMsat) && !(message.fixedMsat && $util.isInteger(message.fixedMsat.low) && $util.isInteger(message.fixedMsat.high)))
                    return "fixedMsat: integer|Long expected";
            }
            if (message.percent != null && message.hasOwnProperty("percent")) {
                if (properties.limit === 1)
                    return "limit: multiple values";
                properties.limit = 1;
                if (!$util.isInteger(message.percent) && !(message.percent && $util.isInteger(message.percent.low) && $util.isInteger(message.percent.high)))
                    return "percent: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a FeeLimit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeLimit} FeeLimit
         */
        FeeLimit.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeLimit)
                return object;
            let message = new $root.lnrpc.FeeLimit();
            if (object.fixed != null)
                if ($util.Long)
                    (message.fixed = $util.Long.fromValue(object.fixed)).unsigned = false;
                else if (typeof object.fixed === "string")
                    message.fixed = parseInt(object.fixed, 10);
                else if (typeof object.fixed === "number")
                    message.fixed = object.fixed;
                else if (typeof object.fixed === "object")
                    message.fixed = new $util.LongBits(object.fixed.low >>> 0, object.fixed.high >>> 0).toNumber();
            if (object.fixedMsat != null)
                if ($util.Long)
                    (message.fixedMsat = $util.Long.fromValue(object.fixedMsat)).unsigned = false;
                else if (typeof object.fixedMsat === "string")
                    message.fixedMsat = parseInt(object.fixedMsat, 10);
                else if (typeof object.fixedMsat === "number")
                    message.fixedMsat = object.fixedMsat;
                else if (typeof object.fixedMsat === "object")
                    message.fixedMsat = new $util.LongBits(object.fixedMsat.low >>> 0, object.fixedMsat.high >>> 0).toNumber();
            if (object.percent != null)
                if ($util.Long)
                    (message.percent = $util.Long.fromValue(object.percent)).unsigned = false;
                else if (typeof object.percent === "string")
                    message.percent = parseInt(object.percent, 10);
                else if (typeof object.percent === "number")
                    message.percent = object.percent;
                else if (typeof object.percent === "object")
                    message.percent = new $util.LongBits(object.percent.low >>> 0, object.percent.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FeeLimit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.FeeLimit} message FeeLimit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeLimit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.fixed != null && message.hasOwnProperty("fixed")) {
                if (typeof message.fixed === "number")
                    object.fixed = options.longs === String ? String(message.fixed) : message.fixed;
                else
                    object.fixed = options.longs === String ? $util.Long.prototype.toString.call(message.fixed) : options.longs === Number ? new $util.LongBits(message.fixed.low >>> 0, message.fixed.high >>> 0).toNumber() : message.fixed;
                if (options.oneofs)
                    object.limit = "fixed";
            }
            if (message.percent != null && message.hasOwnProperty("percent")) {
                if (typeof message.percent === "number")
                    object.percent = options.longs === String ? String(message.percent) : message.percent;
                else
                    object.percent = options.longs === String ? $util.Long.prototype.toString.call(message.percent) : options.longs === Number ? new $util.LongBits(message.percent.low >>> 0, message.percent.high >>> 0).toNumber() : message.percent;
                if (options.oneofs)
                    object.limit = "percent";
            }
            if (message.fixedMsat != null && message.hasOwnProperty("fixedMsat")) {
                if (typeof message.fixedMsat === "number")
                    object.fixedMsat = options.longs === String ? String(message.fixedMsat) : message.fixedMsat;
                else
                    object.fixedMsat = options.longs === String ? $util.Long.prototype.toString.call(message.fixedMsat) : options.longs === Number ? new $util.LongBits(message.fixedMsat.low >>> 0, message.fixedMsat.high >>> 0).toNumber() : message.fixedMsat;
                if (options.oneofs)
                    object.limit = "fixedMsat";
            }
            return object;
        };

        /**
         * Converts this FeeLimit to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeLimit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeLimit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeLimit;
    })();

    lnrpc.SendRequest = (function() {

        /**
         * Properties of a SendRequest.
         * @memberof lnrpc
         * @interface ISendRequest
         * @property {Uint8Array|null} [dest] SendRequest dest
         * @property {string|null} [destString] SendRequest destString
         * @property {number|Long|null} [amt] SendRequest amt
         * @property {number|Long|null} [amtMsat] SendRequest amtMsat
         * @property {Uint8Array|null} [paymentHash] SendRequest paymentHash
         * @property {string|null} [paymentHashString] SendRequest paymentHashString
         * @property {string|null} [paymentRequest] SendRequest paymentRequest
         * @property {number|null} [finalCltvDelta] SendRequest finalCltvDelta
         * @property {lnrpc.IFeeLimit|null} [feeLimit] SendRequest feeLimit
         * @property {number|Long|null} [outgoingChanId] SendRequest outgoingChanId
         * @property {Uint8Array|null} [lastHopPubkey] SendRequest lastHopPubkey
         * @property {number|null} [cltvLimit] SendRequest cltvLimit
         * @property {Object.<string,Uint8Array>|null} [destCustomRecords] SendRequest destCustomRecords
         * @property {boolean|null} [allowSelfPayment] SendRequest allowSelfPayment
         * @property {Array.<lnrpc.FeatureBit>|null} [destFeatures] SendRequest destFeatures
         */

        /**
         * Constructs a new SendRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendRequest.
         * @implements ISendRequest
         * @constructor
         * @param {lnrpc.ISendRequest=} [properties] Properties to set
         */
        function SendRequest(properties) {
            this.destCustomRecords = {};
            this.destFeatures = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendRequest dest.
         * @member {Uint8Array} dest
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.dest = $util.newBuffer([]);

        /**
         * SendRequest destString.
         * @member {string} destString
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.destString = "";

        /**
         * SendRequest amt.
         * @member {number|Long} amt
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SendRequest amtMsat.
         * @member {number|Long} amtMsat
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.amtMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SendRequest paymentHash.
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentHash = $util.newBuffer([]);

        /**
         * SendRequest paymentHashString.
         * @member {string} paymentHashString
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentHashString = "";

        /**
         * SendRequest paymentRequest.
         * @member {string} paymentRequest
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentRequest = "";

        /**
         * SendRequest finalCltvDelta.
         * @member {number} finalCltvDelta
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.finalCltvDelta = 0;

        /**
         * SendRequest feeLimit.
         * @member {lnrpc.IFeeLimit|null|undefined} feeLimit
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.feeLimit = null;

        /**
         * SendRequest outgoingChanId.
         * @member {number|Long} outgoingChanId
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.outgoingChanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SendRequest lastHopPubkey.
         * @member {Uint8Array} lastHopPubkey
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.lastHopPubkey = $util.newBuffer([]);

        /**
         * SendRequest cltvLimit.
         * @member {number} cltvLimit
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.cltvLimit = 0;

        /**
         * SendRequest destCustomRecords.
         * @member {Object.<string,Uint8Array>} destCustomRecords
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.destCustomRecords = $util.emptyObject;

        /**
         * SendRequest allowSelfPayment.
         * @member {boolean} allowSelfPayment
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.allowSelfPayment = false;

        /**
         * SendRequest destFeatures.
         * @member {Array.<lnrpc.FeatureBit>} destFeatures
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.destFeatures = $util.emptyArray;

        /**
         * Creates a new SendRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest=} [properties] Properties to set
         * @returns {lnrpc.SendRequest} SendRequest instance
         */
        SendRequest.create = function create(properties) {
            return new SendRequest(properties);
        };

        /**
         * Encodes the specified SendRequest message. Does not implicitly {@link lnrpc.SendRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest} message SendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.dest);
            if (message.destString != null && Object.hasOwnProperty.call(message, "destString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.destString);
            if (message.amt != null && Object.hasOwnProperty.call(message, "amt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amt);
            if (message.paymentHash != null && Object.hasOwnProperty.call(message, "paymentHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.paymentHash);
            if (message.paymentHashString != null && Object.hasOwnProperty.call(message, "paymentHashString"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.paymentHashString);
            if (message.paymentRequest != null && Object.hasOwnProperty.call(message, "paymentRequest"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.paymentRequest);
            if (message.finalCltvDelta != null && Object.hasOwnProperty.call(message, "finalCltvDelta"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.finalCltvDelta);
            if (message.feeLimit != null && Object.hasOwnProperty.call(message, "feeLimit"))
                $root.lnrpc.FeeLimit.encode(message.feeLimit, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.outgoingChanId != null && Object.hasOwnProperty.call(message, "outgoingChanId"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.outgoingChanId);
            if (message.cltvLimit != null && Object.hasOwnProperty.call(message, "cltvLimit"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.cltvLimit);
            if (message.destCustomRecords != null && Object.hasOwnProperty.call(message, "destCustomRecords"))
                for (let keys = Object.keys(message.destCustomRecords), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.destCustomRecords[keys[i]]).ldelim();
            if (message.amtMsat != null && Object.hasOwnProperty.call(message, "amtMsat"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.amtMsat);
            if (message.lastHopPubkey != null && Object.hasOwnProperty.call(message, "lastHopPubkey"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.lastHopPubkey);
            if (message.allowSelfPayment != null && Object.hasOwnProperty.call(message, "allowSelfPayment"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.allowSelfPayment);
            if (message.destFeatures != null && message.destFeatures.length) {
                writer.uint32(/* id 15, wireType 2 =*/122).fork();
                for (let i = 0; i < message.destFeatures.length; ++i)
                    writer.int32(message.destFeatures[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SendRequest message, length delimited. Does not implicitly {@link lnrpc.SendRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest} message SendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendRequest} SendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendRequest(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = reader.bytes();
                    break;
                case 2:
                    message.destString = reader.string();
                    break;
                case 3:
                    message.amt = reader.int64();
                    break;
                case 12:
                    message.amtMsat = reader.int64();
                    break;
                case 4:
                    message.paymentHash = reader.bytes();
                    break;
                case 5:
                    message.paymentHashString = reader.string();
                    break;
                case 6:
                    message.paymentRequest = reader.string();
                    break;
                case 7:
                    message.finalCltvDelta = reader.int32();
                    break;
                case 8:
                    message.feeLimit = $root.lnrpc.FeeLimit.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.outgoingChanId = reader.uint64();
                    break;
                case 13:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case 10:
                    message.cltvLimit = reader.uint32();
                    break;
                case 11:
                    if (message.destCustomRecords === $util.emptyObject)
                        message.destCustomRecords = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = [];
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint64();
                            break;
                        case 2:
                            value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.destCustomRecords[typeof key === "object" ? $util.longToHash(key) : key] = value;
                    break;
                case 14:
                    message.allowSelfPayment = reader.bool();
                    break;
                case 15:
                    if (!(message.destFeatures && message.destFeatures.length))
                        message.destFeatures = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.destFeatures.push(reader.int32());
                    } else
                        message.destFeatures.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendRequest} SendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendRequest message.
         * @function verify
         * @memberof lnrpc.SendRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!(message.dest && typeof message.dest.length === "number" || $util.isString(message.dest)))
                    return "dest: buffer expected";
            if (message.destString != null && message.hasOwnProperty("destString"))
                if (!$util.isString(message.destString))
                    return "destString: string expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.amtMsat != null && message.hasOwnProperty("amtMsat"))
                if (!$util.isInteger(message.amtMsat) && !(message.amtMsat && $util.isInteger(message.amtMsat.low) && $util.isInteger(message.amtMsat.high)))
                    return "amtMsat: integer|Long expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                if (!$util.isString(message.paymentHashString))
                    return "paymentHashString: string expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                if (!$util.isInteger(message.finalCltvDelta))
                    return "finalCltvDelta: integer expected";
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit")) {
                let error = $root.lnrpc.FeeLimit.verify(message.feeLimit);
                if (error)
                    return "feeLimit." + error;
            }
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                if (!$util.isInteger(message.outgoingChanId) && !(message.outgoingChanId && $util.isInteger(message.outgoingChanId.low) && $util.isInteger(message.outgoingChanId.high)))
                    return "outgoingChanId: integer|Long expected";
            if (message.lastHopPubkey != null && message.hasOwnProperty("lastHopPubkey"))
                if (!(message.lastHopPubkey && typeof message.lastHopPubkey.length === "number" || $util.isString(message.lastHopPubkey)))
                    return "lastHopPubkey: buffer expected";
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                if (!$util.isInteger(message.cltvLimit))
                    return "cltvLimit: integer expected";
            if (message.destCustomRecords != null && message.hasOwnProperty("destCustomRecords")) {
                if (!$util.isObject(message.destCustomRecords))
                    return "destCustomRecords: object expected";
                let key = Object.keys(message.destCustomRecords);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "destCustomRecords: integer|Long key{k:uint64} expected";
                    if (!(message.destCustomRecords[key[i]] && typeof message.destCustomRecords[key[i]].length === "number" || $util.isString(message.destCustomRecords[key[i]])))
                        return "destCustomRecords: buffer{k:uint64} expected";
                }
            }
            if (message.allowSelfPayment != null && message.hasOwnProperty("allowSelfPayment"))
                if (typeof message.allowSelfPayment !== "boolean")
                    return "allowSelfPayment: boolean expected";
            if (message.destFeatures != null && message.hasOwnProperty("destFeatures")) {
                if (!Array.isArray(message.destFeatures))
                    return "destFeatures: array expected";
                for (let i = 0; i < message.destFeatures.length; ++i)
                    switch (message.destFeatures[i]) {
                    default:
                        return "destFeatures: enum value[] expected";
                    case 0:
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a SendRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendRequest} SendRequest
         */
        SendRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendRequest)
                return object;
            let message = new $root.lnrpc.SendRequest();
            if (object.dest != null)
                if (typeof object.dest === "string")
                    $util.base64.decode(object.dest, message.dest = $util.newBuffer($util.base64.length(object.dest)), 0);
                else if (object.dest.length)
                    message.dest = object.dest;
            if (object.destString != null)
                message.destString = String(object.destString);
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.amtMsat != null)
                if ($util.Long)
                    (message.amtMsat = $util.Long.fromValue(object.amtMsat)).unsigned = false;
                else if (typeof object.amtMsat === "string")
                    message.amtMsat = parseInt(object.amtMsat, 10);
                else if (typeof object.amtMsat === "number")
                    message.amtMsat = object.amtMsat;
                else if (typeof object.amtMsat === "object")
                    message.amtMsat = new $util.LongBits(object.amtMsat.low >>> 0, object.amtMsat.high >>> 0).toNumber();
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            if (object.paymentHashString != null)
                message.paymentHashString = String(object.paymentHashString);
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.finalCltvDelta != null)
                message.finalCltvDelta = object.finalCltvDelta | 0;
            if (object.feeLimit != null) {
                if (typeof object.feeLimit !== "object")
                    throw TypeError(".lnrpc.SendRequest.feeLimit: object expected");
                message.feeLimit = $root.lnrpc.FeeLimit.fromObject(object.feeLimit);
            }
            if (object.outgoingChanId != null)
                if ($util.Long)
                    (message.outgoingChanId = $util.Long.fromValue(object.outgoingChanId)).unsigned = true;
                else if (typeof object.outgoingChanId === "string")
                    message.outgoingChanId = parseInt(object.outgoingChanId, 10);
                else if (typeof object.outgoingChanId === "number")
                    message.outgoingChanId = object.outgoingChanId;
                else if (typeof object.outgoingChanId === "object")
                    message.outgoingChanId = new $util.LongBits(object.outgoingChanId.low >>> 0, object.outgoingChanId.high >>> 0).toNumber(true);
            if (object.lastHopPubkey != null)
                if (typeof object.lastHopPubkey === "string")
                    $util.base64.decode(object.lastHopPubkey, message.lastHopPubkey = $util.newBuffer($util.base64.length(object.lastHopPubkey)), 0);
                else if (object.lastHopPubkey.length)
                    message.lastHopPubkey = object.lastHopPubkey;
            if (object.cltvLimit != null)
                message.cltvLimit = object.cltvLimit >>> 0;
            if (object.destCustomRecords) {
                if (typeof object.destCustomRecords !== "object")
                    throw TypeError(".lnrpc.SendRequest.destCustomRecords: object expected");
                message.destCustomRecords = {};
                for (let keys = Object.keys(object.destCustomRecords), i = 0; i < keys.length; ++i)
                    if (typeof object.destCustomRecords[keys[i]] === "string")
                        $util.base64.decode(object.destCustomRecords[keys[i]], message.destCustomRecords[keys[i]] = $util.newBuffer($util.base64.length(object.destCustomRecords[keys[i]])), 0);
                    else if (object.destCustomRecords[keys[i]].length)
                        message.destCustomRecords[keys[i]] = object.destCustomRecords[keys[i]];
            }
            if (object.allowSelfPayment != null)
                message.allowSelfPayment = Boolean(object.allowSelfPayment);
            if (object.destFeatures) {
                if (!Array.isArray(object.destFeatures))
                    throw TypeError(".lnrpc.SendRequest.destFeatures: array expected");
                message.destFeatures = [];
                for (let i = 0; i < object.destFeatures.length; ++i)
                    switch (object.destFeatures[i]) {
                    default:
                    case "DATALOSS_PROTECT_REQ":
                    case 0:
                        message.destFeatures[i] = 0;
                        break;
                    case "DATALOSS_PROTECT_OPT":
                    case 1:
                        message.destFeatures[i] = 1;
                        break;
                    case "INITIAL_ROUING_SYNC":
                    case 3:
                        message.destFeatures[i] = 3;
                        break;
                    case "UPFRONT_SHUTDOWN_SCRIPT_REQ":
                    case 4:
                        message.destFeatures[i] = 4;
                        break;
                    case "UPFRONT_SHUTDOWN_SCRIPT_OPT":
                    case 5:
                        message.destFeatures[i] = 5;
                        break;
                    case "GOSSIP_QUERIES_REQ":
                    case 6:
                        message.destFeatures[i] = 6;
                        break;
                    case "GOSSIP_QUERIES_OPT":
                    case 7:
                        message.destFeatures[i] = 7;
                        break;
                    case "TLV_ONION_REQ":
                    case 8:
                        message.destFeatures[i] = 8;
                        break;
                    case "TLV_ONION_OPT":
                    case 9:
                        message.destFeatures[i] = 9;
                        break;
                    case "EXT_GOSSIP_QUERIES_REQ":
                    case 10:
                        message.destFeatures[i] = 10;
                        break;
                    case "EXT_GOSSIP_QUERIES_OPT":
                    case 11:
                        message.destFeatures[i] = 11;
                        break;
                    case "STATIC_REMOTE_KEY_REQ":
                    case 12:
                        message.destFeatures[i] = 12;
                        break;
                    case "STATIC_REMOTE_KEY_OPT":
                    case 13:
                        message.destFeatures[i] = 13;
                        break;
                    case "PAYMENT_ADDR_REQ":
                    case 14:
                        message.destFeatures[i] = 14;
                        break;
                    case "PAYMENT_ADDR_OPT":
                    case 15:
                        message.destFeatures[i] = 15;
                        break;
                    case "MPP_REQ":
                    case 16:
                        message.destFeatures[i] = 16;
                        break;
                    case "MPP_OPT":
                    case 17:
                        message.destFeatures[i] = 17;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a SendRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.SendRequest} message SendRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.destFeatures = [];
            if (options.objects || options.defaults)
                object.destCustomRecords = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.dest = "";
                else {
                    object.dest = [];
                    if (options.bytes !== Array)
                        object.dest = $util.newBuffer(object.dest);
                }
                object.destString = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
                object.paymentHashString = "";
                object.paymentRequest = "";
                object.finalCltvDelta = 0;
                object.feeLimit = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.outgoingChanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outgoingChanId = options.longs === String ? "0" : 0;
                object.cltvLimit = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtMsat = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.lastHopPubkey = "";
                else {
                    object.lastHopPubkey = [];
                    if (options.bytes !== Array)
                        object.lastHopPubkey = $util.newBuffer(object.lastHopPubkey);
                }
                object.allowSelfPayment = false;
            }
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = options.bytes === String ? $util.base64.encode(message.dest, 0, message.dest.length) : options.bytes === Array ? Array.prototype.slice.call(message.dest) : message.dest;
            if (message.destString != null && message.hasOwnProperty("destString"))
                object.destString = message.destString;
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                object.paymentHashString = message.paymentHashString;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                object.finalCltvDelta = message.finalCltvDelta;
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                object.feeLimit = $root.lnrpc.FeeLimit.toObject(message.feeLimit, options);
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                if (typeof message.outgoingChanId === "number")
                    object.outgoingChanId = options.longs === String ? String(message.outgoingChanId) : message.outgoingChanId;
                else
                    object.outgoingChanId = options.longs === String ? $util.Long.prototype.toString.call(message.outgoingChanId) : options.longs === Number ? new $util.LongBits(message.outgoingChanId.low >>> 0, message.outgoingChanId.high >>> 0).toNumber(true) : message.outgoingChanId;
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                object.cltvLimit = message.cltvLimit;
            let keys2;
            if (message.destCustomRecords && (keys2 = Object.keys(message.destCustomRecords)).length) {
                object.destCustomRecords = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.destCustomRecords[keys2[j]] = options.bytes === String ? $util.base64.encode(message.destCustomRecords[keys2[j]], 0, message.destCustomRecords[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.destCustomRecords[keys2[j]]) : message.destCustomRecords[keys2[j]];
            }
            if (message.amtMsat != null && message.hasOwnProperty("amtMsat"))
                if (typeof message.amtMsat === "number")
                    object.amtMsat = options.longs === String ? String(message.amtMsat) : message.amtMsat;
                else
                    object.amtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtMsat) : options.longs === Number ? new $util.LongBits(message.amtMsat.low >>> 0, message.amtMsat.high >>> 0).toNumber() : message.amtMsat;
            if (message.lastHopPubkey != null && message.hasOwnProperty("lastHopPubkey"))
                object.lastHopPubkey = options.bytes === String ? $util.base64.encode(message.lastHopPubkey, 0, message.lastHopPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastHopPubkey) : message.lastHopPubkey;
            if (message.allowSelfPayment != null && message.hasOwnProperty("allowSelfPayment"))
                object.allowSelfPayment = message.allowSelfPayment;
            if (message.destFeatures && message.destFeatures.length) {
                object.destFeatures = [];
                for (let j = 0; j < message.destFeatures.length; ++j)
                    object.destFeatures[j] = options.enums === String ? $root.lnrpc.FeatureBit[message.destFeatures[j]] : message.destFeatures[j];
            }
            return object;
        };

        /**
         * Converts this SendRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendRequest;
    })();

    lnrpc.SendResponse = (function() {

        /**
         * Properties of a SendResponse.
         * @memberof lnrpc
         * @interface ISendResponse
         * @property {string|null} [paymentError] SendResponse paymentError
         * @property {Uint8Array|null} [paymentPreimage] SendResponse paymentPreimage
         * @property {lnrpc.IRoute|null} [paymentRoute] SendResponse paymentRoute
         * @property {Uint8Array|null} [paymentHash] SendResponse paymentHash
         */

        /**
         * Constructs a new SendResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendResponse.
         * @implements ISendResponse
         * @constructor
         * @param {lnrpc.ISendResponse=} [properties] Properties to set
         */
        function SendResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendResponse paymentError.
         * @member {string} paymentError
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentError = "";

        /**
         * SendResponse paymentPreimage.
         * @member {Uint8Array} paymentPreimage
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentPreimage = $util.newBuffer([]);

        /**
         * SendResponse paymentRoute.
         * @member {lnrpc.IRoute|null|undefined} paymentRoute
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentRoute = null;

        /**
         * SendResponse paymentHash.
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentHash = $util.newBuffer([]);

        /**
         * Creates a new SendResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse=} [properties] Properties to set
         * @returns {lnrpc.SendResponse} SendResponse instance
         */
        SendResponse.create = function create(properties) {
            return new SendResponse(properties);
        };

        /**
         * Encodes the specified SendResponse message. Does not implicitly {@link lnrpc.SendResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse} message SendResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentError != null && Object.hasOwnProperty.call(message, "paymentError"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.paymentError);
            if (message.paymentPreimage != null && Object.hasOwnProperty.call(message, "paymentPreimage"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.paymentPreimage);
            if (message.paymentRoute != null && Object.hasOwnProperty.call(message, "paymentRoute"))
                $root.lnrpc.Route.encode(message.paymentRoute, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.paymentHash != null && Object.hasOwnProperty.call(message, "paymentHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.paymentHash);
            return writer;
        };

        /**
         * Encodes the specified SendResponse message, length delimited. Does not implicitly {@link lnrpc.SendResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse} message SendResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendResponse} SendResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentError = reader.string();
                    break;
                case 2:
                    message.paymentPreimage = reader.bytes();
                    break;
                case 3:
                    message.paymentRoute = $root.lnrpc.Route.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.paymentHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendResponse} SendResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendResponse message.
         * @function verify
         * @memberof lnrpc.SendResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                if (!$util.isString(message.paymentError))
                    return "paymentError: string expected";
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                if (!(message.paymentPreimage && typeof message.paymentPreimage.length === "number" || $util.isString(message.paymentPreimage)))
                    return "paymentPreimage: buffer expected";
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute")) {
                let error = $root.lnrpc.Route.verify(message.paymentRoute);
                if (error)
                    return "paymentRoute." + error;
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            return null;
        };

        /**
         * Creates a SendResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendResponse} SendResponse
         */
        SendResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendResponse)
                return object;
            let message = new $root.lnrpc.SendResponse();
            if (object.paymentError != null)
                message.paymentError = String(object.paymentError);
            if (object.paymentPreimage != null)
                if (typeof object.paymentPreimage === "string")
                    $util.base64.decode(object.paymentPreimage, message.paymentPreimage = $util.newBuffer($util.base64.length(object.paymentPreimage)), 0);
                else if (object.paymentPreimage.length)
                    message.paymentPreimage = object.paymentPreimage;
            if (object.paymentRoute != null) {
                if (typeof object.paymentRoute !== "object")
                    throw TypeError(".lnrpc.SendResponse.paymentRoute: object expected");
                message.paymentRoute = $root.lnrpc.Route.fromObject(object.paymentRoute);
            }
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            return message;
        };

        /**
         * Creates a plain object from a SendResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.SendResponse} message SendResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.paymentError = "";
                if (options.bytes === String)
                    object.paymentPreimage = "";
                else {
                    object.paymentPreimage = [];
                    if (options.bytes !== Array)
                        object.paymentPreimage = $util.newBuffer(object.paymentPreimage);
                }
                object.paymentRoute = null;
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
            }
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                object.paymentError = message.paymentError;
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                object.paymentPreimage = options.bytes === String ? $util.base64.encode(message.paymentPreimage, 0, message.paymentPreimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentPreimage) : message.paymentPreimage;
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute"))
                object.paymentRoute = $root.lnrpc.Route.toObject(message.paymentRoute, options);
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            return object;
        };

        /**
         * Converts this SendResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendResponse;
    })();

    lnrpc.SendToRouteRequest = (function() {

        /**
         * Properties of a SendToRouteRequest.
         * @memberof lnrpc
         * @interface ISendToRouteRequest
         * @property {Uint8Array|null} [paymentHash] SendToRouteRequest paymentHash
         * @property {string|null} [paymentHashString] SendToRouteRequest paymentHashString
         * @property {lnrpc.IRoute|null} [route] SendToRouteRequest route
         */

        /**
         * Constructs a new SendToRouteRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendToRouteRequest.
         * @implements ISendToRouteRequest
         * @constructor
         * @param {lnrpc.ISendToRouteRequest=} [properties] Properties to set
         */
        function SendToRouteRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendToRouteRequest paymentHash.
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.paymentHash = $util.newBuffer([]);

        /**
         * SendToRouteRequest paymentHashString.
         * @member {string} paymentHashString
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.paymentHashString = "";

        /**
         * SendToRouteRequest route.
         * @member {lnrpc.IRoute|null|undefined} route
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.route = null;

        /**
         * Creates a new SendToRouteRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest=} [properties] Properties to set
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest instance
         */
        SendToRouteRequest.create = function create(properties) {
            return new SendToRouteRequest(properties);
        };

        /**
         * Encodes the specified SendToRouteRequest message. Does not implicitly {@link lnrpc.SendToRouteRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest} message SendToRouteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendToRouteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentHash != null && Object.hasOwnProperty.call(message, "paymentHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.paymentHash);
            if (message.paymentHashString != null && Object.hasOwnProperty.call(message, "paymentHashString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentHashString);
            if (message.route != null && Object.hasOwnProperty.call(message, "route"))
                $root.lnrpc.Route.encode(message.route, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendToRouteRequest message, length delimited. Does not implicitly {@link lnrpc.SendToRouteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest} message SendToRouteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendToRouteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendToRouteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendToRouteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendToRouteRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentHash = reader.bytes();
                    break;
                case 2:
                    message.paymentHashString = reader.string();
                    break;
                case 4:
                    message.route = $root.lnrpc.Route.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendToRouteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendToRouteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendToRouteRequest message.
         * @function verify
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendToRouteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                if (!$util.isString(message.paymentHashString))
                    return "paymentHashString: string expected";
            if (message.route != null && message.hasOwnProperty("route")) {
                let error = $root.lnrpc.Route.verify(message.route);
                if (error)
                    return "route." + error;
            }
            return null;
        };

        /**
         * Creates a SendToRouteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         */
        SendToRouteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendToRouteRequest)
                return object;
            let message = new $root.lnrpc.SendToRouteRequest();
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            if (object.paymentHashString != null)
                message.paymentHashString = String(object.paymentHashString);
            if (object.route != null) {
                if (typeof object.route !== "object")
                    throw TypeError(".lnrpc.SendToRouteRequest.route: object expected");
                message.route = $root.lnrpc.Route.fromObject(object.route);
            }
            return message;
        };

        /**
         * Creates a plain object from a SendToRouteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.SendToRouteRequest} message SendToRouteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendToRouteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
                object.paymentHashString = "";
                object.route = null;
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                object.paymentHashString = message.paymentHashString;
            if (message.route != null && message.hasOwnProperty("route"))
                object.route = $root.lnrpc.Route.toObject(message.route, options);
            return object;
        };

        /**
         * Converts this SendToRouteRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendToRouteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendToRouteRequest;
    })();

    lnrpc.ChannelAcceptRequest = (function() {

        /**
         * Properties of a ChannelAcceptRequest.
         * @memberof lnrpc
         * @interface IChannelAcceptRequest
         * @property {Uint8Array|null} [nodePubkey] ChannelAcceptRequest nodePubkey
         * @property {Uint8Array|null} [chainHash] ChannelAcceptRequest chainHash
         * @property {Uint8Array|null} [pendingChanId] ChannelAcceptRequest pendingChanId
         * @property {number|Long|null} [fundingAmt] ChannelAcceptRequest fundingAmt
         * @property {number|Long|null} [pushAmt] ChannelAcceptRequest pushAmt
         * @property {number|Long|null} [dustLimit] ChannelAcceptRequest dustLimit
         * @property {number|Long|null} [maxValueInFlight] ChannelAcceptRequest maxValueInFlight
         * @property {number|Long|null} [channelReserve] ChannelAcceptRequest channelReserve
         * @property {number|Long|null} [minHtlc] ChannelAcceptRequest minHtlc
         * @property {number|Long|null} [feePerKw] ChannelAcceptRequest feePerKw
         * @property {number|null} [csvDelay] ChannelAcceptRequest csvDelay
         * @property {number|null} [maxAcceptedHtlcs] ChannelAcceptRequest maxAcceptedHtlcs
         * @property {number|null} [channelFlags] ChannelAcceptRequest channelFlags
         */

        /**
         * Constructs a new ChannelAcceptRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelAcceptRequest.
         * @implements IChannelAcceptRequest
         * @constructor
         * @param {lnrpc.IChannelAcceptRequest=} [properties] Properties to set
         */
        function ChannelAcceptRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelAcceptRequest nodePubkey.
         * @member {Uint8Array} nodePubkey
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.nodePubkey = $util.newBuffer([]);

        /**
         * ChannelAcceptRequest chainHash.
         * @member {Uint8Array} chainHash
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.chainHash = $util.newBuffer([]);

        /**
         * ChannelAcceptRequest pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * ChannelAcceptRequest fundingAmt.
         * @member {number|Long} fundingAmt
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.fundingAmt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest pushAmt.
         * @member {number|Long} pushAmt
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.pushAmt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest dustLimit.
         * @member {number|Long} dustLimit
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.dustLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest maxValueInFlight.
         * @member {number|Long} maxValueInFlight
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.maxValueInFlight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest channelReserve.
         * @member {number|Long} channelReserve
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.channelReserve = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest minHtlc.
         * @member {number|Long} minHtlc
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.minHtlc = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest feePerKw.
         * @member {number|Long} feePerKw
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelAcceptRequest csvDelay.
         * @member {number} csvDelay
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.csvDelay = 0;

        /**
         * ChannelAcceptRequest maxAcceptedHtlcs.
         * @member {number} maxAcceptedHtlcs
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.maxAcceptedHtlcs = 0;

        /**
         * ChannelAcceptRequest channelFlags.
         * @member {number} channelFlags
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         */
        ChannelAcceptRequest.prototype.channelFlags = 0;

        /**
         * Creates a new ChannelAcceptRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {lnrpc.IChannelAcceptRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelAcceptRequest} ChannelAcceptRequest instance
         */
        ChannelAcceptRequest.create = function create(properties) {
            return new ChannelAcceptRequest(properties);
        };

        /**
         * Encodes the specified ChannelAcceptRequest message. Does not implicitly {@link lnrpc.ChannelAcceptRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {lnrpc.IChannelAcceptRequest} message ChannelAcceptRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodePubkey != null && Object.hasOwnProperty.call(message, "nodePubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nodePubkey);
            if (message.chainHash != null && Object.hasOwnProperty.call(message, "chainHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.chainHash);
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pendingChanId);
            if (message.fundingAmt != null && Object.hasOwnProperty.call(message, "fundingAmt"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fundingAmt);
            if (message.pushAmt != null && Object.hasOwnProperty.call(message, "pushAmt"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.pushAmt);
            if (message.dustLimit != null && Object.hasOwnProperty.call(message, "dustLimit"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.dustLimit);
            if (message.maxValueInFlight != null && Object.hasOwnProperty.call(message, "maxValueInFlight"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.maxValueInFlight);
            if (message.channelReserve != null && Object.hasOwnProperty.call(message, "channelReserve"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.channelReserve);
            if (message.minHtlc != null && Object.hasOwnProperty.call(message, "minHtlc"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.minHtlc);
            if (message.feePerKw != null && Object.hasOwnProperty.call(message, "feePerKw"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.feePerKw);
            if (message.csvDelay != null && Object.hasOwnProperty.call(message, "csvDelay"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.csvDelay);
            if (message.maxAcceptedHtlcs != null && Object.hasOwnProperty.call(message, "maxAcceptedHtlcs"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.maxAcceptedHtlcs);
            if (message.channelFlags != null && Object.hasOwnProperty.call(message, "channelFlags"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.channelFlags);
            return writer;
        };

        /**
         * Encodes the specified ChannelAcceptRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelAcceptRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {lnrpc.IChannelAcceptRequest} message ChannelAcceptRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelAcceptRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelAcceptRequest} ChannelAcceptRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelAcceptRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodePubkey = reader.bytes();
                    break;
                case 2:
                    message.chainHash = reader.bytes();
                    break;
                case 3:
                    message.pendingChanId = reader.bytes();
                    break;
                case 4:
                    message.fundingAmt = reader.uint64();
                    break;
                case 5:
                    message.pushAmt = reader.uint64();
                    break;
                case 6:
                    message.dustLimit = reader.uint64();
                    break;
                case 7:
                    message.maxValueInFlight = reader.uint64();
                    break;
                case 8:
                    message.channelReserve = reader.uint64();
                    break;
                case 9:
                    message.minHtlc = reader.uint64();
                    break;
                case 10:
                    message.feePerKw = reader.uint64();
                    break;
                case 11:
                    message.csvDelay = reader.uint32();
                    break;
                case 12:
                    message.maxAcceptedHtlcs = reader.uint32();
                    break;
                case 13:
                    message.channelFlags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelAcceptRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelAcceptRequest} ChannelAcceptRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelAcceptRequest message.
         * @function verify
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelAcceptRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                if (!(message.nodePubkey && typeof message.nodePubkey.length === "number" || $util.isString(message.nodePubkey)))
                    return "nodePubkey: buffer expected";
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                if (!(message.chainHash && typeof message.chainHash.length === "number" || $util.isString(message.chainHash)))
                    return "chainHash: buffer expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            if (message.fundingAmt != null && message.hasOwnProperty("fundingAmt"))
                if (!$util.isInteger(message.fundingAmt) && !(message.fundingAmt && $util.isInteger(message.fundingAmt.low) && $util.isInteger(message.fundingAmt.high)))
                    return "fundingAmt: integer|Long expected";
            if (message.pushAmt != null && message.hasOwnProperty("pushAmt"))
                if (!$util.isInteger(message.pushAmt) && !(message.pushAmt && $util.isInteger(message.pushAmt.low) && $util.isInteger(message.pushAmt.high)))
                    return "pushAmt: integer|Long expected";
            if (message.dustLimit != null && message.hasOwnProperty("dustLimit"))
                if (!$util.isInteger(message.dustLimit) && !(message.dustLimit && $util.isInteger(message.dustLimit.low) && $util.isInteger(message.dustLimit.high)))
                    return "dustLimit: integer|Long expected";
            if (message.maxValueInFlight != null && message.hasOwnProperty("maxValueInFlight"))
                if (!$util.isInteger(message.maxValueInFlight) && !(message.maxValueInFlight && $util.isInteger(message.maxValueInFlight.low) && $util.isInteger(message.maxValueInFlight.high)))
                    return "maxValueInFlight: integer|Long expected";
            if (message.channelReserve != null && message.hasOwnProperty("channelReserve"))
                if (!$util.isInteger(message.channelReserve) && !(message.channelReserve && $util.isInteger(message.channelReserve.low) && $util.isInteger(message.channelReserve.high)))
                    return "channelReserve: integer|Long expected";
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (!$util.isInteger(message.minHtlc) && !(message.minHtlc && $util.isInteger(message.minHtlc.low) && $util.isInteger(message.minHtlc.high)))
                    return "minHtlc: integer|Long expected";
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                    return "feePerKw: integer|Long expected";
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                if (!$util.isInteger(message.csvDelay))
                    return "csvDelay: integer expected";
            if (message.maxAcceptedHtlcs != null && message.hasOwnProperty("maxAcceptedHtlcs"))
                if (!$util.isInteger(message.maxAcceptedHtlcs))
                    return "maxAcceptedHtlcs: integer expected";
            if (message.channelFlags != null && message.hasOwnProperty("channelFlags"))
                if (!$util.isInteger(message.channelFlags))
                    return "channelFlags: integer expected";
            return null;
        };

        /**
         * Creates a ChannelAcceptRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelAcceptRequest} ChannelAcceptRequest
         */
        ChannelAcceptRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelAcceptRequest)
                return object;
            let message = new $root.lnrpc.ChannelAcceptRequest();
            if (object.nodePubkey != null)
                if (typeof object.nodePubkey === "string")
                    $util.base64.decode(object.nodePubkey, message.nodePubkey = $util.newBuffer($util.base64.length(object.nodePubkey)), 0);
                else if (object.nodePubkey.length)
                    message.nodePubkey = object.nodePubkey;
            if (object.chainHash != null)
                if (typeof object.chainHash === "string")
                    $util.base64.decode(object.chainHash, message.chainHash = $util.newBuffer($util.base64.length(object.chainHash)), 0);
                else if (object.chainHash.length)
                    message.chainHash = object.chainHash;
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            if (object.fundingAmt != null)
                if ($util.Long)
                    (message.fundingAmt = $util.Long.fromValue(object.fundingAmt)).unsigned = true;
                else if (typeof object.fundingAmt === "string")
                    message.fundingAmt = parseInt(object.fundingAmt, 10);
                else if (typeof object.fundingAmt === "number")
                    message.fundingAmt = object.fundingAmt;
                else if (typeof object.fundingAmt === "object")
                    message.fundingAmt = new $util.LongBits(object.fundingAmt.low >>> 0, object.fundingAmt.high >>> 0).toNumber(true);
            if (object.pushAmt != null)
                if ($util.Long)
                    (message.pushAmt = $util.Long.fromValue(object.pushAmt)).unsigned = true;
                else if (typeof object.pushAmt === "string")
                    message.pushAmt = parseInt(object.pushAmt, 10);
                else if (typeof object.pushAmt === "number")
                    message.pushAmt = object.pushAmt;
                else if (typeof object.pushAmt === "object")
                    message.pushAmt = new $util.LongBits(object.pushAmt.low >>> 0, object.pushAmt.high >>> 0).toNumber(true);
            if (object.dustLimit != null)
                if ($util.Long)
                    (message.dustLimit = $util.Long.fromValue(object.dustLimit)).unsigned = true;
                else if (typeof object.dustLimit === "string")
                    message.dustLimit = parseInt(object.dustLimit, 10);
                else if (typeof object.dustLimit === "number")
                    message.dustLimit = object.dustLimit;
                else if (typeof object.dustLimit === "object")
                    message.dustLimit = new $util.LongBits(object.dustLimit.low >>> 0, object.dustLimit.high >>> 0).toNumber(true);
            if (object.maxValueInFlight != null)
                if ($util.Long)
                    (message.maxValueInFlight = $util.Long.fromValue(object.maxValueInFlight)).unsigned = true;
                else if (typeof object.maxValueInFlight === "string")
                    message.maxValueInFlight = parseInt(object.maxValueInFlight, 10);
                else if (typeof object.maxValueInFlight === "number")
                    message.maxValueInFlight = object.maxValueInFlight;
                else if (typeof object.maxValueInFlight === "object")
                    message.maxValueInFlight = new $util.LongBits(object.maxValueInFlight.low >>> 0, object.maxValueInFlight.high >>> 0).toNumber(true);
            if (object.channelReserve != null)
                if ($util.Long)
                    (message.channelReserve = $util.Long.fromValue(object.channelReserve)).unsigned = true;
                else if (typeof object.channelReserve === "string")
                    message.channelReserve = parseInt(object.channelReserve, 10);
                else if (typeof object.channelReserve === "number")
                    message.channelReserve = object.channelReserve;
                else if (typeof object.channelReserve === "object")
                    message.channelReserve = new $util.LongBits(object.channelReserve.low >>> 0, object.channelReserve.high >>> 0).toNumber(true);
            if (object.minHtlc != null)
                if ($util.Long)
                    (message.minHtlc = $util.Long.fromValue(object.minHtlc)).unsigned = true;
                else if (typeof object.minHtlc === "string")
                    message.minHtlc = parseInt(object.minHtlc, 10);
                else if (typeof object.minHtlc === "number")
                    message.minHtlc = object.minHtlc;
                else if (typeof object.minHtlc === "object")
                    message.minHtlc = new $util.LongBits(object.minHtlc.low >>> 0, object.minHtlc.high >>> 0).toNumber(true);
            if (object.feePerKw != null)
                if ($util.Long)
                    (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = true;
                else if (typeof object.feePerKw === "string")
                    message.feePerKw = parseInt(object.feePerKw, 10);
                else if (typeof object.feePerKw === "number")
                    message.feePerKw = object.feePerKw;
                else if (typeof object.feePerKw === "object")
                    message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber(true);
            if (object.csvDelay != null)
                message.csvDelay = object.csvDelay >>> 0;
            if (object.maxAcceptedHtlcs != null)
                message.maxAcceptedHtlcs = object.maxAcceptedHtlcs >>> 0;
            if (object.channelFlags != null)
                message.channelFlags = object.channelFlags >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChannelAcceptRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelAcceptRequest
         * @static
         * @param {lnrpc.ChannelAcceptRequest} message ChannelAcceptRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelAcceptRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nodePubkey = "";
                else {
                    object.nodePubkey = [];
                    if (options.bytes !== Array)
                        object.nodePubkey = $util.newBuffer(object.nodePubkey);
                }
                if (options.bytes === String)
                    object.chainHash = "";
                else {
                    object.chainHash = [];
                    if (options.bytes !== Array)
                        object.chainHash = $util.newBuffer(object.chainHash);
                }
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.fundingAmt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fundingAmt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.pushAmt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pushAmt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.dustLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dustLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxValueInFlight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxValueInFlight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.channelReserve = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelReserve = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minHtlc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerKw = options.longs === String ? "0" : 0;
                object.csvDelay = 0;
                object.maxAcceptedHtlcs = 0;
                object.channelFlags = 0;
            }
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                object.nodePubkey = options.bytes === String ? $util.base64.encode(message.nodePubkey, 0, message.nodePubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodePubkey) : message.nodePubkey;
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                object.chainHash = options.bytes === String ? $util.base64.encode(message.chainHash, 0, message.chainHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainHash) : message.chainHash;
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            if (message.fundingAmt != null && message.hasOwnProperty("fundingAmt"))
                if (typeof message.fundingAmt === "number")
                    object.fundingAmt = options.longs === String ? String(message.fundingAmt) : message.fundingAmt;
                else
                    object.fundingAmt = options.longs === String ? $util.Long.prototype.toString.call(message.fundingAmt) : options.longs === Number ? new $util.LongBits(message.fundingAmt.low >>> 0, message.fundingAmt.high >>> 0).toNumber(true) : message.fundingAmt;
            if (message.pushAmt != null && message.hasOwnProperty("pushAmt"))
                if (typeof message.pushAmt === "number")
                    object.pushAmt = options.longs === String ? String(message.pushAmt) : message.pushAmt;
                else
                    object.pushAmt = options.longs === String ? $util.Long.prototype.toString.call(message.pushAmt) : options.longs === Number ? new $util.LongBits(message.pushAmt.low >>> 0, message.pushAmt.high >>> 0).toNumber(true) : message.pushAmt;
            if (message.dustLimit != null && message.hasOwnProperty("dustLimit"))
                if (typeof message.dustLimit === "number")
                    object.dustLimit = options.longs === String ? String(message.dustLimit) : message.dustLimit;
                else
                    object.dustLimit = options.longs === String ? $util.Long.prototype.toString.call(message.dustLimit) : options.longs === Number ? new $util.LongBits(message.dustLimit.low >>> 0, message.dustLimit.high >>> 0).toNumber(true) : message.dustLimit;
            if (message.maxValueInFlight != null && message.hasOwnProperty("maxValueInFlight"))
                if (typeof message.maxValueInFlight === "number")
                    object.maxValueInFlight = options.longs === String ? String(message.maxValueInFlight) : message.maxValueInFlight;
                else
                    object.maxValueInFlight = options.longs === String ? $util.Long.prototype.toString.call(message.maxValueInFlight) : options.longs === Number ? new $util.LongBits(message.maxValueInFlight.low >>> 0, message.maxValueInFlight.high >>> 0).toNumber(true) : message.maxValueInFlight;
            if (message.channelReserve != null && message.hasOwnProperty("channelReserve"))
                if (typeof message.channelReserve === "number")
                    object.channelReserve = options.longs === String ? String(message.channelReserve) : message.channelReserve;
                else
                    object.channelReserve = options.longs === String ? $util.Long.prototype.toString.call(message.channelReserve) : options.longs === Number ? new $util.LongBits(message.channelReserve.low >>> 0, message.channelReserve.high >>> 0).toNumber(true) : message.channelReserve;
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (typeof message.minHtlc === "number")
                    object.minHtlc = options.longs === String ? String(message.minHtlc) : message.minHtlc;
                else
                    object.minHtlc = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlc) : options.longs === Number ? new $util.LongBits(message.minHtlc.low >>> 0, message.minHtlc.high >>> 0).toNumber(true) : message.minHtlc;
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (typeof message.feePerKw === "number")
                    object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                else
                    object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber(true) : message.feePerKw;
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                object.csvDelay = message.csvDelay;
            if (message.maxAcceptedHtlcs != null && message.hasOwnProperty("maxAcceptedHtlcs"))
                object.maxAcceptedHtlcs = message.maxAcceptedHtlcs;
            if (message.channelFlags != null && message.hasOwnProperty("channelFlags"))
                object.channelFlags = message.channelFlags;
            return object;
        };

        /**
         * Converts this ChannelAcceptRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelAcceptRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelAcceptRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelAcceptRequest;
    })();

    lnrpc.ChannelAcceptResponse = (function() {

        /**
         * Properties of a ChannelAcceptResponse.
         * @memberof lnrpc
         * @interface IChannelAcceptResponse
         * @property {boolean|null} [accept] ChannelAcceptResponse accept
         * @property {Uint8Array|null} [pendingChanId] ChannelAcceptResponse pendingChanId
         */

        /**
         * Constructs a new ChannelAcceptResponse.
         * @memberof lnrpc
         * @classdesc Represents a ChannelAcceptResponse.
         * @implements IChannelAcceptResponse
         * @constructor
         * @param {lnrpc.IChannelAcceptResponse=} [properties] Properties to set
         */
        function ChannelAcceptResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelAcceptResponse accept.
         * @member {boolean} accept
         * @memberof lnrpc.ChannelAcceptResponse
         * @instance
         */
        ChannelAcceptResponse.prototype.accept = false;

        /**
         * ChannelAcceptResponse pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.ChannelAcceptResponse
         * @instance
         */
        ChannelAcceptResponse.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * Creates a new ChannelAcceptResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {lnrpc.IChannelAcceptResponse=} [properties] Properties to set
         * @returns {lnrpc.ChannelAcceptResponse} ChannelAcceptResponse instance
         */
        ChannelAcceptResponse.create = function create(properties) {
            return new ChannelAcceptResponse(properties);
        };

        /**
         * Encodes the specified ChannelAcceptResponse message. Does not implicitly {@link lnrpc.ChannelAcceptResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {lnrpc.IChannelAcceptResponse} message ChannelAcceptResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accept != null && Object.hasOwnProperty.call(message, "accept"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.accept);
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pendingChanId);
            return writer;
        };

        /**
         * Encodes the specified ChannelAcceptResponse message, length delimited. Does not implicitly {@link lnrpc.ChannelAcceptResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {lnrpc.IChannelAcceptResponse} message ChannelAcceptResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelAcceptResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelAcceptResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelAcceptResponse} ChannelAcceptResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelAcceptResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accept = reader.bool();
                    break;
                case 2:
                    message.pendingChanId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelAcceptResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelAcceptResponse} ChannelAcceptResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelAcceptResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelAcceptResponse message.
         * @function verify
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelAcceptResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accept != null && message.hasOwnProperty("accept"))
                if (typeof message.accept !== "boolean")
                    return "accept: boolean expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelAcceptResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelAcceptResponse} ChannelAcceptResponse
         */
        ChannelAcceptResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelAcceptResponse)
                return object;
            let message = new $root.lnrpc.ChannelAcceptResponse();
            if (object.accept != null)
                message.accept = Boolean(object.accept);
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            return message;
        };

        /**
         * Creates a plain object from a ChannelAcceptResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelAcceptResponse
         * @static
         * @param {lnrpc.ChannelAcceptResponse} message ChannelAcceptResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelAcceptResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.accept = false;
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
            }
            if (message.accept != null && message.hasOwnProperty("accept"))
                object.accept = message.accept;
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            return object;
        };

        /**
         * Converts this ChannelAcceptResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelAcceptResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelAcceptResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelAcceptResponse;
    })();

    lnrpc.ChannelPoint = (function() {

        /**
         * Properties of a ChannelPoint.
         * @memberof lnrpc
         * @interface IChannelPoint
         * @property {Uint8Array|null} [fundingTxidBytes] ChannelPoint fundingTxidBytes
         * @property {string|null} [fundingTxidStr] ChannelPoint fundingTxidStr
         * @property {number|null} [outputIndex] ChannelPoint outputIndex
         */

        /**
         * Constructs a new ChannelPoint.
         * @memberof lnrpc
         * @classdesc Represents a ChannelPoint.
         * @implements IChannelPoint
         * @constructor
         * @param {lnrpc.IChannelPoint=} [properties] Properties to set
         */
        function ChannelPoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelPoint fundingTxidBytes.
         * @member {Uint8Array|null|undefined} fundingTxidBytes
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.fundingTxidBytes = null;

        /**
         * ChannelPoint fundingTxidStr.
         * @member {string|null|undefined} fundingTxidStr
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.fundingTxidStr = null;

        /**
         * ChannelPoint outputIndex.
         * @member {number} outputIndex
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.outputIndex = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ChannelPoint fundingTxid.
         * @member {"fundingTxidBytes"|"fundingTxidStr"|undefined} fundingTxid
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        Object.defineProperty(ChannelPoint.prototype, "fundingTxid", {
            get: $util.oneOfGetter($oneOfFields = ["fundingTxidBytes", "fundingTxidStr"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ChannelPoint instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint=} [properties] Properties to set
         * @returns {lnrpc.ChannelPoint} ChannelPoint instance
         */
        ChannelPoint.create = function create(properties) {
            return new ChannelPoint(properties);
        };

        /**
         * Encodes the specified ChannelPoint message. Does not implicitly {@link lnrpc.ChannelPoint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint} message ChannelPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fundingTxidBytes != null && Object.hasOwnProperty.call(message, "fundingTxidBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fundingTxidBytes);
            if (message.fundingTxidStr != null && Object.hasOwnProperty.call(message, "fundingTxidStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fundingTxidStr);
            if (message.outputIndex != null && Object.hasOwnProperty.call(message, "outputIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified ChannelPoint message, length delimited. Does not implicitly {@link lnrpc.ChannelPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint} message ChannelPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPoint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelPoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fundingTxidBytes = reader.bytes();
                    break;
                case 2:
                    message.fundingTxidStr = reader.string();
                    break;
                case 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPoint message.
         * @function verify
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes")) {
                properties.fundingTxid = 1;
                if (!(message.fundingTxidBytes && typeof message.fundingTxidBytes.length === "number" || $util.isString(message.fundingTxidBytes)))
                    return "fundingTxidBytes: buffer expected";
            }
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr")) {
                if (properties.fundingTxid === 1)
                    return "fundingTxid: multiple values";
                properties.fundingTxid = 1;
                if (!$util.isString(message.fundingTxidStr))
                    return "fundingTxidStr: string expected";
            }
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates a ChannelPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         */
        ChannelPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelPoint)
                return object;
            let message = new $root.lnrpc.ChannelPoint();
            if (object.fundingTxidBytes != null)
                if (typeof object.fundingTxidBytes === "string")
                    $util.base64.decode(object.fundingTxidBytes, message.fundingTxidBytes = $util.newBuffer($util.base64.length(object.fundingTxidBytes)), 0);
                else if (object.fundingTxidBytes.length)
                    message.fundingTxidBytes = object.fundingTxidBytes;
            if (object.fundingTxidStr != null)
                message.fundingTxidStr = String(object.fundingTxidStr);
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChannelPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.ChannelPoint} message ChannelPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.outputIndex = 0;
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes")) {
                object.fundingTxidBytes = options.bytes === String ? $util.base64.encode(message.fundingTxidBytes, 0, message.fundingTxidBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.fundingTxidBytes) : message.fundingTxidBytes;
                if (options.oneofs)
                    object.fundingTxid = "fundingTxidBytes";
            }
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr")) {
                object.fundingTxidStr = message.fundingTxidStr;
                if (options.oneofs)
                    object.fundingTxid = "fundingTxidStr";
            }
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this ChannelPoint to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPoint;
    })();

    lnrpc.OutPoint = (function() {

        /**
         * Properties of an OutPoint.
         * @memberof lnrpc
         * @interface IOutPoint
         * @property {Uint8Array|null} [txidBytes] OutPoint txidBytes
         * @property {string|null} [txidStr] OutPoint txidStr
         * @property {number|null} [outputIndex] OutPoint outputIndex
         */

        /**
         * Constructs a new OutPoint.
         * @memberof lnrpc
         * @classdesc Represents an OutPoint.
         * @implements IOutPoint
         * @constructor
         * @param {lnrpc.IOutPoint=} [properties] Properties to set
         */
        function OutPoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutPoint txidBytes.
         * @member {Uint8Array} txidBytes
         * @memberof lnrpc.OutPoint
         * @instance
         */
        OutPoint.prototype.txidBytes = $util.newBuffer([]);

        /**
         * OutPoint txidStr.
         * @member {string} txidStr
         * @memberof lnrpc.OutPoint
         * @instance
         */
        OutPoint.prototype.txidStr = "";

        /**
         * OutPoint outputIndex.
         * @member {number} outputIndex
         * @memberof lnrpc.OutPoint
         * @instance
         */
        OutPoint.prototype.outputIndex = 0;

        /**
         * Creates a new OutPoint instance using the specified properties.
         * @function create
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.IOutPoint=} [properties] Properties to set
         * @returns {lnrpc.OutPoint} OutPoint instance
         */
        OutPoint.create = function create(properties) {
            return new OutPoint(properties);
        };

        /**
         * Encodes the specified OutPoint message. Does not implicitly {@link lnrpc.OutPoint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.IOutPoint} message OutPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txidBytes != null && Object.hasOwnProperty.call(message, "txidBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txidBytes);
            if (message.txidStr != null && Object.hasOwnProperty.call(message, "txidStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.txidStr);
            if (message.outputIndex != null && Object.hasOwnProperty.call(message, "outputIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified OutPoint message, length delimited. Does not implicitly {@link lnrpc.OutPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.IOutPoint} message OutPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OutPoint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OutPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OutPoint} OutPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OutPoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txidBytes = reader.bytes();
                    break;
                case 2:
                    message.txidStr = reader.string();
                    break;
                case 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OutPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OutPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OutPoint} OutPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OutPoint message.
         * @function verify
         * @memberof lnrpc.OutPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OutPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txidBytes != null && message.hasOwnProperty("txidBytes"))
                if (!(message.txidBytes && typeof message.txidBytes.length === "number" || $util.isString(message.txidBytes)))
                    return "txidBytes: buffer expected";
            if (message.txidStr != null && message.hasOwnProperty("txidStr"))
                if (!$util.isString(message.txidStr))
                    return "txidStr: string expected";
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OutPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OutPoint} OutPoint
         */
        OutPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OutPoint)
                return object;
            let message = new $root.lnrpc.OutPoint();
            if (object.txidBytes != null)
                if (typeof object.txidBytes === "string")
                    $util.base64.decode(object.txidBytes, message.txidBytes = $util.newBuffer($util.base64.length(object.txidBytes)), 0);
                else if (object.txidBytes.length)
                    message.txidBytes = object.txidBytes;
            if (object.txidStr != null)
                message.txidStr = String(object.txidStr);
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.OutPoint} message OutPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OutPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.txidBytes = "";
                else {
                    object.txidBytes = [];
                    if (options.bytes !== Array)
                        object.txidBytes = $util.newBuffer(object.txidBytes);
                }
                object.txidStr = "";
                object.outputIndex = 0;
            }
            if (message.txidBytes != null && message.hasOwnProperty("txidBytes"))
                object.txidBytes = options.bytes === String ? $util.base64.encode(message.txidBytes, 0, message.txidBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.txidBytes) : message.txidBytes;
            if (message.txidStr != null && message.hasOwnProperty("txidStr"))
                object.txidStr = message.txidStr;
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this OutPoint to JSON.
         * @function toJSON
         * @memberof lnrpc.OutPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OutPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OutPoint;
    })();

    lnrpc.LightningAddress = (function() {

        /**
         * Properties of a LightningAddress.
         * @memberof lnrpc
         * @interface ILightningAddress
         * @property {string|null} [pubkey] LightningAddress pubkey
         * @property {string|null} [host] LightningAddress host
         */

        /**
         * Constructs a new LightningAddress.
         * @memberof lnrpc
         * @classdesc Represents a LightningAddress.
         * @implements ILightningAddress
         * @constructor
         * @param {lnrpc.ILightningAddress=} [properties] Properties to set
         */
        function LightningAddress(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightningAddress pubkey.
         * @member {string} pubkey
         * @memberof lnrpc.LightningAddress
         * @instance
         */
        LightningAddress.prototype.pubkey = "";

        /**
         * LightningAddress host.
         * @member {string} host
         * @memberof lnrpc.LightningAddress
         * @instance
         */
        LightningAddress.prototype.host = "";

        /**
         * Creates a new LightningAddress instance using the specified properties.
         * @function create
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress=} [properties] Properties to set
         * @returns {lnrpc.LightningAddress} LightningAddress instance
         */
        LightningAddress.create = function create(properties) {
            return new LightningAddress(properties);
        };

        /**
         * Encodes the specified LightningAddress message. Does not implicitly {@link lnrpc.LightningAddress.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress} message LightningAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkey);
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            return writer;
        };

        /**
         * Encodes the specified LightningAddress message, length delimited. Does not implicitly {@link lnrpc.LightningAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress} message LightningAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightningAddress message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.LightningAddress} LightningAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.LightningAddress();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubkey = reader.string();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightningAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.LightningAddress} LightningAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightningAddress message.
         * @function verify
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightningAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!$util.isString(message.pubkey))
                    return "pubkey: string expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            return null;
        };

        /**
         * Creates a LightningAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.LightningAddress} LightningAddress
         */
        LightningAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.LightningAddress)
                return object;
            let message = new $root.lnrpc.LightningAddress();
            if (object.pubkey != null)
                message.pubkey = String(object.pubkey);
            if (object.host != null)
                message.host = String(object.host);
            return message;
        };

        /**
         * Creates a plain object from a LightningAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.LightningAddress} message LightningAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightningAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pubkey = "";
                object.host = "";
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = message.pubkey;
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            return object;
        };

        /**
         * Converts this LightningAddress to JSON.
         * @function toJSON
         * @memberof lnrpc.LightningAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightningAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightningAddress;
    })();

    lnrpc.EstimateFeeRequest = (function() {

        /**
         * Properties of an EstimateFeeRequest.
         * @memberof lnrpc
         * @interface IEstimateFeeRequest
         * @property {Object.<string,number|Long>|null} [AddrToAmount] EstimateFeeRequest AddrToAmount
         * @property {number|null} [targetConf] EstimateFeeRequest targetConf
         */

        /**
         * Constructs a new EstimateFeeRequest.
         * @memberof lnrpc
         * @classdesc Represents an EstimateFeeRequest.
         * @implements IEstimateFeeRequest
         * @constructor
         * @param {lnrpc.IEstimateFeeRequest=} [properties] Properties to set
         */
        function EstimateFeeRequest(properties) {
            this.AddrToAmount = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EstimateFeeRequest AddrToAmount.
         * @member {Object.<string,number|Long>} AddrToAmount
         * @memberof lnrpc.EstimateFeeRequest
         * @instance
         */
        EstimateFeeRequest.prototype.AddrToAmount = $util.emptyObject;

        /**
         * EstimateFeeRequest targetConf.
         * @member {number} targetConf
         * @memberof lnrpc.EstimateFeeRequest
         * @instance
         */
        EstimateFeeRequest.prototype.targetConf = 0;

        /**
         * Creates a new EstimateFeeRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.IEstimateFeeRequest=} [properties] Properties to set
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest instance
         */
        EstimateFeeRequest.create = function create(properties) {
            return new EstimateFeeRequest(properties);
        };

        /**
         * Encodes the specified EstimateFeeRequest message. Does not implicitly {@link lnrpc.EstimateFeeRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.IEstimateFeeRequest} message EstimateFeeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddrToAmount != null && Object.hasOwnProperty.call(message, "AddrToAmount"))
                for (let keys = Object.keys(message.AddrToAmount), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.AddrToAmount[keys[i]]).ldelim();
            if (message.targetConf != null && Object.hasOwnProperty.call(message, "targetConf"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.targetConf);
            return writer;
        };

        /**
         * Encodes the specified EstimateFeeRequest message, length delimited. Does not implicitly {@link lnrpc.EstimateFeeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.IEstimateFeeRequest} message EstimateFeeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EstimateFeeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.EstimateFeeRequest(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.AddrToAmount === $util.emptyObject)
                        message.AddrToAmount = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.AddrToAmount[key] = value;
                    break;
                case 2:
                    message.targetConf = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EstimateFeeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EstimateFeeRequest message.
         * @function verify
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EstimateFeeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount")) {
                if (!$util.isObject(message.AddrToAmount))
                    return "AddrToAmount: object expected";
                let key = Object.keys(message.AddrToAmount);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.AddrToAmount[key[i]]) && !(message.AddrToAmount[key[i]] && $util.isInteger(message.AddrToAmount[key[i]].low) && $util.isInteger(message.AddrToAmount[key[i]].high)))
                        return "AddrToAmount: integer|Long{k:string} expected";
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            return null;
        };

        /**
         * Creates an EstimateFeeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest
         */
        EstimateFeeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.EstimateFeeRequest)
                return object;
            let message = new $root.lnrpc.EstimateFeeRequest();
            if (object.AddrToAmount) {
                if (typeof object.AddrToAmount !== "object")
                    throw TypeError(".lnrpc.EstimateFeeRequest.AddrToAmount: object expected");
                message.AddrToAmount = {};
                for (let keys = Object.keys(object.AddrToAmount), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.AddrToAmount[keys[i]] = $util.Long.fromValue(object.AddrToAmount[keys[i]])).unsigned = false;
                    else if (typeof object.AddrToAmount[keys[i]] === "string")
                        message.AddrToAmount[keys[i]] = parseInt(object.AddrToAmount[keys[i]], 10);
                    else if (typeof object.AddrToAmount[keys[i]] === "number")
                        message.AddrToAmount[keys[i]] = object.AddrToAmount[keys[i]];
                    else if (typeof object.AddrToAmount[keys[i]] === "object")
                        message.AddrToAmount[keys[i]] = new $util.LongBits(object.AddrToAmount[keys[i]].low >>> 0, object.AddrToAmount[keys[i]].high >>> 0).toNumber();
            }
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            return message;
        };

        /**
         * Creates a plain object from an EstimateFeeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.EstimateFeeRequest} message EstimateFeeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EstimateFeeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.AddrToAmount = {};
            if (options.defaults)
                object.targetConf = 0;
            let keys2;
            if (message.AddrToAmount && (keys2 = Object.keys(message.AddrToAmount)).length) {
                object.AddrToAmount = {};
                for (let j = 0; j < keys2.length; ++j)
                    if (typeof message.AddrToAmount[keys2[j]] === "number")
                        object.AddrToAmount[keys2[j]] = options.longs === String ? String(message.AddrToAmount[keys2[j]]) : message.AddrToAmount[keys2[j]];
                    else
                        object.AddrToAmount[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.AddrToAmount[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.AddrToAmount[keys2[j]].low >>> 0, message.AddrToAmount[keys2[j]].high >>> 0).toNumber() : message.AddrToAmount[keys2[j]];
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            return object;
        };

        /**
         * Converts this EstimateFeeRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.EstimateFeeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EstimateFeeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EstimateFeeRequest;
    })();

    lnrpc.EstimateFeeResponse = (function() {

        /**
         * Properties of an EstimateFeeResponse.
         * @memberof lnrpc
         * @interface IEstimateFeeResponse
         * @property {number|Long|null} [feeSat] EstimateFeeResponse feeSat
         * @property {number|Long|null} [feerateSatPerByte] EstimateFeeResponse feerateSatPerByte
         */

        /**
         * Constructs a new EstimateFeeResponse.
         * @memberof lnrpc
         * @classdesc Represents an EstimateFeeResponse.
         * @implements IEstimateFeeResponse
         * @constructor
         * @param {lnrpc.IEstimateFeeResponse=} [properties] Properties to set
         */
        function EstimateFeeResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EstimateFeeResponse feeSat.
         * @member {number|Long} feeSat
         * @memberof lnrpc.EstimateFeeResponse
         * @instance
         */
        EstimateFeeResponse.prototype.feeSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EstimateFeeResponse feerateSatPerByte.
         * @member {number|Long} feerateSatPerByte
         * @memberof lnrpc.EstimateFeeResponse
         * @instance
         */
        EstimateFeeResponse.prototype.feerateSatPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EstimateFeeResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.IEstimateFeeResponse=} [properties] Properties to set
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse instance
         */
        EstimateFeeResponse.create = function create(properties) {
            return new EstimateFeeResponse(properties);
        };

        /**
         * Encodes the specified EstimateFeeResponse message. Does not implicitly {@link lnrpc.EstimateFeeResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.IEstimateFeeResponse} message EstimateFeeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.feeSat != null && Object.hasOwnProperty.call(message, "feeSat"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.feeSat);
            if (message.feerateSatPerByte != null && Object.hasOwnProperty.call(message, "feerateSatPerByte"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.feerateSatPerByte);
            return writer;
        };

        /**
         * Encodes the specified EstimateFeeResponse message, length delimited. Does not implicitly {@link lnrpc.EstimateFeeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.IEstimateFeeResponse} message EstimateFeeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EstimateFeeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.EstimateFeeResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feeSat = reader.int64();
                    break;
                case 2:
                    message.feerateSatPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EstimateFeeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EstimateFeeResponse message.
         * @function verify
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EstimateFeeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (!$util.isInteger(message.feeSat) && !(message.feeSat && $util.isInteger(message.feeSat.low) && $util.isInteger(message.feeSat.high)))
                    return "feeSat: integer|Long expected";
            if (message.feerateSatPerByte != null && message.hasOwnProperty("feerateSatPerByte"))
                if (!$util.isInteger(message.feerateSatPerByte) && !(message.feerateSatPerByte && $util.isInteger(message.feerateSatPerByte.low) && $util.isInteger(message.feerateSatPerByte.high)))
                    return "feerateSatPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates an EstimateFeeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse
         */
        EstimateFeeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.EstimateFeeResponse)
                return object;
            let message = new $root.lnrpc.EstimateFeeResponse();
            if (object.feeSat != null)
                if ($util.Long)
                    (message.feeSat = $util.Long.fromValue(object.feeSat)).unsigned = false;
                else if (typeof object.feeSat === "string")
                    message.feeSat = parseInt(object.feeSat, 10);
                else if (typeof object.feeSat === "number")
                    message.feeSat = object.feeSat;
                else if (typeof object.feeSat === "object")
                    message.feeSat = new $util.LongBits(object.feeSat.low >>> 0, object.feeSat.high >>> 0).toNumber();
            if (object.feerateSatPerByte != null)
                if ($util.Long)
                    (message.feerateSatPerByte = $util.Long.fromValue(object.feerateSatPerByte)).unsigned = false;
                else if (typeof object.feerateSatPerByte === "string")
                    message.feerateSatPerByte = parseInt(object.feerateSatPerByte, 10);
                else if (typeof object.feerateSatPerByte === "number")
                    message.feerateSatPerByte = object.feerateSatPerByte;
                else if (typeof object.feerateSatPerByte === "object")
                    message.feerateSatPerByte = new $util.LongBits(object.feerateSatPerByte.low >>> 0, object.feerateSatPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EstimateFeeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.EstimateFeeResponse} message EstimateFeeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EstimateFeeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feerateSatPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feerateSatPerByte = options.longs === String ? "0" : 0;
            }
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (typeof message.feeSat === "number")
                    object.feeSat = options.longs === String ? String(message.feeSat) : message.feeSat;
                else
                    object.feeSat = options.longs === String ? $util.Long.prototype.toString.call(message.feeSat) : options.longs === Number ? new $util.LongBits(message.feeSat.low >>> 0, message.feeSat.high >>> 0).toNumber() : message.feeSat;
            if (message.feerateSatPerByte != null && message.hasOwnProperty("feerateSatPerByte"))
                if (typeof message.feerateSatPerByte === "number")
                    object.feerateSatPerByte = options.longs === String ? String(message.feerateSatPerByte) : message.feerateSatPerByte;
                else
                    object.feerateSatPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.feerateSatPerByte) : options.longs === Number ? new $util.LongBits(message.feerateSatPerByte.low >>> 0, message.feerateSatPerByte.high >>> 0).toNumber() : message.feerateSatPerByte;
            return object;
        };

        /**
         * Converts this EstimateFeeResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.EstimateFeeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EstimateFeeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EstimateFeeResponse;
    })();

    lnrpc.SendManyRequest = (function() {

        /**
         * Properties of a SendManyRequest.
         * @memberof lnrpc
         * @interface ISendManyRequest
         * @property {Object.<string,number|Long>|null} [AddrToAmount] SendManyRequest AddrToAmount
         * @property {number|null} [targetConf] SendManyRequest targetConf
         * @property {number|Long|null} [satPerByte] SendManyRequest satPerByte
         * @property {string|null} [label] SendManyRequest label
         * @property {number|null} [minConfs] SendManyRequest minConfs
         * @property {boolean|null} [spendUnconfirmed] SendManyRequest spendUnconfirmed
         */

        /**
         * Constructs a new SendManyRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendManyRequest.
         * @implements ISendManyRequest
         * @constructor
         * @param {lnrpc.ISendManyRequest=} [properties] Properties to set
         */
        function SendManyRequest(properties) {
            this.AddrToAmount = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendManyRequest AddrToAmount.
         * @member {Object.<string,number|Long>} AddrToAmount
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.AddrToAmount = $util.emptyObject;

        /**
         * SendManyRequest targetConf.
         * @member {number} targetConf
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.targetConf = 0;

        /**
         * SendManyRequest satPerByte.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SendManyRequest label.
         * @member {string} label
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.label = "";

        /**
         * SendManyRequest minConfs.
         * @member {number} minConfs
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.minConfs = 0;

        /**
         * SendManyRequest spendUnconfirmed.
         * @member {boolean} spendUnconfirmed
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.spendUnconfirmed = false;

        /**
         * Creates a new SendManyRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest=} [properties] Properties to set
         * @returns {lnrpc.SendManyRequest} SendManyRequest instance
         */
        SendManyRequest.create = function create(properties) {
            return new SendManyRequest(properties);
        };

        /**
         * Encodes the specified SendManyRequest message. Does not implicitly {@link lnrpc.SendManyRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest} message SendManyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddrToAmount != null && Object.hasOwnProperty.call(message, "AddrToAmount"))
                for (let keys = Object.keys(message.AddrToAmount), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.AddrToAmount[keys[i]]).ldelim();
            if (message.targetConf != null && Object.hasOwnProperty.call(message, "targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && Object.hasOwnProperty.call(message, "satPerByte"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.satPerByte);
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.label);
            if (message.minConfs != null && Object.hasOwnProperty.call(message, "minConfs"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.minConfs);
            if (message.spendUnconfirmed != null && Object.hasOwnProperty.call(message, "spendUnconfirmed"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.spendUnconfirmed);
            return writer;
        };

        /**
         * Encodes the specified SendManyRequest message, length delimited. Does not implicitly {@link lnrpc.SendManyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest} message SendManyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendManyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendManyRequest(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.AddrToAmount === $util.emptyObject)
                        message.AddrToAmount = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.AddrToAmount[key] = value;
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 5:
                    message.satPerByte = reader.int64();
                    break;
                case 6:
                    message.label = reader.string();
                    break;
                case 7:
                    message.minConfs = reader.int32();
                    break;
                case 8:
                    message.spendUnconfirmed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendManyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendManyRequest message.
         * @function verify
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendManyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount")) {
                if (!$util.isObject(message.AddrToAmount))
                    return "AddrToAmount: object expected";
                let key = Object.keys(message.AddrToAmount);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.AddrToAmount[key[i]]) && !(message.AddrToAmount[key[i]] && $util.isInteger(message.AddrToAmount[key[i]].low) && $util.isInteger(message.AddrToAmount[key[i]].high)))
                        return "AddrToAmount: integer|Long{k:string} expected";
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                if (!$util.isInteger(message.minConfs))
                    return "minConfs: integer expected";
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                if (typeof message.spendUnconfirmed !== "boolean")
                    return "spendUnconfirmed: boolean expected";
            return null;
        };

        /**
         * Creates a SendManyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         */
        SendManyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendManyRequest)
                return object;
            let message = new $root.lnrpc.SendManyRequest();
            if (object.AddrToAmount) {
                if (typeof object.AddrToAmount !== "object")
                    throw TypeError(".lnrpc.SendManyRequest.AddrToAmount: object expected");
                message.AddrToAmount = {};
                for (let keys = Object.keys(object.AddrToAmount), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.AddrToAmount[keys[i]] = $util.Long.fromValue(object.AddrToAmount[keys[i]])).unsigned = false;
                    else if (typeof object.AddrToAmount[keys[i]] === "string")
                        message.AddrToAmount[keys[i]] = parseInt(object.AddrToAmount[keys[i]], 10);
                    else if (typeof object.AddrToAmount[keys[i]] === "number")
                        message.AddrToAmount[keys[i]] = object.AddrToAmount[keys[i]];
                    else if (typeof object.AddrToAmount[keys[i]] === "object")
                        message.AddrToAmount[keys[i]] = new $util.LongBits(object.AddrToAmount[keys[i]].low >>> 0, object.AddrToAmount[keys[i]].high >>> 0).toNumber();
            }
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object.label != null)
                message.label = String(object.label);
            if (object.minConfs != null)
                message.minConfs = object.minConfs | 0;
            if (object.spendUnconfirmed != null)
                message.spendUnconfirmed = Boolean(object.spendUnconfirmed);
            return message;
        };

        /**
         * Creates a plain object from a SendManyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.SendManyRequest} message SendManyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendManyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.AddrToAmount = {};
            if (options.defaults) {
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object.label = "";
                object.minConfs = 0;
                object.spendUnconfirmed = false;
            }
            let keys2;
            if (message.AddrToAmount && (keys2 = Object.keys(message.AddrToAmount)).length) {
                object.AddrToAmount = {};
                for (let j = 0; j < keys2.length; ++j)
                    if (typeof message.AddrToAmount[keys2[j]] === "number")
                        object.AddrToAmount[keys2[j]] = options.longs === String ? String(message.AddrToAmount[keys2[j]]) : message.AddrToAmount[keys2[j]];
                    else
                        object.AddrToAmount[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.AddrToAmount[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.AddrToAmount[keys2[j]].low >>> 0, message.AddrToAmount[keys2[j]].high >>> 0).toNumber() : message.AddrToAmount[keys2[j]];
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                object.minConfs = message.minConfs;
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                object.spendUnconfirmed = message.spendUnconfirmed;
            return object;
        };

        /**
         * Converts this SendManyRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendManyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendManyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendManyRequest;
    })();

    lnrpc.SendManyResponse = (function() {

        /**
         * Properties of a SendManyResponse.
         * @memberof lnrpc
         * @interface ISendManyResponse
         * @property {string|null} [txid] SendManyResponse txid
         */

        /**
         * Constructs a new SendManyResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendManyResponse.
         * @implements ISendManyResponse
         * @constructor
         * @param {lnrpc.ISendManyResponse=} [properties] Properties to set
         */
        function SendManyResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendManyResponse txid.
         * @member {string} txid
         * @memberof lnrpc.SendManyResponse
         * @instance
         */
        SendManyResponse.prototype.txid = "";

        /**
         * Creates a new SendManyResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse=} [properties] Properties to set
         * @returns {lnrpc.SendManyResponse} SendManyResponse instance
         */
        SendManyResponse.create = function create(properties) {
            return new SendManyResponse(properties);
        };

        /**
         * Encodes the specified SendManyResponse message. Does not implicitly {@link lnrpc.SendManyResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse} message SendManyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            return writer;
        };

        /**
         * Encodes the specified SendManyResponse message, length delimited. Does not implicitly {@link lnrpc.SendManyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse} message SendManyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendManyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendManyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendManyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendManyResponse message.
         * @function verify
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendManyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            return null;
        };

        /**
         * Creates a SendManyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         */
        SendManyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendManyResponse)
                return object;
            let message = new $root.lnrpc.SendManyResponse();
            if (object.txid != null)
                message.txid = String(object.txid);
            return message;
        };

        /**
         * Creates a plain object from a SendManyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.SendManyResponse} message SendManyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendManyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.txid = "";
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            return object;
        };

        /**
         * Converts this SendManyResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendManyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendManyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendManyResponse;
    })();

    lnrpc.SendCoinsRequest = (function() {

        /**
         * Properties of a SendCoinsRequest.
         * @memberof lnrpc
         * @interface ISendCoinsRequest
         * @property {string|null} [addr] SendCoinsRequest addr
         * @property {number|Long|null} [amount] SendCoinsRequest amount
         * @property {number|null} [targetConf] SendCoinsRequest targetConf
         * @property {number|Long|null} [satPerByte] SendCoinsRequest satPerByte
         * @property {boolean|null} [sendAll] SendCoinsRequest sendAll
         * @property {string|null} [label] SendCoinsRequest label
         * @property {number|null} [minConfs] SendCoinsRequest minConfs
         * @property {boolean|null} [spendUnconfirmed] SendCoinsRequest spendUnconfirmed
         */

        /**
         * Constructs a new SendCoinsRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendCoinsRequest.
         * @implements ISendCoinsRequest
         * @constructor
         * @param {lnrpc.ISendCoinsRequest=} [properties] Properties to set
         */
        function SendCoinsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendCoinsRequest addr.
         * @member {string} addr
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.addr = "";

        /**
         * SendCoinsRequest amount.
         * @member {number|Long} amount
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SendCoinsRequest targetConf.
         * @member {number} targetConf
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.targetConf = 0;

        /**
         * SendCoinsRequest satPerByte.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SendCoinsRequest sendAll.
         * @member {boolean} sendAll
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.sendAll = false;

        /**
         * SendCoinsRequest label.
         * @member {string} label
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.label = "";

        /**
         * SendCoinsRequest minConfs.
         * @member {number} minConfs
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.minConfs = 0;

        /**
         * SendCoinsRequest spendUnconfirmed.
         * @member {boolean} spendUnconfirmed
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.spendUnconfirmed = false;

        /**
         * Creates a new SendCoinsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest=} [properties] Properties to set
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest instance
         */
        SendCoinsRequest.create = function create(properties) {
            return new SendCoinsRequest(properties);
        };

        /**
         * Encodes the specified SendCoinsRequest message. Does not implicitly {@link lnrpc.SendCoinsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest} message SendCoinsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && Object.hasOwnProperty.call(message, "addr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.addr);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.targetConf != null && Object.hasOwnProperty.call(message, "targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && Object.hasOwnProperty.call(message, "satPerByte"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.satPerByte);
            if (message.sendAll != null && Object.hasOwnProperty.call(message, "sendAll"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.sendAll);
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.label);
            if (message.minConfs != null && Object.hasOwnProperty.call(message, "minConfs"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.minConfs);
            if (message.spendUnconfirmed != null && Object.hasOwnProperty.call(message, "spendUnconfirmed"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.spendUnconfirmed);
            return writer;
        };

        /**
         * Encodes the specified SendCoinsRequest message, length delimited. Does not implicitly {@link lnrpc.SendCoinsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest} message SendCoinsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendCoinsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendCoinsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 5:
                    message.satPerByte = reader.int64();
                    break;
                case 6:
                    message.sendAll = reader.bool();
                    break;
                case 7:
                    message.label = reader.string();
                    break;
                case 8:
                    message.minConfs = reader.int32();
                    break;
                case 9:
                    message.spendUnconfirmed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendCoinsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendCoinsRequest message.
         * @function verify
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendCoinsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message.sendAll != null && message.hasOwnProperty("sendAll"))
                if (typeof message.sendAll !== "boolean")
                    return "sendAll: boolean expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                if (!$util.isInteger(message.minConfs))
                    return "minConfs: integer expected";
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                if (typeof message.spendUnconfirmed !== "boolean")
                    return "spendUnconfirmed: boolean expected";
            return null;
        };

        /**
         * Creates a SendCoinsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         */
        SendCoinsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendCoinsRequest)
                return object;
            let message = new $root.lnrpc.SendCoinsRequest();
            if (object.addr != null)
                message.addr = String(object.addr);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object.sendAll != null)
                message.sendAll = Boolean(object.sendAll);
            if (object.label != null)
                message.label = String(object.label);
            if (object.minConfs != null)
                message.minConfs = object.minConfs | 0;
            if (object.spendUnconfirmed != null)
                message.spendUnconfirmed = Boolean(object.spendUnconfirmed);
            return message;
        };

        /**
         * Creates a plain object from a SendCoinsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.SendCoinsRequest} message SendCoinsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendCoinsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addr = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object.sendAll = false;
                object.label = "";
                object.minConfs = 0;
                object.spendUnconfirmed = false;
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message.sendAll != null && message.hasOwnProperty("sendAll"))
                object.sendAll = message.sendAll;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                object.minConfs = message.minConfs;
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                object.spendUnconfirmed = message.spendUnconfirmed;
            return object;
        };

        /**
         * Converts this SendCoinsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendCoinsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendCoinsRequest;
    })();

    lnrpc.SendCoinsResponse = (function() {

        /**
         * Properties of a SendCoinsResponse.
         * @memberof lnrpc
         * @interface ISendCoinsResponse
         * @property {string|null} [txid] SendCoinsResponse txid
         */

        /**
         * Constructs a new SendCoinsResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendCoinsResponse.
         * @implements ISendCoinsResponse
         * @constructor
         * @param {lnrpc.ISendCoinsResponse=} [properties] Properties to set
         */
        function SendCoinsResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendCoinsResponse txid.
         * @member {string} txid
         * @memberof lnrpc.SendCoinsResponse
         * @instance
         */
        SendCoinsResponse.prototype.txid = "";

        /**
         * Creates a new SendCoinsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse=} [properties] Properties to set
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse instance
         */
        SendCoinsResponse.create = function create(properties) {
            return new SendCoinsResponse(properties);
        };

        /**
         * Encodes the specified SendCoinsResponse message. Does not implicitly {@link lnrpc.SendCoinsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse} message SendCoinsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            return writer;
        };

        /**
         * Encodes the specified SendCoinsResponse message, length delimited. Does not implicitly {@link lnrpc.SendCoinsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse} message SendCoinsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendCoinsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendCoinsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendCoinsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendCoinsResponse message.
         * @function verify
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendCoinsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            return null;
        };

        /**
         * Creates a SendCoinsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         */
        SendCoinsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendCoinsResponse)
                return object;
            let message = new $root.lnrpc.SendCoinsResponse();
            if (object.txid != null)
                message.txid = String(object.txid);
            return message;
        };

        /**
         * Creates a plain object from a SendCoinsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.SendCoinsResponse} message SendCoinsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendCoinsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.txid = "";
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            return object;
        };

        /**
         * Converts this SendCoinsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendCoinsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendCoinsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendCoinsResponse;
    })();

    lnrpc.ListUnspentRequest = (function() {

        /**
         * Properties of a ListUnspentRequest.
         * @memberof lnrpc
         * @interface IListUnspentRequest
         * @property {number|null} [minConfs] ListUnspentRequest minConfs
         * @property {number|null} [maxConfs] ListUnspentRequest maxConfs
         */

        /**
         * Constructs a new ListUnspentRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListUnspentRequest.
         * @implements IListUnspentRequest
         * @constructor
         * @param {lnrpc.IListUnspentRequest=} [properties] Properties to set
         */
        function ListUnspentRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListUnspentRequest minConfs.
         * @member {number} minConfs
         * @memberof lnrpc.ListUnspentRequest
         * @instance
         */
        ListUnspentRequest.prototype.minConfs = 0;

        /**
         * ListUnspentRequest maxConfs.
         * @member {number} maxConfs
         * @memberof lnrpc.ListUnspentRequest
         * @instance
         */
        ListUnspentRequest.prototype.maxConfs = 0;

        /**
         * Creates a new ListUnspentRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.IListUnspentRequest=} [properties] Properties to set
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest instance
         */
        ListUnspentRequest.create = function create(properties) {
            return new ListUnspentRequest(properties);
        };

        /**
         * Encodes the specified ListUnspentRequest message. Does not implicitly {@link lnrpc.ListUnspentRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.IListUnspentRequest} message ListUnspentRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minConfs != null && Object.hasOwnProperty.call(message, "minConfs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minConfs);
            if (message.maxConfs != null && Object.hasOwnProperty.call(message, "maxConfs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxConfs);
            return writer;
        };

        /**
         * Encodes the specified ListUnspentRequest message, length delimited. Does not implicitly {@link lnrpc.ListUnspentRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.IListUnspentRequest} message ListUnspentRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListUnspentRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListUnspentRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minConfs = reader.int32();
                    break;
                case 2:
                    message.maxConfs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListUnspentRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListUnspentRequest message.
         * @function verify
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListUnspentRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                if (!$util.isInteger(message.minConfs))
                    return "minConfs: integer expected";
            if (message.maxConfs != null && message.hasOwnProperty("maxConfs"))
                if (!$util.isInteger(message.maxConfs))
                    return "maxConfs: integer expected";
            return null;
        };

        /**
         * Creates a ListUnspentRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest
         */
        ListUnspentRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListUnspentRequest)
                return object;
            let message = new $root.lnrpc.ListUnspentRequest();
            if (object.minConfs != null)
                message.minConfs = object.minConfs | 0;
            if (object.maxConfs != null)
                message.maxConfs = object.maxConfs | 0;
            return message;
        };

        /**
         * Creates a plain object from a ListUnspentRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.ListUnspentRequest} message ListUnspentRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListUnspentRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.minConfs = 0;
                object.maxConfs = 0;
            }
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                object.minConfs = message.minConfs;
            if (message.maxConfs != null && message.hasOwnProperty("maxConfs"))
                object.maxConfs = message.maxConfs;
            return object;
        };

        /**
         * Converts this ListUnspentRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListUnspentRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListUnspentRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListUnspentRequest;
    })();

    lnrpc.ListUnspentResponse = (function() {

        /**
         * Properties of a ListUnspentResponse.
         * @memberof lnrpc
         * @interface IListUnspentResponse
         * @property {Array.<lnrpc.IUtxo>|null} [utxos] ListUnspentResponse utxos
         */

        /**
         * Constructs a new ListUnspentResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListUnspentResponse.
         * @implements IListUnspentResponse
         * @constructor
         * @param {lnrpc.IListUnspentResponse=} [properties] Properties to set
         */
        function ListUnspentResponse(properties) {
            this.utxos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListUnspentResponse utxos.
         * @member {Array.<lnrpc.IUtxo>} utxos
         * @memberof lnrpc.ListUnspentResponse
         * @instance
         */
        ListUnspentResponse.prototype.utxos = $util.emptyArray;

        /**
         * Creates a new ListUnspentResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.IListUnspentResponse=} [properties] Properties to set
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse instance
         */
        ListUnspentResponse.create = function create(properties) {
            return new ListUnspentResponse(properties);
        };

        /**
         * Encodes the specified ListUnspentResponse message. Does not implicitly {@link lnrpc.ListUnspentResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.IListUnspentResponse} message ListUnspentResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.utxos != null && message.utxos.length)
                for (let i = 0; i < message.utxos.length; ++i)
                    $root.lnrpc.Utxo.encode(message.utxos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListUnspentResponse message, length delimited. Does not implicitly {@link lnrpc.ListUnspentResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.IListUnspentResponse} message ListUnspentResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListUnspentResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListUnspentResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.utxos && message.utxos.length))
                        message.utxos = [];
                    message.utxos.push($root.lnrpc.Utxo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListUnspentResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListUnspentResponse message.
         * @function verify
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListUnspentResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.utxos != null && message.hasOwnProperty("utxos")) {
                if (!Array.isArray(message.utxos))
                    return "utxos: array expected";
                for (let i = 0; i < message.utxos.length; ++i) {
                    let error = $root.lnrpc.Utxo.verify(message.utxos[i]);
                    if (error)
                        return "utxos." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListUnspentResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse
         */
        ListUnspentResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListUnspentResponse)
                return object;
            let message = new $root.lnrpc.ListUnspentResponse();
            if (object.utxos) {
                if (!Array.isArray(object.utxos))
                    throw TypeError(".lnrpc.ListUnspentResponse.utxos: array expected");
                message.utxos = [];
                for (let i = 0; i < object.utxos.length; ++i) {
                    if (typeof object.utxos[i] !== "object")
                        throw TypeError(".lnrpc.ListUnspentResponse.utxos: object expected");
                    message.utxos[i] = $root.lnrpc.Utxo.fromObject(object.utxos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListUnspentResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.ListUnspentResponse} message ListUnspentResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListUnspentResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.utxos = [];
            if (message.utxos && message.utxos.length) {
                object.utxos = [];
                for (let j = 0; j < message.utxos.length; ++j)
                    object.utxos[j] = $root.lnrpc.Utxo.toObject(message.utxos[j], options);
            }
            return object;
        };

        /**
         * Converts this ListUnspentResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListUnspentResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListUnspentResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListUnspentResponse;
    })();

    /**
     * AddressType enum.
     * @name lnrpc.AddressType
     * @enum {number}
     * @property {number} WITNESS_PUBKEY_HASH=0 WITNESS_PUBKEY_HASH value
     * @property {number} NESTED_PUBKEY_HASH=1 NESTED_PUBKEY_HASH value
     * @property {number} UNUSED_WITNESS_PUBKEY_HASH=2 UNUSED_WITNESS_PUBKEY_HASH value
     * @property {number} UNUSED_NESTED_PUBKEY_HASH=3 UNUSED_NESTED_PUBKEY_HASH value
     */
    lnrpc.AddressType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WITNESS_PUBKEY_HASH"] = 0;
        values[valuesById[1] = "NESTED_PUBKEY_HASH"] = 1;
        values[valuesById[2] = "UNUSED_WITNESS_PUBKEY_HASH"] = 2;
        values[valuesById[3] = "UNUSED_NESTED_PUBKEY_HASH"] = 3;
        return values;
    })();

    lnrpc.NewAddressRequest = (function() {

        /**
         * Properties of a NewAddressRequest.
         * @memberof lnrpc
         * @interface INewAddressRequest
         * @property {lnrpc.AddressType|null} [type] NewAddressRequest type
         */

        /**
         * Constructs a new NewAddressRequest.
         * @memberof lnrpc
         * @classdesc Represents a NewAddressRequest.
         * @implements INewAddressRequest
         * @constructor
         * @param {lnrpc.INewAddressRequest=} [properties] Properties to set
         */
        function NewAddressRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewAddressRequest type.
         * @member {lnrpc.AddressType} type
         * @memberof lnrpc.NewAddressRequest
         * @instance
         */
        NewAddressRequest.prototype.type = 0;

        /**
         * Creates a new NewAddressRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest=} [properties] Properties to set
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest instance
         */
        NewAddressRequest.create = function create(properties) {
            return new NewAddressRequest(properties);
        };

        /**
         * Encodes the specified NewAddressRequest message. Does not implicitly {@link lnrpc.NewAddressRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest} message NewAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified NewAddressRequest message, length delimited. Does not implicitly {@link lnrpc.NewAddressRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest} message NewAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewAddressRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewAddressRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewAddressRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewAddressRequest message.
         * @function verify
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewAddressRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a NewAddressRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         */
        NewAddressRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewAddressRequest)
                return object;
            let message = new $root.lnrpc.NewAddressRequest();
            switch (object.type) {
            case "WITNESS_PUBKEY_HASH":
            case 0:
                message.type = 0;
                break;
            case "NESTED_PUBKEY_HASH":
            case 1:
                message.type = 1;
                break;
            case "UNUSED_WITNESS_PUBKEY_HASH":
            case 2:
                message.type = 2;
                break;
            case "UNUSED_NESTED_PUBKEY_HASH":
            case 3:
                message.type = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a NewAddressRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.NewAddressRequest} message NewAddressRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewAddressRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = options.enums === String ? "WITNESS_PUBKEY_HASH" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.AddressType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this NewAddressRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NewAddressRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewAddressRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewAddressRequest;
    })();

    lnrpc.NewAddressResponse = (function() {

        /**
         * Properties of a NewAddressResponse.
         * @memberof lnrpc
         * @interface INewAddressResponse
         * @property {string|null} [address] NewAddressResponse address
         */

        /**
         * Constructs a new NewAddressResponse.
         * @memberof lnrpc
         * @classdesc Represents a NewAddressResponse.
         * @implements INewAddressResponse
         * @constructor
         * @param {lnrpc.INewAddressResponse=} [properties] Properties to set
         */
        function NewAddressResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewAddressResponse address.
         * @member {string} address
         * @memberof lnrpc.NewAddressResponse
         * @instance
         */
        NewAddressResponse.prototype.address = "";

        /**
         * Creates a new NewAddressResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse=} [properties] Properties to set
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse instance
         */
        NewAddressResponse.create = function create(properties) {
            return new NewAddressResponse(properties);
        };

        /**
         * Encodes the specified NewAddressResponse message. Does not implicitly {@link lnrpc.NewAddressResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse} message NewAddressResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified NewAddressResponse message, length delimited. Does not implicitly {@link lnrpc.NewAddressResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse} message NewAddressResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewAddressResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewAddressResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewAddressResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewAddressResponse message.
         * @function verify
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewAddressResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a NewAddressResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         */
        NewAddressResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewAddressResponse)
                return object;
            let message = new $root.lnrpc.NewAddressResponse();
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a NewAddressResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.NewAddressResponse} message NewAddressResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewAddressResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.address = "";
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this NewAddressResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.NewAddressResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewAddressResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewAddressResponse;
    })();

    lnrpc.SignMessageRequest = (function() {

        /**
         * Properties of a SignMessageRequest.
         * @memberof lnrpc
         * @interface ISignMessageRequest
         * @property {Uint8Array|null} [msg] SignMessageRequest msg
         */

        /**
         * Constructs a new SignMessageRequest.
         * @memberof lnrpc
         * @classdesc Represents a SignMessageRequest.
         * @implements ISignMessageRequest
         * @constructor
         * @param {lnrpc.ISignMessageRequest=} [properties] Properties to set
         */
        function SignMessageRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignMessageRequest msg.
         * @member {Uint8Array} msg
         * @memberof lnrpc.SignMessageRequest
         * @instance
         */
        SignMessageRequest.prototype.msg = $util.newBuffer([]);

        /**
         * Creates a new SignMessageRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest=} [properties] Properties to set
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest instance
         */
        SignMessageRequest.create = function create(properties) {
            return new SignMessageRequest(properties);
        };

        /**
         * Encodes the specified SignMessageRequest message. Does not implicitly {@link lnrpc.SignMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest} message SignMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msg);
            return writer;
        };

        /**
         * Encodes the specified SignMessageRequest message, length delimited. Does not implicitly {@link lnrpc.SignMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest} message SignMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SignMessageRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignMessageRequest message.
         * @function verify
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            return null;
        };

        /**
         * Creates a SignMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         */
        SignMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SignMessageRequest)
                return object;
            let message = new $root.lnrpc.SignMessageRequest();
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            return message;
        };

        /**
         * Creates a plain object from a SignMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.SignMessageRequest} message SignMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            return object;
        };

        /**
         * Converts this SignMessageRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SignMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignMessageRequest;
    })();

    lnrpc.SignMessageResponse = (function() {

        /**
         * Properties of a SignMessageResponse.
         * @memberof lnrpc
         * @interface ISignMessageResponse
         * @property {string|null} [signature] SignMessageResponse signature
         */

        /**
         * Constructs a new SignMessageResponse.
         * @memberof lnrpc
         * @classdesc Represents a SignMessageResponse.
         * @implements ISignMessageResponse
         * @constructor
         * @param {lnrpc.ISignMessageResponse=} [properties] Properties to set
         */
        function SignMessageResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignMessageResponse signature.
         * @member {string} signature
         * @memberof lnrpc.SignMessageResponse
         * @instance
         */
        SignMessageResponse.prototype.signature = "";

        /**
         * Creates a new SignMessageResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse=} [properties] Properties to set
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse instance
         */
        SignMessageResponse.create = function create(properties) {
            return new SignMessageResponse(properties);
        };

        /**
         * Encodes the specified SignMessageResponse message. Does not implicitly {@link lnrpc.SignMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse} message SignMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified SignMessageResponse message, length delimited. Does not implicitly {@link lnrpc.SignMessageResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse} message SignMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SignMessageResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignMessageResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignMessageResponse message.
         * @function verify
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignMessageResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a SignMessageResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         */
        SignMessageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SignMessageResponse)
                return object;
            let message = new $root.lnrpc.SignMessageResponse();
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a SignMessageResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.SignMessageResponse} message SignMessageResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignMessageResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.signature = "";
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this SignMessageResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SignMessageResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignMessageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignMessageResponse;
    })();

    lnrpc.VerifyMessageRequest = (function() {

        /**
         * Properties of a VerifyMessageRequest.
         * @memberof lnrpc
         * @interface IVerifyMessageRequest
         * @property {Uint8Array|null} [msg] VerifyMessageRequest msg
         * @property {string|null} [signature] VerifyMessageRequest signature
         */

        /**
         * Constructs a new VerifyMessageRequest.
         * @memberof lnrpc
         * @classdesc Represents a VerifyMessageRequest.
         * @implements IVerifyMessageRequest
         * @constructor
         * @param {lnrpc.IVerifyMessageRequest=} [properties] Properties to set
         */
        function VerifyMessageRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyMessageRequest msg.
         * @member {Uint8Array} msg
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         */
        VerifyMessageRequest.prototype.msg = $util.newBuffer([]);

        /**
         * VerifyMessageRequest signature.
         * @member {string} signature
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         */
        VerifyMessageRequest.prototype.signature = "";

        /**
         * Creates a new VerifyMessageRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest=} [properties] Properties to set
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest instance
         */
        VerifyMessageRequest.create = function create(properties) {
            return new VerifyMessageRequest(properties);
        };

        /**
         * Encodes the specified VerifyMessageRequest message. Does not implicitly {@link lnrpc.VerifyMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest} message VerifyMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msg);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified VerifyMessageRequest message, length delimited. Does not implicitly {@link lnrpc.VerifyMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest} message VerifyMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyMessageRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyMessageRequest message.
         * @function verify
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a VerifyMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         */
        VerifyMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyMessageRequest)
                return object;
            let message = new $root.lnrpc.VerifyMessageRequest();
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a VerifyMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.VerifyMessageRequest} message VerifyMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
                object.signature = "";
            }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this VerifyMessageRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyMessageRequest;
    })();

    lnrpc.VerifyMessageResponse = (function() {

        /**
         * Properties of a VerifyMessageResponse.
         * @memberof lnrpc
         * @interface IVerifyMessageResponse
         * @property {boolean|null} [valid] VerifyMessageResponse valid
         * @property {string|null} [pubkey] VerifyMessageResponse pubkey
         */

        /**
         * Constructs a new VerifyMessageResponse.
         * @memberof lnrpc
         * @classdesc Represents a VerifyMessageResponse.
         * @implements IVerifyMessageResponse
         * @constructor
         * @param {lnrpc.IVerifyMessageResponse=} [properties] Properties to set
         */
        function VerifyMessageResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyMessageResponse valid.
         * @member {boolean} valid
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         */
        VerifyMessageResponse.prototype.valid = false;

        /**
         * VerifyMessageResponse pubkey.
         * @member {string} pubkey
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         */
        VerifyMessageResponse.prototype.pubkey = "";

        /**
         * Creates a new VerifyMessageResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse=} [properties] Properties to set
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse instance
         */
        VerifyMessageResponse.create = function create(properties) {
            return new VerifyMessageResponse(properties);
        };

        /**
         * Encodes the specified VerifyMessageResponse message. Does not implicitly {@link lnrpc.VerifyMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse} message VerifyMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.valid != null && Object.hasOwnProperty.call(message, "valid"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.valid);
            if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pubkey);
            return writer;
        };

        /**
         * Encodes the specified VerifyMessageResponse message, length delimited. Does not implicitly {@link lnrpc.VerifyMessageResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse} message VerifyMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyMessageResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.valid = reader.bool();
                    break;
                case 2:
                    message.pubkey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyMessageResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyMessageResponse message.
         * @function verify
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyMessageResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.valid != null && message.hasOwnProperty("valid"))
                if (typeof message.valid !== "boolean")
                    return "valid: boolean expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!$util.isString(message.pubkey))
                    return "pubkey: string expected";
            return null;
        };

        /**
         * Creates a VerifyMessageResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         */
        VerifyMessageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyMessageResponse)
                return object;
            let message = new $root.lnrpc.VerifyMessageResponse();
            if (object.valid != null)
                message.valid = Boolean(object.valid);
            if (object.pubkey != null)
                message.pubkey = String(object.pubkey);
            return message;
        };

        /**
         * Creates a plain object from a VerifyMessageResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.VerifyMessageResponse} message VerifyMessageResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyMessageResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.valid = false;
                object.pubkey = "";
            }
            if (message.valid != null && message.hasOwnProperty("valid"))
                object.valid = message.valid;
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = message.pubkey;
            return object;
        };

        /**
         * Converts this VerifyMessageResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyMessageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyMessageResponse;
    })();

    lnrpc.ConnectPeerRequest = (function() {

        /**
         * Properties of a ConnectPeerRequest.
         * @memberof lnrpc
         * @interface IConnectPeerRequest
         * @property {lnrpc.ILightningAddress|null} [addr] ConnectPeerRequest addr
         * @property {boolean|null} [perm] ConnectPeerRequest perm
         * @property {number|Long|null} [timeout] ConnectPeerRequest timeout
         */

        /**
         * Constructs a new ConnectPeerRequest.
         * @memberof lnrpc
         * @classdesc Represents a ConnectPeerRequest.
         * @implements IConnectPeerRequest
         * @constructor
         * @param {lnrpc.IConnectPeerRequest=} [properties] Properties to set
         */
        function ConnectPeerRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectPeerRequest addr.
         * @member {lnrpc.ILightningAddress|null|undefined} addr
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.addr = null;

        /**
         * ConnectPeerRequest perm.
         * @member {boolean} perm
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.perm = false;

        /**
         * ConnectPeerRequest timeout.
         * @member {number|Long} timeout
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ConnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest=} [properties] Properties to set
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest instance
         */
        ConnectPeerRequest.create = function create(properties) {
            return new ConnectPeerRequest(properties);
        };

        /**
         * Encodes the specified ConnectPeerRequest message. Does not implicitly {@link lnrpc.ConnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && Object.hasOwnProperty.call(message, "addr"))
                $root.lnrpc.LightningAddress.encode(message.addr, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.perm != null && Object.hasOwnProperty.call(message, "perm"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.perm);
            if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeout);
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerRequest message, length delimited. Does not implicitly {@link lnrpc.ConnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConnectPeerRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = $root.lnrpc.LightningAddress.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.perm = reader.bool();
                    break;
                case 3:
                    message.timeout = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerRequest message.
         * @function verify
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr")) {
                let error = $root.lnrpc.LightningAddress.verify(message.addr);
                if (error)
                    return "addr." + error;
            }
            if (message.perm != null && message.hasOwnProperty("perm"))
                if (typeof message.perm !== "boolean")
                    return "perm: boolean expected";
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            return null;
        };

        /**
         * Creates a ConnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         */
        ConnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConnectPeerRequest)
                return object;
            let message = new $root.lnrpc.ConnectPeerRequest();
            if (object.addr != null) {
                if (typeof object.addr !== "object")
                    throw TypeError(".lnrpc.ConnectPeerRequest.addr: object expected");
                message.addr = $root.lnrpc.LightningAddress.fromObject(object.addr);
            }
            if (object.perm != null)
                message.perm = Boolean(object.perm);
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = true;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ConnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.ConnectPeerRequest} message ConnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addr = null;
                object.perm = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = $root.lnrpc.LightningAddress.toObject(message.addr, options);
            if (message.perm != null && message.hasOwnProperty("perm"))
                object.perm = message.perm;
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber(true) : message.timeout;
            return object;
        };

        /**
         * Converts this ConnectPeerRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectPeerRequest;
    })();

    lnrpc.ConnectPeerResponse = (function() {

        /**
         * Properties of a ConnectPeerResponse.
         * @memberof lnrpc
         * @interface IConnectPeerResponse
         */

        /**
         * Constructs a new ConnectPeerResponse.
         * @memberof lnrpc
         * @classdesc Represents a ConnectPeerResponse.
         * @implements IConnectPeerResponse
         * @constructor
         * @param {lnrpc.IConnectPeerResponse=} [properties] Properties to set
         */
        function ConnectPeerResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ConnectPeerResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse=} [properties] Properties to set
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse instance
         */
        ConnectPeerResponse.create = function create(properties) {
            return new ConnectPeerResponse(properties);
        };

        /**
         * Encodes the specified ConnectPeerResponse message. Does not implicitly {@link lnrpc.ConnectPeerResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse} message ConnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerResponse message, length delimited. Does not implicitly {@link lnrpc.ConnectPeerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse} message ConnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConnectPeerResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerResponse message.
         * @function verify
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ConnectPeerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         */
        ConnectPeerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConnectPeerResponse)
                return object;
            return new $root.lnrpc.ConnectPeerResponse();
        };

        /**
         * Creates a plain object from a ConnectPeerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.ConnectPeerResponse} message ConnectPeerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ConnectPeerResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ConnectPeerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectPeerResponse;
    })();

    lnrpc.DisconnectPeerRequest = (function() {

        /**
         * Properties of a DisconnectPeerRequest.
         * @memberof lnrpc
         * @interface IDisconnectPeerRequest
         * @property {string|null} [pubKey] DisconnectPeerRequest pubKey
         */

        /**
         * Constructs a new DisconnectPeerRequest.
         * @memberof lnrpc
         * @classdesc Represents a DisconnectPeerRequest.
         * @implements IDisconnectPeerRequest
         * @constructor
         * @param {lnrpc.IDisconnectPeerRequest=} [properties] Properties to set
         */
        function DisconnectPeerRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DisconnectPeerRequest pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.DisconnectPeerRequest
         * @instance
         */
        DisconnectPeerRequest.prototype.pubKey = "";

        /**
         * Creates a new DisconnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest=} [properties] Properties to set
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest instance
         */
        DisconnectPeerRequest.create = function create(properties) {
            return new DisconnectPeerRequest(properties);
        };

        /**
         * Encodes the specified DisconnectPeerRequest message. Does not implicitly {@link lnrpc.DisconnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest} message DisconnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            return writer;
        };

        /**
         * Encodes the specified DisconnectPeerRequest message, length delimited. Does not implicitly {@link lnrpc.DisconnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest} message DisconnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DisconnectPeerRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectPeerRequest message.
         * @function verify
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            return null;
        };

        /**
         * Creates a DisconnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         */
        DisconnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DisconnectPeerRequest)
                return object;
            let message = new $root.lnrpc.DisconnectPeerRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            return message;
        };

        /**
         * Creates a plain object from a DisconnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.DisconnectPeerRequest} message DisconnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.pubKey = "";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            return object;
        };

        /**
         * Converts this DisconnectPeerRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DisconnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectPeerRequest;
    })();

    lnrpc.DisconnectPeerResponse = (function() {

        /**
         * Properties of a DisconnectPeerResponse.
         * @memberof lnrpc
         * @interface IDisconnectPeerResponse
         */

        /**
         * Constructs a new DisconnectPeerResponse.
         * @memberof lnrpc
         * @classdesc Represents a DisconnectPeerResponse.
         * @implements IDisconnectPeerResponse
         * @constructor
         * @param {lnrpc.IDisconnectPeerResponse=} [properties] Properties to set
         */
        function DisconnectPeerResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DisconnectPeerResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse=} [properties] Properties to set
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse instance
         */
        DisconnectPeerResponse.create = function create(properties) {
            return new DisconnectPeerResponse(properties);
        };

        /**
         * Encodes the specified DisconnectPeerResponse message. Does not implicitly {@link lnrpc.DisconnectPeerResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse} message DisconnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DisconnectPeerResponse message, length delimited. Does not implicitly {@link lnrpc.DisconnectPeerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse} message DisconnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectPeerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DisconnectPeerResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectPeerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectPeerResponse message.
         * @function verify
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectPeerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DisconnectPeerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         */
        DisconnectPeerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DisconnectPeerResponse)
                return object;
            return new $root.lnrpc.DisconnectPeerResponse();
        };

        /**
         * Creates a plain object from a DisconnectPeerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.DisconnectPeerResponse} message DisconnectPeerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectPeerResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DisconnectPeerResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DisconnectPeerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectPeerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectPeerResponse;
    })();

    lnrpc.HTLC = (function() {

        /**
         * Properties of a HTLC.
         * @memberof lnrpc
         * @interface IHTLC
         * @property {boolean|null} [incoming] HTLC incoming
         * @property {number|Long|null} [amount] HTLC amount
         * @property {Uint8Array|null} [hashLock] HTLC hashLock
         * @property {number|null} [expirationHeight] HTLC expirationHeight
         * @property {number|Long|null} [htlcIndex] HTLC htlcIndex
         * @property {number|Long|null} [forwardingChannel] HTLC forwardingChannel
         * @property {number|Long|null} [forwardingHtlcIndex] HTLC forwardingHtlcIndex
         */

        /**
         * Constructs a new HTLC.
         * @memberof lnrpc
         * @classdesc Represents a HTLC.
         * @implements IHTLC
         * @constructor
         * @param {lnrpc.IHTLC=} [properties] Properties to set
         */
        function HTLC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HTLC incoming.
         * @member {boolean} incoming
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.incoming = false;

        /**
         * HTLC amount.
         * @member {number|Long} amount
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HTLC hashLock.
         * @member {Uint8Array} hashLock
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.hashLock = $util.newBuffer([]);

        /**
         * HTLC expirationHeight.
         * @member {number} expirationHeight
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.expirationHeight = 0;

        /**
         * HTLC htlcIndex.
         * @member {number|Long} htlcIndex
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.htlcIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HTLC forwardingChannel.
         * @member {number|Long} forwardingChannel
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.forwardingChannel = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HTLC forwardingHtlcIndex.
         * @member {number|Long} forwardingHtlcIndex
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.forwardingHtlcIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC=} [properties] Properties to set
         * @returns {lnrpc.HTLC} HTLC instance
         */
        HTLC.create = function create(properties) {
            return new HTLC(properties);
        };

        /**
         * Encodes the specified HTLC message. Does not implicitly {@link lnrpc.HTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC} message HTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incoming != null && Object.hasOwnProperty.call(message, "incoming"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.incoming);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.hashLock != null && Object.hasOwnProperty.call(message, "hashLock"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hashLock);
            if (message.expirationHeight != null && Object.hasOwnProperty.call(message, "expirationHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expirationHeight);
            if (message.htlcIndex != null && Object.hasOwnProperty.call(message, "htlcIndex"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.htlcIndex);
            if (message.forwardingChannel != null && Object.hasOwnProperty.call(message, "forwardingChannel"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.forwardingChannel);
            if (message.forwardingHtlcIndex != null && Object.hasOwnProperty.call(message, "forwardingHtlcIndex"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.forwardingHtlcIndex);
            return writer;
        };

        /**
         * Encodes the specified HTLC message, length delimited. Does not implicitly {@link lnrpc.HTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC} message HTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HTLC} HTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HTLC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incoming = reader.bool();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.hashLock = reader.bytes();
                    break;
                case 4:
                    message.expirationHeight = reader.uint32();
                    break;
                case 5:
                    message.htlcIndex = reader.uint64();
                    break;
                case 6:
                    message.forwardingChannel = reader.uint64();
                    break;
                case 7:
                    message.forwardingHtlcIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HTLC} HTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HTLC message.
         * @function verify
         * @memberof lnrpc.HTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                if (typeof message.incoming !== "boolean")
                    return "incoming: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                if (!(message.hashLock && typeof message.hashLock.length === "number" || $util.isString(message.hashLock)))
                    return "hashLock: buffer expected";
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                if (!$util.isInteger(message.expirationHeight))
                    return "expirationHeight: integer expected";
            if (message.htlcIndex != null && message.hasOwnProperty("htlcIndex"))
                if (!$util.isInteger(message.htlcIndex) && !(message.htlcIndex && $util.isInteger(message.htlcIndex.low) && $util.isInteger(message.htlcIndex.high)))
                    return "htlcIndex: integer|Long expected";
            if (message.forwardingChannel != null && message.hasOwnProperty("forwardingChannel"))
                if (!$util.isInteger(message.forwardingChannel) && !(message.forwardingChannel && $util.isInteger(message.forwardingChannel.low) && $util.isInteger(message.forwardingChannel.high)))
                    return "forwardingChannel: integer|Long expected";
            if (message.forwardingHtlcIndex != null && message.hasOwnProperty("forwardingHtlcIndex"))
                if (!$util.isInteger(message.forwardingHtlcIndex) && !(message.forwardingHtlcIndex && $util.isInteger(message.forwardingHtlcIndex.low) && $util.isInteger(message.forwardingHtlcIndex.high)))
                    return "forwardingHtlcIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates a HTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HTLC} HTLC
         */
        HTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HTLC)
                return object;
            let message = new $root.lnrpc.HTLC();
            if (object.incoming != null)
                message.incoming = Boolean(object.incoming);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.hashLock != null)
                if (typeof object.hashLock === "string")
                    $util.base64.decode(object.hashLock, message.hashLock = $util.newBuffer($util.base64.length(object.hashLock)), 0);
                else if (object.hashLock.length)
                    message.hashLock = object.hashLock;
            if (object.expirationHeight != null)
                message.expirationHeight = object.expirationHeight >>> 0;
            if (object.htlcIndex != null)
                if ($util.Long)
                    (message.htlcIndex = $util.Long.fromValue(object.htlcIndex)).unsigned = true;
                else if (typeof object.htlcIndex === "string")
                    message.htlcIndex = parseInt(object.htlcIndex, 10);
                else if (typeof object.htlcIndex === "number")
                    message.htlcIndex = object.htlcIndex;
                else if (typeof object.htlcIndex === "object")
                    message.htlcIndex = new $util.LongBits(object.htlcIndex.low >>> 0, object.htlcIndex.high >>> 0).toNumber(true);
            if (object.forwardingChannel != null)
                if ($util.Long)
                    (message.forwardingChannel = $util.Long.fromValue(object.forwardingChannel)).unsigned = true;
                else if (typeof object.forwardingChannel === "string")
                    message.forwardingChannel = parseInt(object.forwardingChannel, 10);
                else if (typeof object.forwardingChannel === "number")
                    message.forwardingChannel = object.forwardingChannel;
                else if (typeof object.forwardingChannel === "object")
                    message.forwardingChannel = new $util.LongBits(object.forwardingChannel.low >>> 0, object.forwardingChannel.high >>> 0).toNumber(true);
            if (object.forwardingHtlcIndex != null)
                if ($util.Long)
                    (message.forwardingHtlcIndex = $util.Long.fromValue(object.forwardingHtlcIndex)).unsigned = true;
                else if (typeof object.forwardingHtlcIndex === "string")
                    message.forwardingHtlcIndex = parseInt(object.forwardingHtlcIndex, 10);
                else if (typeof object.forwardingHtlcIndex === "number")
                    message.forwardingHtlcIndex = object.forwardingHtlcIndex;
                else if (typeof object.forwardingHtlcIndex === "object")
                    message.forwardingHtlcIndex = new $util.LongBits(object.forwardingHtlcIndex.low >>> 0, object.forwardingHtlcIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a HTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.HTLC} message HTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.incoming = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hashLock = "";
                else {
                    object.hashLock = [];
                    if (options.bytes !== Array)
                        object.hashLock = $util.newBuffer(object.hashLock);
                }
                object.expirationHeight = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.htlcIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.htlcIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.forwardingChannel = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.forwardingChannel = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.forwardingHtlcIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.forwardingHtlcIndex = options.longs === String ? "0" : 0;
            }
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                object.incoming = message.incoming;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                object.hashLock = options.bytes === String ? $util.base64.encode(message.hashLock, 0, message.hashLock.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashLock) : message.hashLock;
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                object.expirationHeight = message.expirationHeight;
            if (message.htlcIndex != null && message.hasOwnProperty("htlcIndex"))
                if (typeof message.htlcIndex === "number")
                    object.htlcIndex = options.longs === String ? String(message.htlcIndex) : message.htlcIndex;
                else
                    object.htlcIndex = options.longs === String ? $util.Long.prototype.toString.call(message.htlcIndex) : options.longs === Number ? new $util.LongBits(message.htlcIndex.low >>> 0, message.htlcIndex.high >>> 0).toNumber(true) : message.htlcIndex;
            if (message.forwardingChannel != null && message.hasOwnProperty("forwardingChannel"))
                if (typeof message.forwardingChannel === "number")
                    object.forwardingChannel = options.longs === String ? String(message.forwardingChannel) : message.forwardingChannel;
                else
                    object.forwardingChannel = options.longs === String ? $util.Long.prototype.toString.call(message.forwardingChannel) : options.longs === Number ? new $util.LongBits(message.forwardingChannel.low >>> 0, message.forwardingChannel.high >>> 0).toNumber(true) : message.forwardingChannel;
            if (message.forwardingHtlcIndex != null && message.hasOwnProperty("forwardingHtlcIndex"))
                if (typeof message.forwardingHtlcIndex === "number")
                    object.forwardingHtlcIndex = options.longs === String ? String(message.forwardingHtlcIndex) : message.forwardingHtlcIndex;
                else
                    object.forwardingHtlcIndex = options.longs === String ? $util.Long.prototype.toString.call(message.forwardingHtlcIndex) : options.longs === Number ? new $util.LongBits(message.forwardingHtlcIndex.low >>> 0, message.forwardingHtlcIndex.high >>> 0).toNumber(true) : message.forwardingHtlcIndex;
            return object;
        };

        /**
         * Converts this HTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.HTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HTLC;
    })();

    /**
     * CommitmentType enum.
     * @name lnrpc.CommitmentType
     * @enum {number}
     * @property {number} LEGACY=0 LEGACY value
     * @property {number} STATIC_REMOTE_KEY=1 STATIC_REMOTE_KEY value
     * @property {number} ANCHORS=2 ANCHORS value
     * @property {number} UNKNOWN_COMMITMENT_TYPE=999 UNKNOWN_COMMITMENT_TYPE value
     */
    lnrpc.CommitmentType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LEGACY"] = 0;
        values[valuesById[1] = "STATIC_REMOTE_KEY"] = 1;
        values[valuesById[2] = "ANCHORS"] = 2;
        values[valuesById[999] = "UNKNOWN_COMMITMENT_TYPE"] = 999;
        return values;
    })();

    lnrpc.ChannelConstraints = (function() {

        /**
         * Properties of a ChannelConstraints.
         * @memberof lnrpc
         * @interface IChannelConstraints
         * @property {number|null} [csvDelay] ChannelConstraints csvDelay
         * @property {number|Long|null} [chanReserveSat] ChannelConstraints chanReserveSat
         * @property {number|Long|null} [dustLimitSat] ChannelConstraints dustLimitSat
         * @property {number|Long|null} [maxPendingAmtMsat] ChannelConstraints maxPendingAmtMsat
         * @property {number|Long|null} [minHtlcMsat] ChannelConstraints minHtlcMsat
         * @property {number|null} [maxAcceptedHtlcs] ChannelConstraints maxAcceptedHtlcs
         */

        /**
         * Constructs a new ChannelConstraints.
         * @memberof lnrpc
         * @classdesc Represents a ChannelConstraints.
         * @implements IChannelConstraints
         * @constructor
         * @param {lnrpc.IChannelConstraints=} [properties] Properties to set
         */
        function ChannelConstraints(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelConstraints csvDelay.
         * @member {number} csvDelay
         * @memberof lnrpc.ChannelConstraints
         * @instance
         */
        ChannelConstraints.prototype.csvDelay = 0;

        /**
         * ChannelConstraints chanReserveSat.
         * @member {number|Long} chanReserveSat
         * @memberof lnrpc.ChannelConstraints
         * @instance
         */
        ChannelConstraints.prototype.chanReserveSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelConstraints dustLimitSat.
         * @member {number|Long} dustLimitSat
         * @memberof lnrpc.ChannelConstraints
         * @instance
         */
        ChannelConstraints.prototype.dustLimitSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelConstraints maxPendingAmtMsat.
         * @member {number|Long} maxPendingAmtMsat
         * @memberof lnrpc.ChannelConstraints
         * @instance
         */
        ChannelConstraints.prototype.maxPendingAmtMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelConstraints minHtlcMsat.
         * @member {number|Long} minHtlcMsat
         * @memberof lnrpc.ChannelConstraints
         * @instance
         */
        ChannelConstraints.prototype.minHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelConstraints maxAcceptedHtlcs.
         * @member {number} maxAcceptedHtlcs
         * @memberof lnrpc.ChannelConstraints
         * @instance
         */
        ChannelConstraints.prototype.maxAcceptedHtlcs = 0;

        /**
         * Creates a new ChannelConstraints instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {lnrpc.IChannelConstraints=} [properties] Properties to set
         * @returns {lnrpc.ChannelConstraints} ChannelConstraints instance
         */
        ChannelConstraints.create = function create(properties) {
            return new ChannelConstraints(properties);
        };

        /**
         * Encodes the specified ChannelConstraints message. Does not implicitly {@link lnrpc.ChannelConstraints.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {lnrpc.IChannelConstraints} message ChannelConstraints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelConstraints.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.csvDelay != null && Object.hasOwnProperty.call(message, "csvDelay"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.csvDelay);
            if (message.chanReserveSat != null && Object.hasOwnProperty.call(message, "chanReserveSat"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanReserveSat);
            if (message.dustLimitSat != null && Object.hasOwnProperty.call(message, "dustLimitSat"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.dustLimitSat);
            if (message.maxPendingAmtMsat != null && Object.hasOwnProperty.call(message, "maxPendingAmtMsat"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxPendingAmtMsat);
            if (message.minHtlcMsat != null && Object.hasOwnProperty.call(message, "minHtlcMsat"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.minHtlcMsat);
            if (message.maxAcceptedHtlcs != null && Object.hasOwnProperty.call(message, "maxAcceptedHtlcs"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.maxAcceptedHtlcs);
            return writer;
        };

        /**
         * Encodes the specified ChannelConstraints message, length delimited. Does not implicitly {@link lnrpc.ChannelConstraints.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {lnrpc.IChannelConstraints} message ChannelConstraints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelConstraints.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelConstraints message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelConstraints} ChannelConstraints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelConstraints.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelConstraints();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.csvDelay = reader.uint32();
                    break;
                case 2:
                    message.chanReserveSat = reader.uint64();
                    break;
                case 3:
                    message.dustLimitSat = reader.uint64();
                    break;
                case 4:
                    message.maxPendingAmtMsat = reader.uint64();
                    break;
                case 5:
                    message.minHtlcMsat = reader.uint64();
                    break;
                case 6:
                    message.maxAcceptedHtlcs = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelConstraints message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelConstraints} ChannelConstraints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelConstraints.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelConstraints message.
         * @function verify
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelConstraints.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                if (!$util.isInteger(message.csvDelay))
                    return "csvDelay: integer expected";
            if (message.chanReserveSat != null && message.hasOwnProperty("chanReserveSat"))
                if (!$util.isInteger(message.chanReserveSat) && !(message.chanReserveSat && $util.isInteger(message.chanReserveSat.low) && $util.isInteger(message.chanReserveSat.high)))
                    return "chanReserveSat: integer|Long expected";
            if (message.dustLimitSat != null && message.hasOwnProperty("dustLimitSat"))
                if (!$util.isInteger(message.dustLimitSat) && !(message.dustLimitSat && $util.isInteger(message.dustLimitSat.low) && $util.isInteger(message.dustLimitSat.high)))
                    return "dustLimitSat: integer|Long expected";
            if (message.maxPendingAmtMsat != null && message.hasOwnProperty("maxPendingAmtMsat"))
                if (!$util.isInteger(message.maxPendingAmtMsat) && !(message.maxPendingAmtMsat && $util.isInteger(message.maxPendingAmtMsat.low) && $util.isInteger(message.maxPendingAmtMsat.high)))
                    return "maxPendingAmtMsat: integer|Long expected";
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (!$util.isInteger(message.minHtlcMsat) && !(message.minHtlcMsat && $util.isInteger(message.minHtlcMsat.low) && $util.isInteger(message.minHtlcMsat.high)))
                    return "minHtlcMsat: integer|Long expected";
            if (message.maxAcceptedHtlcs != null && message.hasOwnProperty("maxAcceptedHtlcs"))
                if (!$util.isInteger(message.maxAcceptedHtlcs))
                    return "maxAcceptedHtlcs: integer expected";
            return null;
        };

        /**
         * Creates a ChannelConstraints message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelConstraints} ChannelConstraints
         */
        ChannelConstraints.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelConstraints)
                return object;
            let message = new $root.lnrpc.ChannelConstraints();
            if (object.csvDelay != null)
                message.csvDelay = object.csvDelay >>> 0;
            if (object.chanReserveSat != null)
                if ($util.Long)
                    (message.chanReserveSat = $util.Long.fromValue(object.chanReserveSat)).unsigned = true;
                else if (typeof object.chanReserveSat === "string")
                    message.chanReserveSat = parseInt(object.chanReserveSat, 10);
                else if (typeof object.chanReserveSat === "number")
                    message.chanReserveSat = object.chanReserveSat;
                else if (typeof object.chanReserveSat === "object")
                    message.chanReserveSat = new $util.LongBits(object.chanReserveSat.low >>> 0, object.chanReserveSat.high >>> 0).toNumber(true);
            if (object.dustLimitSat != null)
                if ($util.Long)
                    (message.dustLimitSat = $util.Long.fromValue(object.dustLimitSat)).unsigned = true;
                else if (typeof object.dustLimitSat === "string")
                    message.dustLimitSat = parseInt(object.dustLimitSat, 10);
                else if (typeof object.dustLimitSat === "number")
                    message.dustLimitSat = object.dustLimitSat;
                else if (typeof object.dustLimitSat === "object")
                    message.dustLimitSat = new $util.LongBits(object.dustLimitSat.low >>> 0, object.dustLimitSat.high >>> 0).toNumber(true);
            if (object.maxPendingAmtMsat != null)
                if ($util.Long)
                    (message.maxPendingAmtMsat = $util.Long.fromValue(object.maxPendingAmtMsat)).unsigned = true;
                else if (typeof object.maxPendingAmtMsat === "string")
                    message.maxPendingAmtMsat = parseInt(object.maxPendingAmtMsat, 10);
                else if (typeof object.maxPendingAmtMsat === "number")
                    message.maxPendingAmtMsat = object.maxPendingAmtMsat;
                else if (typeof object.maxPendingAmtMsat === "object")
                    message.maxPendingAmtMsat = new $util.LongBits(object.maxPendingAmtMsat.low >>> 0, object.maxPendingAmtMsat.high >>> 0).toNumber(true);
            if (object.minHtlcMsat != null)
                if ($util.Long)
                    (message.minHtlcMsat = $util.Long.fromValue(object.minHtlcMsat)).unsigned = true;
                else if (typeof object.minHtlcMsat === "string")
                    message.minHtlcMsat = parseInt(object.minHtlcMsat, 10);
                else if (typeof object.minHtlcMsat === "number")
                    message.minHtlcMsat = object.minHtlcMsat;
                else if (typeof object.minHtlcMsat === "object")
                    message.minHtlcMsat = new $util.LongBits(object.minHtlcMsat.low >>> 0, object.minHtlcMsat.high >>> 0).toNumber(true);
            if (object.maxAcceptedHtlcs != null)
                message.maxAcceptedHtlcs = object.maxAcceptedHtlcs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChannelConstraints message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelConstraints
         * @static
         * @param {lnrpc.ChannelConstraints} message ChannelConstraints
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelConstraints.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.csvDelay = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanReserveSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.dustLimitSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dustLimitSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxPendingAmtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxPendingAmtMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlcMsat = options.longs === String ? "0" : 0;
                object.maxAcceptedHtlcs = 0;
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                object.csvDelay = message.csvDelay;
            if (message.chanReserveSat != null && message.hasOwnProperty("chanReserveSat"))
                if (typeof message.chanReserveSat === "number")
                    object.chanReserveSat = options.longs === String ? String(message.chanReserveSat) : message.chanReserveSat;
                else
                    object.chanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.chanReserveSat) : options.longs === Number ? new $util.LongBits(message.chanReserveSat.low >>> 0, message.chanReserveSat.high >>> 0).toNumber(true) : message.chanReserveSat;
            if (message.dustLimitSat != null && message.hasOwnProperty("dustLimitSat"))
                if (typeof message.dustLimitSat === "number")
                    object.dustLimitSat = options.longs === String ? String(message.dustLimitSat) : message.dustLimitSat;
                else
                    object.dustLimitSat = options.longs === String ? $util.Long.prototype.toString.call(message.dustLimitSat) : options.longs === Number ? new $util.LongBits(message.dustLimitSat.low >>> 0, message.dustLimitSat.high >>> 0).toNumber(true) : message.dustLimitSat;
            if (message.maxPendingAmtMsat != null && message.hasOwnProperty("maxPendingAmtMsat"))
                if (typeof message.maxPendingAmtMsat === "number")
                    object.maxPendingAmtMsat = options.longs === String ? String(message.maxPendingAmtMsat) : message.maxPendingAmtMsat;
                else
                    object.maxPendingAmtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.maxPendingAmtMsat) : options.longs === Number ? new $util.LongBits(message.maxPendingAmtMsat.low >>> 0, message.maxPendingAmtMsat.high >>> 0).toNumber(true) : message.maxPendingAmtMsat;
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (typeof message.minHtlcMsat === "number")
                    object.minHtlcMsat = options.longs === String ? String(message.minHtlcMsat) : message.minHtlcMsat;
                else
                    object.minHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlcMsat) : options.longs === Number ? new $util.LongBits(message.minHtlcMsat.low >>> 0, message.minHtlcMsat.high >>> 0).toNumber(true) : message.minHtlcMsat;
            if (message.maxAcceptedHtlcs != null && message.hasOwnProperty("maxAcceptedHtlcs"))
                object.maxAcceptedHtlcs = message.maxAcceptedHtlcs;
            return object;
        };

        /**
         * Converts this ChannelConstraints to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelConstraints
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelConstraints.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelConstraints;
    })();

    lnrpc.Channel = (function() {

        /**
         * Properties of a Channel.
         * @memberof lnrpc
         * @interface IChannel
         * @property {boolean|null} [active] Channel active
         * @property {string|null} [remotePubkey] Channel remotePubkey
         * @property {string|null} [channelPoint] Channel channelPoint
         * @property {number|Long|null} [chanId] Channel chanId
         * @property {number|Long|null} [capacity] Channel capacity
         * @property {number|Long|null} [localBalance] Channel localBalance
         * @property {number|Long|null} [remoteBalance] Channel remoteBalance
         * @property {number|Long|null} [commitFee] Channel commitFee
         * @property {number|Long|null} [commitWeight] Channel commitWeight
         * @property {number|Long|null} [feePerKw] Channel feePerKw
         * @property {number|Long|null} [unsettledBalance] Channel unsettledBalance
         * @property {number|Long|null} [totalSatoshisSent] Channel totalSatoshisSent
         * @property {number|Long|null} [totalSatoshisReceived] Channel totalSatoshisReceived
         * @property {number|Long|null} [numUpdates] Channel numUpdates
         * @property {Array.<lnrpc.IHTLC>|null} [pendingHtlcs] Channel pendingHtlcs
         * @property {number|null} [csvDelay] Channel csvDelay
         * @property {boolean|null} ["private"] Channel private
         * @property {boolean|null} [initiator] Channel initiator
         * @property {string|null} [chanStatusFlags] Channel chanStatusFlags
         * @property {number|Long|null} [localChanReserveSat] Channel localChanReserveSat
         * @property {number|Long|null} [remoteChanReserveSat] Channel remoteChanReserveSat
         * @property {boolean|null} [staticRemoteKey] Channel staticRemoteKey
         * @property {lnrpc.CommitmentType|null} [commitmentType] Channel commitmentType
         * @property {number|Long|null} [lifetime] Channel lifetime
         * @property {number|Long|null} [uptime] Channel uptime
         * @property {string|null} [closeAddress] Channel closeAddress
         * @property {number|Long|null} [pushAmountSat] Channel pushAmountSat
         * @property {number|null} [thawHeight] Channel thawHeight
         * @property {lnrpc.IChannelConstraints|null} [localConstraints] Channel localConstraints
         * @property {lnrpc.IChannelConstraints|null} [remoteConstraints] Channel remoteConstraints
         */

        /**
         * Constructs a new Channel.
         * @memberof lnrpc
         * @classdesc Represents a Channel.
         * @implements IChannel
         * @constructor
         * @param {lnrpc.IChannel=} [properties] Properties to set
         */
        function Channel(properties) {
            this.pendingHtlcs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Channel active.
         * @member {boolean} active
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.active = false;

        /**
         * Channel remotePubkey.
         * @member {string} remotePubkey
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remotePubkey = "";

        /**
         * Channel channelPoint.
         * @member {string} channelPoint
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.channelPoint = "";

        /**
         * Channel chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Channel capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel localBalance.
         * @member {number|Long} localBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.localBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel remoteBalance.
         * @member {number|Long} remoteBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remoteBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel commitFee.
         * @member {number|Long} commitFee
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel commitWeight.
         * @member {number|Long} commitWeight
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitWeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel feePerKw.
         * @member {number|Long} feePerKw
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel unsettledBalance.
         * @member {number|Long} unsettledBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.unsettledBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel totalSatoshisSent.
         * @member {number|Long} totalSatoshisSent
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.totalSatoshisSent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel totalSatoshisReceived.
         * @member {number|Long} totalSatoshisReceived
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.totalSatoshisReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel numUpdates.
         * @member {number|Long} numUpdates
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.numUpdates = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Channel pendingHtlcs.
         * @member {Array.<lnrpc.IHTLC>} pendingHtlcs
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.pendingHtlcs = $util.emptyArray;

        /**
         * Channel csvDelay.
         * @member {number} csvDelay
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.csvDelay = 0;

        /**
         * Channel private.
         * @member {boolean} private
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype["private"] = false;

        /**
         * Channel initiator.
         * @member {boolean} initiator
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.initiator = false;

        /**
         * Channel chanStatusFlags.
         * @member {string} chanStatusFlags
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.chanStatusFlags = "";

        /**
         * Channel localChanReserveSat.
         * @member {number|Long} localChanReserveSat
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.localChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel remoteChanReserveSat.
         * @member {number|Long} remoteChanReserveSat
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remoteChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel staticRemoteKey.
         * @member {boolean} staticRemoteKey
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.staticRemoteKey = false;

        /**
         * Channel commitmentType.
         * @member {lnrpc.CommitmentType} commitmentType
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitmentType = 0;

        /**
         * Channel lifetime.
         * @member {number|Long} lifetime
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.lifetime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel uptime.
         * @member {number|Long} uptime
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.uptime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channel closeAddress.
         * @member {string} closeAddress
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.closeAddress = "";

        /**
         * Channel pushAmountSat.
         * @member {number|Long} pushAmountSat
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.pushAmountSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Channel thawHeight.
         * @member {number} thawHeight
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.thawHeight = 0;

        /**
         * Channel localConstraints.
         * @member {lnrpc.IChannelConstraints|null|undefined} localConstraints
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.localConstraints = null;

        /**
         * Channel remoteConstraints.
         * @member {lnrpc.IChannelConstraints|null|undefined} remoteConstraints
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remoteConstraints = null;

        /**
         * Creates a new Channel instance using the specified properties.
         * @function create
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel=} [properties] Properties to set
         * @returns {lnrpc.Channel} Channel instance
         */
        Channel.create = function create(properties) {
            return new Channel(properties);
        };

        /**
         * Encodes the specified Channel message. Does not implicitly {@link lnrpc.Channel.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.active);
            if (message.remotePubkey != null && Object.hasOwnProperty.call(message, "remotePubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.remotePubkey);
            if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelPoint);
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.chanId);
            if (message.capacity != null && Object.hasOwnProperty.call(message, "capacity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.capacity);
            if (message.localBalance != null && Object.hasOwnProperty.call(message, "localBalance"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.localBalance);
            if (message.remoteBalance != null && Object.hasOwnProperty.call(message, "remoteBalance"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.remoteBalance);
            if (message.commitFee != null && Object.hasOwnProperty.call(message, "commitFee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.commitFee);
            if (message.commitWeight != null && Object.hasOwnProperty.call(message, "commitWeight"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.commitWeight);
            if (message.feePerKw != null && Object.hasOwnProperty.call(message, "feePerKw"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.feePerKw);
            if (message.unsettledBalance != null && Object.hasOwnProperty.call(message, "unsettledBalance"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.unsettledBalance);
            if (message.totalSatoshisSent != null && Object.hasOwnProperty.call(message, "totalSatoshisSent"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.totalSatoshisSent);
            if (message.totalSatoshisReceived != null && Object.hasOwnProperty.call(message, "totalSatoshisReceived"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.totalSatoshisReceived);
            if (message.numUpdates != null && Object.hasOwnProperty.call(message, "numUpdates"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.numUpdates);
            if (message.pendingHtlcs != null && message.pendingHtlcs.length)
                for (let i = 0; i < message.pendingHtlcs.length; ++i)
                    $root.lnrpc.HTLC.encode(message.pendingHtlcs[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.csvDelay != null && Object.hasOwnProperty.call(message, "csvDelay"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.csvDelay);
            if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message["private"]);
            if (message.initiator != null && Object.hasOwnProperty.call(message, "initiator"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.initiator);
            if (message.chanStatusFlags != null && Object.hasOwnProperty.call(message, "chanStatusFlags"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.chanStatusFlags);
            if (message.localChanReserveSat != null && Object.hasOwnProperty.call(message, "localChanReserveSat"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.localChanReserveSat);
            if (message.remoteChanReserveSat != null && Object.hasOwnProperty.call(message, "remoteChanReserveSat"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.remoteChanReserveSat);
            if (message.staticRemoteKey != null && Object.hasOwnProperty.call(message, "staticRemoteKey"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.staticRemoteKey);
            if (message.lifetime != null && Object.hasOwnProperty.call(message, "lifetime"))
                writer.uint32(/* id 23, wireType 0 =*/184).int64(message.lifetime);
            if (message.uptime != null && Object.hasOwnProperty.call(message, "uptime"))
                writer.uint32(/* id 24, wireType 0 =*/192).int64(message.uptime);
            if (message.closeAddress != null && Object.hasOwnProperty.call(message, "closeAddress"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.closeAddress);
            if (message.commitmentType != null && Object.hasOwnProperty.call(message, "commitmentType"))
                writer.uint32(/* id 26, wireType 0 =*/208).int32(message.commitmentType);
            if (message.pushAmountSat != null && Object.hasOwnProperty.call(message, "pushAmountSat"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint64(message.pushAmountSat);
            if (message.thawHeight != null && Object.hasOwnProperty.call(message, "thawHeight"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.thawHeight);
            if (message.localConstraints != null && Object.hasOwnProperty.call(message, "localConstraints"))
                $root.lnrpc.ChannelConstraints.encode(message.localConstraints, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.remoteConstraints != null && Object.hasOwnProperty.call(message, "remoteConstraints"))
                $root.lnrpc.ChannelConstraints.encode(message.remoteConstraints, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Channel message, length delimited. Does not implicitly {@link lnrpc.Channel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Channel message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Channel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.active = reader.bool();
                    break;
                case 2:
                    message.remotePubkey = reader.string();
                    break;
                case 3:
                    message.channelPoint = reader.string();
                    break;
                case 4:
                    message.chanId = reader.uint64();
                    break;
                case 5:
                    message.capacity = reader.int64();
                    break;
                case 6:
                    message.localBalance = reader.int64();
                    break;
                case 7:
                    message.remoteBalance = reader.int64();
                    break;
                case 8:
                    message.commitFee = reader.int64();
                    break;
                case 9:
                    message.commitWeight = reader.int64();
                    break;
                case 10:
                    message.feePerKw = reader.int64();
                    break;
                case 11:
                    message.unsettledBalance = reader.int64();
                    break;
                case 12:
                    message.totalSatoshisSent = reader.int64();
                    break;
                case 13:
                    message.totalSatoshisReceived = reader.int64();
                    break;
                case 14:
                    message.numUpdates = reader.uint64();
                    break;
                case 15:
                    if (!(message.pendingHtlcs && message.pendingHtlcs.length))
                        message.pendingHtlcs = [];
                    message.pendingHtlcs.push($root.lnrpc.HTLC.decode(reader, reader.uint32()));
                    break;
                case 16:
                    message.csvDelay = reader.uint32();
                    break;
                case 17:
                    message["private"] = reader.bool();
                    break;
                case 18:
                    message.initiator = reader.bool();
                    break;
                case 19:
                    message.chanStatusFlags = reader.string();
                    break;
                case 20:
                    message.localChanReserveSat = reader.int64();
                    break;
                case 21:
                    message.remoteChanReserveSat = reader.int64();
                    break;
                case 22:
                    message.staticRemoteKey = reader.bool();
                    break;
                case 26:
                    message.commitmentType = reader.int32();
                    break;
                case 23:
                    message.lifetime = reader.int64();
                    break;
                case 24:
                    message.uptime = reader.int64();
                    break;
                case 25:
                    message.closeAddress = reader.string();
                    break;
                case 27:
                    message.pushAmountSat = reader.uint64();
                    break;
                case 28:
                    message.thawHeight = reader.uint32();
                    break;
                case 29:
                    message.localConstraints = $root.lnrpc.ChannelConstraints.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.remoteConstraints = $root.lnrpc.ChannelConstraints.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Channel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Channel message.
         * @function verify
         * @memberof lnrpc.Channel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Channel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                if (!$util.isString(message.remotePubkey))
                    return "remotePubkey: string expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                if (!$util.isInteger(message.localBalance) && !(message.localBalance && $util.isInteger(message.localBalance.low) && $util.isInteger(message.localBalance.high)))
                    return "localBalance: integer|Long expected";
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                if (!$util.isInteger(message.remoteBalance) && !(message.remoteBalance && $util.isInteger(message.remoteBalance.low) && $util.isInteger(message.remoteBalance.high)))
                    return "remoteBalance: integer|Long expected";
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                if (!$util.isInteger(message.commitFee) && !(message.commitFee && $util.isInteger(message.commitFee.low) && $util.isInteger(message.commitFee.high)))
                    return "commitFee: integer|Long expected";
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                if (!$util.isInteger(message.commitWeight) && !(message.commitWeight && $util.isInteger(message.commitWeight.low) && $util.isInteger(message.commitWeight.high)))
                    return "commitWeight: integer|Long expected";
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                    return "feePerKw: integer|Long expected";
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                if (!$util.isInteger(message.unsettledBalance) && !(message.unsettledBalance && $util.isInteger(message.unsettledBalance.low) && $util.isInteger(message.unsettledBalance.high)))
                    return "unsettledBalance: integer|Long expected";
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                if (!$util.isInteger(message.totalSatoshisSent) && !(message.totalSatoshisSent && $util.isInteger(message.totalSatoshisSent.low) && $util.isInteger(message.totalSatoshisSent.high)))
                    return "totalSatoshisSent: integer|Long expected";
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                if (!$util.isInteger(message.totalSatoshisReceived) && !(message.totalSatoshisReceived && $util.isInteger(message.totalSatoshisReceived.low) && $util.isInteger(message.totalSatoshisReceived.high)))
                    return "totalSatoshisReceived: integer|Long expected";
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                if (!$util.isInteger(message.numUpdates) && !(message.numUpdates && $util.isInteger(message.numUpdates.low) && $util.isInteger(message.numUpdates.high)))
                    return "numUpdates: integer|Long expected";
            if (message.pendingHtlcs != null && message.hasOwnProperty("pendingHtlcs")) {
                if (!Array.isArray(message.pendingHtlcs))
                    return "pendingHtlcs: array expected";
                for (let i = 0; i < message.pendingHtlcs.length; ++i) {
                    let error = $root.lnrpc.HTLC.verify(message.pendingHtlcs[i]);
                    if (error)
                        return "pendingHtlcs." + error;
                }
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                if (!$util.isInteger(message.csvDelay))
                    return "csvDelay: integer expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                if (typeof message.initiator !== "boolean")
                    return "initiator: boolean expected";
            if (message.chanStatusFlags != null && message.hasOwnProperty("chanStatusFlags"))
                if (!$util.isString(message.chanStatusFlags))
                    return "chanStatusFlags: string expected";
            if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                if (!$util.isInteger(message.localChanReserveSat) && !(message.localChanReserveSat && $util.isInteger(message.localChanReserveSat.low) && $util.isInteger(message.localChanReserveSat.high)))
                    return "localChanReserveSat: integer|Long expected";
            if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                if (!$util.isInteger(message.remoteChanReserveSat) && !(message.remoteChanReserveSat && $util.isInteger(message.remoteChanReserveSat.low) && $util.isInteger(message.remoteChanReserveSat.high)))
                    return "remoteChanReserveSat: integer|Long expected";
            if (message.staticRemoteKey != null && message.hasOwnProperty("staticRemoteKey"))
                if (typeof message.staticRemoteKey !== "boolean")
                    return "staticRemoteKey: boolean expected";
            if (message.commitmentType != null && message.hasOwnProperty("commitmentType"))
                switch (message.commitmentType) {
                default:
                    return "commitmentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 999:
                    break;
                }
            if (message.lifetime != null && message.hasOwnProperty("lifetime"))
                if (!$util.isInteger(message.lifetime) && !(message.lifetime && $util.isInteger(message.lifetime.low) && $util.isInteger(message.lifetime.high)))
                    return "lifetime: integer|Long expected";
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                if (!$util.isInteger(message.uptime) && !(message.uptime && $util.isInteger(message.uptime.low) && $util.isInteger(message.uptime.high)))
                    return "uptime: integer|Long expected";
            if (message.closeAddress != null && message.hasOwnProperty("closeAddress"))
                if (!$util.isString(message.closeAddress))
                    return "closeAddress: string expected";
            if (message.pushAmountSat != null && message.hasOwnProperty("pushAmountSat"))
                if (!$util.isInteger(message.pushAmountSat) && !(message.pushAmountSat && $util.isInteger(message.pushAmountSat.low) && $util.isInteger(message.pushAmountSat.high)))
                    return "pushAmountSat: integer|Long expected";
            if (message.thawHeight != null && message.hasOwnProperty("thawHeight"))
                if (!$util.isInteger(message.thawHeight))
                    return "thawHeight: integer expected";
            if (message.localConstraints != null && message.hasOwnProperty("localConstraints")) {
                let error = $root.lnrpc.ChannelConstraints.verify(message.localConstraints);
                if (error)
                    return "localConstraints." + error;
            }
            if (message.remoteConstraints != null && message.hasOwnProperty("remoteConstraints")) {
                let error = $root.lnrpc.ChannelConstraints.verify(message.remoteConstraints);
                if (error)
                    return "remoteConstraints." + error;
            }
            return null;
        };

        /**
         * Creates a Channel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Channel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Channel} Channel
         */
        Channel.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Channel)
                return object;
            let message = new $root.lnrpc.Channel();
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.remotePubkey != null)
                message.remotePubkey = String(object.remotePubkey);
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.localBalance != null)
                if ($util.Long)
                    (message.localBalance = $util.Long.fromValue(object.localBalance)).unsigned = false;
                else if (typeof object.localBalance === "string")
                    message.localBalance = parseInt(object.localBalance, 10);
                else if (typeof object.localBalance === "number")
                    message.localBalance = object.localBalance;
                else if (typeof object.localBalance === "object")
                    message.localBalance = new $util.LongBits(object.localBalance.low >>> 0, object.localBalance.high >>> 0).toNumber();
            if (object.remoteBalance != null)
                if ($util.Long)
                    (message.remoteBalance = $util.Long.fromValue(object.remoteBalance)).unsigned = false;
                else if (typeof object.remoteBalance === "string")
                    message.remoteBalance = parseInt(object.remoteBalance, 10);
                else if (typeof object.remoteBalance === "number")
                    message.remoteBalance = object.remoteBalance;
                else if (typeof object.remoteBalance === "object")
                    message.remoteBalance = new $util.LongBits(object.remoteBalance.low >>> 0, object.remoteBalance.high >>> 0).toNumber();
            if (object.commitFee != null)
                if ($util.Long)
                    (message.commitFee = $util.Long.fromValue(object.commitFee)).unsigned = false;
                else if (typeof object.commitFee === "string")
                    message.commitFee = parseInt(object.commitFee, 10);
                else if (typeof object.commitFee === "number")
                    message.commitFee = object.commitFee;
                else if (typeof object.commitFee === "object")
                    message.commitFee = new $util.LongBits(object.commitFee.low >>> 0, object.commitFee.high >>> 0).toNumber();
            if (object.commitWeight != null)
                if ($util.Long)
                    (message.commitWeight = $util.Long.fromValue(object.commitWeight)).unsigned = false;
                else if (typeof object.commitWeight === "string")
                    message.commitWeight = parseInt(object.commitWeight, 10);
                else if (typeof object.commitWeight === "number")
                    message.commitWeight = object.commitWeight;
                else if (typeof object.commitWeight === "object")
                    message.commitWeight = new $util.LongBits(object.commitWeight.low >>> 0, object.commitWeight.high >>> 0).toNumber();
            if (object.feePerKw != null)
                if ($util.Long)
                    (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = false;
                else if (typeof object.feePerKw === "string")
                    message.feePerKw = parseInt(object.feePerKw, 10);
                else if (typeof object.feePerKw === "number")
                    message.feePerKw = object.feePerKw;
                else if (typeof object.feePerKw === "object")
                    message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber();
            if (object.unsettledBalance != null)
                if ($util.Long)
                    (message.unsettledBalance = $util.Long.fromValue(object.unsettledBalance)).unsigned = false;
                else if (typeof object.unsettledBalance === "string")
                    message.unsettledBalance = parseInt(object.unsettledBalance, 10);
                else if (typeof object.unsettledBalance === "number")
                    message.unsettledBalance = object.unsettledBalance;
                else if (typeof object.unsettledBalance === "object")
                    message.unsettledBalance = new $util.LongBits(object.unsettledBalance.low >>> 0, object.unsettledBalance.high >>> 0).toNumber();
            if (object.totalSatoshisSent != null)
                if ($util.Long)
                    (message.totalSatoshisSent = $util.Long.fromValue(object.totalSatoshisSent)).unsigned = false;
                else if (typeof object.totalSatoshisSent === "string")
                    message.totalSatoshisSent = parseInt(object.totalSatoshisSent, 10);
                else if (typeof object.totalSatoshisSent === "number")
                    message.totalSatoshisSent = object.totalSatoshisSent;
                else if (typeof object.totalSatoshisSent === "object")
                    message.totalSatoshisSent = new $util.LongBits(object.totalSatoshisSent.low >>> 0, object.totalSatoshisSent.high >>> 0).toNumber();
            if (object.totalSatoshisReceived != null)
                if ($util.Long)
                    (message.totalSatoshisReceived = $util.Long.fromValue(object.totalSatoshisReceived)).unsigned = false;
                else if (typeof object.totalSatoshisReceived === "string")
                    message.totalSatoshisReceived = parseInt(object.totalSatoshisReceived, 10);
                else if (typeof object.totalSatoshisReceived === "number")
                    message.totalSatoshisReceived = object.totalSatoshisReceived;
                else if (typeof object.totalSatoshisReceived === "object")
                    message.totalSatoshisReceived = new $util.LongBits(object.totalSatoshisReceived.low >>> 0, object.totalSatoshisReceived.high >>> 0).toNumber();
            if (object.numUpdates != null)
                if ($util.Long)
                    (message.numUpdates = $util.Long.fromValue(object.numUpdates)).unsigned = true;
                else if (typeof object.numUpdates === "string")
                    message.numUpdates = parseInt(object.numUpdates, 10);
                else if (typeof object.numUpdates === "number")
                    message.numUpdates = object.numUpdates;
                else if (typeof object.numUpdates === "object")
                    message.numUpdates = new $util.LongBits(object.numUpdates.low >>> 0, object.numUpdates.high >>> 0).toNumber(true);
            if (object.pendingHtlcs) {
                if (!Array.isArray(object.pendingHtlcs))
                    throw TypeError(".lnrpc.Channel.pendingHtlcs: array expected");
                message.pendingHtlcs = [];
                for (let i = 0; i < object.pendingHtlcs.length; ++i) {
                    if (typeof object.pendingHtlcs[i] !== "object")
                        throw TypeError(".lnrpc.Channel.pendingHtlcs: object expected");
                    message.pendingHtlcs[i] = $root.lnrpc.HTLC.fromObject(object.pendingHtlcs[i]);
                }
            }
            if (object.csvDelay != null)
                message.csvDelay = object.csvDelay >>> 0;
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.initiator != null)
                message.initiator = Boolean(object.initiator);
            if (object.chanStatusFlags != null)
                message.chanStatusFlags = String(object.chanStatusFlags);
            if (object.localChanReserveSat != null)
                if ($util.Long)
                    (message.localChanReserveSat = $util.Long.fromValue(object.localChanReserveSat)).unsigned = false;
                else if (typeof object.localChanReserveSat === "string")
                    message.localChanReserveSat = parseInt(object.localChanReserveSat, 10);
                else if (typeof object.localChanReserveSat === "number")
                    message.localChanReserveSat = object.localChanReserveSat;
                else if (typeof object.localChanReserveSat === "object")
                    message.localChanReserveSat = new $util.LongBits(object.localChanReserveSat.low >>> 0, object.localChanReserveSat.high >>> 0).toNumber();
            if (object.remoteChanReserveSat != null)
                if ($util.Long)
                    (message.remoteChanReserveSat = $util.Long.fromValue(object.remoteChanReserveSat)).unsigned = false;
                else if (typeof object.remoteChanReserveSat === "string")
                    message.remoteChanReserveSat = parseInt(object.remoteChanReserveSat, 10);
                else if (typeof object.remoteChanReserveSat === "number")
                    message.remoteChanReserveSat = object.remoteChanReserveSat;
                else if (typeof object.remoteChanReserveSat === "object")
                    message.remoteChanReserveSat = new $util.LongBits(object.remoteChanReserveSat.low >>> 0, object.remoteChanReserveSat.high >>> 0).toNumber();
            if (object.staticRemoteKey != null)
                message.staticRemoteKey = Boolean(object.staticRemoteKey);
            switch (object.commitmentType) {
            case "LEGACY":
            case 0:
                message.commitmentType = 0;
                break;
            case "STATIC_REMOTE_KEY":
            case 1:
                message.commitmentType = 1;
                break;
            case "ANCHORS":
            case 2:
                message.commitmentType = 2;
                break;
            case "UNKNOWN_COMMITMENT_TYPE":
            case 999:
                message.commitmentType = 999;
                break;
            }
            if (object.lifetime != null)
                if ($util.Long)
                    (message.lifetime = $util.Long.fromValue(object.lifetime)).unsigned = false;
                else if (typeof object.lifetime === "string")
                    message.lifetime = parseInt(object.lifetime, 10);
                else if (typeof object.lifetime === "number")
                    message.lifetime = object.lifetime;
                else if (typeof object.lifetime === "object")
                    message.lifetime = new $util.LongBits(object.lifetime.low >>> 0, object.lifetime.high >>> 0).toNumber();
            if (object.uptime != null)
                if ($util.Long)
                    (message.uptime = $util.Long.fromValue(object.uptime)).unsigned = false;
                else if (typeof object.uptime === "string")
                    message.uptime = parseInt(object.uptime, 10);
                else if (typeof object.uptime === "number")
                    message.uptime = object.uptime;
                else if (typeof object.uptime === "object")
                    message.uptime = new $util.LongBits(object.uptime.low >>> 0, object.uptime.high >>> 0).toNumber();
            if (object.closeAddress != null)
                message.closeAddress = String(object.closeAddress);
            if (object.pushAmountSat != null)
                if ($util.Long)
                    (message.pushAmountSat = $util.Long.fromValue(object.pushAmountSat)).unsigned = true;
                else if (typeof object.pushAmountSat === "string")
                    message.pushAmountSat = parseInt(object.pushAmountSat, 10);
                else if (typeof object.pushAmountSat === "number")
                    message.pushAmountSat = object.pushAmountSat;
                else if (typeof object.pushAmountSat === "object")
                    message.pushAmountSat = new $util.LongBits(object.pushAmountSat.low >>> 0, object.pushAmountSat.high >>> 0).toNumber(true);
            if (object.thawHeight != null)
                message.thawHeight = object.thawHeight >>> 0;
            if (object.localConstraints != null) {
                if (typeof object.localConstraints !== "object")
                    throw TypeError(".lnrpc.Channel.localConstraints: object expected");
                message.localConstraints = $root.lnrpc.ChannelConstraints.fromObject(object.localConstraints);
            }
            if (object.remoteConstraints != null) {
                if (typeof object.remoteConstraints !== "object")
                    throw TypeError(".lnrpc.Channel.remoteConstraints: object expected");
                message.remoteConstraints = $root.lnrpc.ChannelConstraints.fromObject(object.remoteConstraints);
            }
            return message;
        };

        /**
         * Creates a plain object from a Channel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.Channel} message Channel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Channel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.pendingHtlcs = [];
            if (options.defaults) {
                object.active = false;
                object.remotePubkey = "";
                object.channelPoint = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.localBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.remoteBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remoteBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.commitFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commitFee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.commitWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commitWeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerKw = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unsettledBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unsettledBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalSatoshisSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSatoshisSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalSatoshisReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSatoshisReceived = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.numUpdates = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numUpdates = options.longs === String ? "0" : 0;
                object.csvDelay = 0;
                object["private"] = false;
                object.initiator = false;
                object.chanStatusFlags = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.localChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localChanReserveSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.remoteChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remoteChanReserveSat = options.longs === String ? "0" : 0;
                object.staticRemoteKey = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lifetime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lifetime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.uptime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uptime = options.longs === String ? "0" : 0;
                object.closeAddress = "";
                object.commitmentType = options.enums === String ? "LEGACY" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.pushAmountSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pushAmountSat = options.longs === String ? "0" : 0;
                object.thawHeight = 0;
                object.localConstraints = null;
                object.remoteConstraints = null;
            }
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                object.remotePubkey = message.remotePubkey;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                if (typeof message.localBalance === "number")
                    object.localBalance = options.longs === String ? String(message.localBalance) : message.localBalance;
                else
                    object.localBalance = options.longs === String ? $util.Long.prototype.toString.call(message.localBalance) : options.longs === Number ? new $util.LongBits(message.localBalance.low >>> 0, message.localBalance.high >>> 0).toNumber() : message.localBalance;
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                if (typeof message.remoteBalance === "number")
                    object.remoteBalance = options.longs === String ? String(message.remoteBalance) : message.remoteBalance;
                else
                    object.remoteBalance = options.longs === String ? $util.Long.prototype.toString.call(message.remoteBalance) : options.longs === Number ? new $util.LongBits(message.remoteBalance.low >>> 0, message.remoteBalance.high >>> 0).toNumber() : message.remoteBalance;
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                if (typeof message.commitFee === "number")
                    object.commitFee = options.longs === String ? String(message.commitFee) : message.commitFee;
                else
                    object.commitFee = options.longs === String ? $util.Long.prototype.toString.call(message.commitFee) : options.longs === Number ? new $util.LongBits(message.commitFee.low >>> 0, message.commitFee.high >>> 0).toNumber() : message.commitFee;
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                if (typeof message.commitWeight === "number")
                    object.commitWeight = options.longs === String ? String(message.commitWeight) : message.commitWeight;
                else
                    object.commitWeight = options.longs === String ? $util.Long.prototype.toString.call(message.commitWeight) : options.longs === Number ? new $util.LongBits(message.commitWeight.low >>> 0, message.commitWeight.high >>> 0).toNumber() : message.commitWeight;
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (typeof message.feePerKw === "number")
                    object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                else
                    object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber() : message.feePerKw;
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                if (typeof message.unsettledBalance === "number")
                    object.unsettledBalance = options.longs === String ? String(message.unsettledBalance) : message.unsettledBalance;
                else
                    object.unsettledBalance = options.longs === String ? $util.Long.prototype.toString.call(message.unsettledBalance) : options.longs === Number ? new $util.LongBits(message.unsettledBalance.low >>> 0, message.unsettledBalance.high >>> 0).toNumber() : message.unsettledBalance;
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                if (typeof message.totalSatoshisSent === "number")
                    object.totalSatoshisSent = options.longs === String ? String(message.totalSatoshisSent) : message.totalSatoshisSent;
                else
                    object.totalSatoshisSent = options.longs === String ? $util.Long.prototype.toString.call(message.totalSatoshisSent) : options.longs === Number ? new $util.LongBits(message.totalSatoshisSent.low >>> 0, message.totalSatoshisSent.high >>> 0).toNumber() : message.totalSatoshisSent;
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                if (typeof message.totalSatoshisReceived === "number")
                    object.totalSatoshisReceived = options.longs === String ? String(message.totalSatoshisReceived) : message.totalSatoshisReceived;
                else
                    object.totalSatoshisReceived = options.longs === String ? $util.Long.prototype.toString.call(message.totalSatoshisReceived) : options.longs === Number ? new $util.LongBits(message.totalSatoshisReceived.low >>> 0, message.totalSatoshisReceived.high >>> 0).toNumber() : message.totalSatoshisReceived;
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                if (typeof message.numUpdates === "number")
                    object.numUpdates = options.longs === String ? String(message.numUpdates) : message.numUpdates;
                else
                    object.numUpdates = options.longs === String ? $util.Long.prototype.toString.call(message.numUpdates) : options.longs === Number ? new $util.LongBits(message.numUpdates.low >>> 0, message.numUpdates.high >>> 0).toNumber(true) : message.numUpdates;
            if (message.pendingHtlcs && message.pendingHtlcs.length) {
                object.pendingHtlcs = [];
                for (let j = 0; j < message.pendingHtlcs.length; ++j)
                    object.pendingHtlcs[j] = $root.lnrpc.HTLC.toObject(message.pendingHtlcs[j], options);
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                object.csvDelay = message.csvDelay;
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                object.initiator = message.initiator;
            if (message.chanStatusFlags != null && message.hasOwnProperty("chanStatusFlags"))
                object.chanStatusFlags = message.chanStatusFlags;
            if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                if (typeof message.localChanReserveSat === "number")
                    object.localChanReserveSat = options.longs === String ? String(message.localChanReserveSat) : message.localChanReserveSat;
                else
                    object.localChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.localChanReserveSat) : options.longs === Number ? new $util.LongBits(message.localChanReserveSat.low >>> 0, message.localChanReserveSat.high >>> 0).toNumber() : message.localChanReserveSat;
            if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                if (typeof message.remoteChanReserveSat === "number")
                    object.remoteChanReserveSat = options.longs === String ? String(message.remoteChanReserveSat) : message.remoteChanReserveSat;
                else
                    object.remoteChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.remoteChanReserveSat) : options.longs === Number ? new $util.LongBits(message.remoteChanReserveSat.low >>> 0, message.remoteChanReserveSat.high >>> 0).toNumber() : message.remoteChanReserveSat;
            if (message.staticRemoteKey != null && message.hasOwnProperty("staticRemoteKey"))
                object.staticRemoteKey = message.staticRemoteKey;
            if (message.lifetime != null && message.hasOwnProperty("lifetime"))
                if (typeof message.lifetime === "number")
                    object.lifetime = options.longs === String ? String(message.lifetime) : message.lifetime;
                else
                    object.lifetime = options.longs === String ? $util.Long.prototype.toString.call(message.lifetime) : options.longs === Number ? new $util.LongBits(message.lifetime.low >>> 0, message.lifetime.high >>> 0).toNumber() : message.lifetime;
            if (message.uptime != null && message.hasOwnProperty("uptime"))
                if (typeof message.uptime === "number")
                    object.uptime = options.longs === String ? String(message.uptime) : message.uptime;
                else
                    object.uptime = options.longs === String ? $util.Long.prototype.toString.call(message.uptime) : options.longs === Number ? new $util.LongBits(message.uptime.low >>> 0, message.uptime.high >>> 0).toNumber() : message.uptime;
            if (message.closeAddress != null && message.hasOwnProperty("closeAddress"))
                object.closeAddress = message.closeAddress;
            if (message.commitmentType != null && message.hasOwnProperty("commitmentType"))
                object.commitmentType = options.enums === String ? $root.lnrpc.CommitmentType[message.commitmentType] : message.commitmentType;
            if (message.pushAmountSat != null && message.hasOwnProperty("pushAmountSat"))
                if (typeof message.pushAmountSat === "number")
                    object.pushAmountSat = options.longs === String ? String(message.pushAmountSat) : message.pushAmountSat;
                else
                    object.pushAmountSat = options.longs === String ? $util.Long.prototype.toString.call(message.pushAmountSat) : options.longs === Number ? new $util.LongBits(message.pushAmountSat.low >>> 0, message.pushAmountSat.high >>> 0).toNumber(true) : message.pushAmountSat;
            if (message.thawHeight != null && message.hasOwnProperty("thawHeight"))
                object.thawHeight = message.thawHeight;
            if (message.localConstraints != null && message.hasOwnProperty("localConstraints"))
                object.localConstraints = $root.lnrpc.ChannelConstraints.toObject(message.localConstraints, options);
            if (message.remoteConstraints != null && message.hasOwnProperty("remoteConstraints"))
                object.remoteConstraints = $root.lnrpc.ChannelConstraints.toObject(message.remoteConstraints, options);
            return object;
        };

        /**
         * Converts this Channel to JSON.
         * @function toJSON
         * @memberof lnrpc.Channel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Channel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Channel;
    })();

    lnrpc.ListChannelsRequest = (function() {

        /**
         * Properties of a ListChannelsRequest.
         * @memberof lnrpc
         * @interface IListChannelsRequest
         * @property {boolean|null} [activeOnly] ListChannelsRequest activeOnly
         * @property {boolean|null} [inactiveOnly] ListChannelsRequest inactiveOnly
         * @property {boolean|null} [publicOnly] ListChannelsRequest publicOnly
         * @property {boolean|null} [privateOnly] ListChannelsRequest privateOnly
         * @property {Uint8Array|null} [peer] ListChannelsRequest peer
         */

        /**
         * Constructs a new ListChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListChannelsRequest.
         * @implements IListChannelsRequest
         * @constructor
         * @param {lnrpc.IListChannelsRequest=} [properties] Properties to set
         */
        function ListChannelsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListChannelsRequest activeOnly.
         * @member {boolean} activeOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.activeOnly = false;

        /**
         * ListChannelsRequest inactiveOnly.
         * @member {boolean} inactiveOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.inactiveOnly = false;

        /**
         * ListChannelsRequest publicOnly.
         * @member {boolean} publicOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.publicOnly = false;

        /**
         * ListChannelsRequest privateOnly.
         * @member {boolean} privateOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.privateOnly = false;

        /**
         * ListChannelsRequest peer.
         * @member {Uint8Array} peer
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.peer = $util.newBuffer([]);

        /**
         * Creates a new ListChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest instance
         */
        ListChannelsRequest.create = function create(properties) {
            return new ListChannelsRequest(properties);
        };

        /**
         * Encodes the specified ListChannelsRequest message. Does not implicitly {@link lnrpc.ListChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest} message ListChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activeOnly != null && Object.hasOwnProperty.call(message, "activeOnly"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.activeOnly);
            if (message.inactiveOnly != null && Object.hasOwnProperty.call(message, "inactiveOnly"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inactiveOnly);
            if (message.publicOnly != null && Object.hasOwnProperty.call(message, "publicOnly"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.publicOnly);
            if (message.privateOnly != null && Object.hasOwnProperty.call(message, "privateOnly"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.privateOnly);
            if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.peer);
            return writer;
        };

        /**
         * Encodes the specified ListChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.ListChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest} message ListChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListChannelsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activeOnly = reader.bool();
                    break;
                case 2:
                    message.inactiveOnly = reader.bool();
                    break;
                case 3:
                    message.publicOnly = reader.bool();
                    break;
                case 4:
                    message.privateOnly = reader.bool();
                    break;
                case 5:
                    message.peer = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListChannelsRequest message.
         * @function verify
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                if (typeof message.activeOnly !== "boolean")
                    return "activeOnly: boolean expected";
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                if (typeof message.inactiveOnly !== "boolean")
                    return "inactiveOnly: boolean expected";
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                if (typeof message.publicOnly !== "boolean")
                    return "publicOnly: boolean expected";
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                if (typeof message.privateOnly !== "boolean")
                    return "privateOnly: boolean expected";
            if (message.peer != null && message.hasOwnProperty("peer"))
                if (!(message.peer && typeof message.peer.length === "number" || $util.isString(message.peer)))
                    return "peer: buffer expected";
            return null;
        };

        /**
         * Creates a ListChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         */
        ListChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListChannelsRequest)
                return object;
            let message = new $root.lnrpc.ListChannelsRequest();
            if (object.activeOnly != null)
                message.activeOnly = Boolean(object.activeOnly);
            if (object.inactiveOnly != null)
                message.inactiveOnly = Boolean(object.inactiveOnly);
            if (object.publicOnly != null)
                message.publicOnly = Boolean(object.publicOnly);
            if (object.privateOnly != null)
                message.privateOnly = Boolean(object.privateOnly);
            if (object.peer != null)
                if (typeof object.peer === "string")
                    $util.base64.decode(object.peer, message.peer = $util.newBuffer($util.base64.length(object.peer)), 0);
                else if (object.peer.length)
                    message.peer = object.peer;
            return message;
        };

        /**
         * Creates a plain object from a ListChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.ListChannelsRequest} message ListChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListChannelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.activeOnly = false;
                object.inactiveOnly = false;
                object.publicOnly = false;
                object.privateOnly = false;
                if (options.bytes === String)
                    object.peer = "";
                else {
                    object.peer = [];
                    if (options.bytes !== Array)
                        object.peer = $util.newBuffer(object.peer);
                }
            }
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                object.activeOnly = message.activeOnly;
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                object.inactiveOnly = message.inactiveOnly;
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                object.publicOnly = message.publicOnly;
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                object.privateOnly = message.privateOnly;
            if (message.peer != null && message.hasOwnProperty("peer"))
                object.peer = options.bytes === String ? $util.base64.encode(message.peer, 0, message.peer.length) : options.bytes === Array ? Array.prototype.slice.call(message.peer) : message.peer;
            return object;
        };

        /**
         * Converts this ListChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListChannelsRequest;
    })();

    lnrpc.ListChannelsResponse = (function() {

        /**
         * Properties of a ListChannelsResponse.
         * @memberof lnrpc
         * @interface IListChannelsResponse
         * @property {Array.<lnrpc.IChannel>|null} [channels] ListChannelsResponse channels
         */

        /**
         * Constructs a new ListChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListChannelsResponse.
         * @implements IListChannelsResponse
         * @constructor
         * @param {lnrpc.IListChannelsResponse=} [properties] Properties to set
         */
        function ListChannelsResponse(properties) {
            this.channels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListChannelsResponse channels.
         * @member {Array.<lnrpc.IChannel>} channels
         * @memberof lnrpc.ListChannelsResponse
         * @instance
         */
        ListChannelsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ListChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse instance
         */
        ListChannelsResponse.create = function create(properties) {
            return new ListChannelsResponse(properties);
        };

        /**
         * Encodes the specified ListChannelsResponse message. Does not implicitly {@link lnrpc.ListChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse} message ListChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.Channel.encode(message.channels[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.ListChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse} message ListChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListChannelsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 11:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.Channel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListChannelsResponse message.
         * @function verify
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.lnrpc.Channel.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         */
        ListChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListChannelsResponse)
                return object;
            let message = new $root.lnrpc.ListChannelsResponse();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.ListChannelsResponse.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.ListChannelsResponse.channels: object expected");
                    message.channels[i] = $root.lnrpc.Channel.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.ListChannelsResponse} message ListChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.Channel.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this ListChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListChannelsResponse;
    })();

    /**
     * Initiator enum.
     * @name lnrpc.Initiator
     * @enum {number}
     * @property {number} INITIATOR_UNKNOWN=0 INITIATOR_UNKNOWN value
     * @property {number} INITIATOR_LOCAL=1 INITIATOR_LOCAL value
     * @property {number} INITIATOR_REMOTE=2 INITIATOR_REMOTE value
     * @property {number} INITIATOR_BOTH=3 INITIATOR_BOTH value
     */
    lnrpc.Initiator = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INITIATOR_UNKNOWN"] = 0;
        values[valuesById[1] = "INITIATOR_LOCAL"] = 1;
        values[valuesById[2] = "INITIATOR_REMOTE"] = 2;
        values[valuesById[3] = "INITIATOR_BOTH"] = 3;
        return values;
    })();

    lnrpc.ChannelCloseSummary = (function() {

        /**
         * Properties of a ChannelCloseSummary.
         * @memberof lnrpc
         * @interface IChannelCloseSummary
         * @property {string|null} [channelPoint] ChannelCloseSummary channelPoint
         * @property {number|Long|null} [chanId] ChannelCloseSummary chanId
         * @property {string|null} [chainHash] ChannelCloseSummary chainHash
         * @property {string|null} [closingTxHash] ChannelCloseSummary closingTxHash
         * @property {string|null} [remotePubkey] ChannelCloseSummary remotePubkey
         * @property {number|Long|null} [capacity] ChannelCloseSummary capacity
         * @property {number|null} [closeHeight] ChannelCloseSummary closeHeight
         * @property {number|Long|null} [settledBalance] ChannelCloseSummary settledBalance
         * @property {number|Long|null} [timeLockedBalance] ChannelCloseSummary timeLockedBalance
         * @property {lnrpc.ChannelCloseSummary.ClosureType|null} [closeType] ChannelCloseSummary closeType
         * @property {lnrpc.Initiator|null} [openInitiator] ChannelCloseSummary openInitiator
         * @property {lnrpc.Initiator|null} [closeInitiator] ChannelCloseSummary closeInitiator
         * @property {Array.<lnrpc.IResolution>|null} [resolutions] ChannelCloseSummary resolutions
         */

        /**
         * Constructs a new ChannelCloseSummary.
         * @memberof lnrpc
         * @classdesc Represents a ChannelCloseSummary.
         * @implements IChannelCloseSummary
         * @constructor
         * @param {lnrpc.IChannelCloseSummary=} [properties] Properties to set
         */
        function ChannelCloseSummary(properties) {
            this.resolutions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelCloseSummary channelPoint.
         * @member {string} channelPoint
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.channelPoint = "";

        /**
         * ChannelCloseSummary chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelCloseSummary chainHash.
         * @member {string} chainHash
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.chainHash = "";

        /**
         * ChannelCloseSummary closingTxHash.
         * @member {string} closingTxHash
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closingTxHash = "";

        /**
         * ChannelCloseSummary remotePubkey.
         * @member {string} remotePubkey
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.remotePubkey = "";

        /**
         * ChannelCloseSummary capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelCloseSummary closeHeight.
         * @member {number} closeHeight
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeHeight = 0;

        /**
         * ChannelCloseSummary settledBalance.
         * @member {number|Long} settledBalance
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.settledBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelCloseSummary timeLockedBalance.
         * @member {number|Long} timeLockedBalance
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.timeLockedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelCloseSummary closeType.
         * @member {lnrpc.ChannelCloseSummary.ClosureType} closeType
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeType = 0;

        /**
         * ChannelCloseSummary openInitiator.
         * @member {lnrpc.Initiator} openInitiator
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.openInitiator = 0;

        /**
         * ChannelCloseSummary closeInitiator.
         * @member {lnrpc.Initiator} closeInitiator
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeInitiator = 0;

        /**
         * ChannelCloseSummary resolutions.
         * @member {Array.<lnrpc.IResolution>} resolutions
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.resolutions = $util.emptyArray;

        /**
         * Creates a new ChannelCloseSummary instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary=} [properties] Properties to set
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary instance
         */
        ChannelCloseSummary.create = function create(properties) {
            return new ChannelCloseSummary(properties);
        };

        /**
         * Encodes the specified ChannelCloseSummary message. Does not implicitly {@link lnrpc.ChannelCloseSummary.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary} message ChannelCloseSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelPoint);
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanId);
            if (message.chainHash != null && Object.hasOwnProperty.call(message, "chainHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.chainHash);
            if (message.closingTxHash != null && Object.hasOwnProperty.call(message, "closingTxHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.closingTxHash);
            if (message.remotePubkey != null && Object.hasOwnProperty.call(message, "remotePubkey"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.remotePubkey);
            if (message.capacity != null && Object.hasOwnProperty.call(message, "capacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.capacity);
            if (message.closeHeight != null && Object.hasOwnProperty.call(message, "closeHeight"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.closeHeight);
            if (message.settledBalance != null && Object.hasOwnProperty.call(message, "settledBalance"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.settledBalance);
            if (message.timeLockedBalance != null && Object.hasOwnProperty.call(message, "timeLockedBalance"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeLockedBalance);
            if (message.closeType != null && Object.hasOwnProperty.call(message, "closeType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.closeType);
            if (message.openInitiator != null && Object.hasOwnProperty.call(message, "openInitiator"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.openInitiator);
            if (message.closeInitiator != null && Object.hasOwnProperty.call(message, "closeInitiator"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.closeInitiator);
            if (message.resolutions != null && message.resolutions.length)
                for (let i = 0; i < message.resolutions.length; ++i)
                    $root.lnrpc.Resolution.encode(message.resolutions[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseSummary message, length delimited. Does not implicitly {@link lnrpc.ChannelCloseSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary} message ChannelCloseSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseSummary message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelCloseSummary();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = reader.string();
                    break;
                case 2:
                    message.chanId = reader.uint64();
                    break;
                case 3:
                    message.chainHash = reader.string();
                    break;
                case 4:
                    message.closingTxHash = reader.string();
                    break;
                case 5:
                    message.remotePubkey = reader.string();
                    break;
                case 6:
                    message.capacity = reader.int64();
                    break;
                case 7:
                    message.closeHeight = reader.uint32();
                    break;
                case 8:
                    message.settledBalance = reader.int64();
                    break;
                case 9:
                    message.timeLockedBalance = reader.int64();
                    break;
                case 10:
                    message.closeType = reader.int32();
                    break;
                case 11:
                    message.openInitiator = reader.int32();
                    break;
                case 12:
                    message.closeInitiator = reader.int32();
                    break;
                case 13:
                    if (!(message.resolutions && message.resolutions.length))
                        message.resolutions = [];
                    message.resolutions.push($root.lnrpc.Resolution.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseSummary message.
         * @function verify
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                if (!$util.isString(message.chainHash))
                    return "chainHash: string expected";
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                if (!$util.isString(message.closingTxHash))
                    return "closingTxHash: string expected";
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                if (!$util.isString(message.remotePubkey))
                    return "remotePubkey: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                if (!$util.isInteger(message.closeHeight))
                    return "closeHeight: integer expected";
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                if (!$util.isInteger(message.settledBalance) && !(message.settledBalance && $util.isInteger(message.settledBalance.low) && $util.isInteger(message.settledBalance.high)))
                    return "settledBalance: integer|Long expected";
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                if (!$util.isInteger(message.timeLockedBalance) && !(message.timeLockedBalance && $util.isInteger(message.timeLockedBalance.low) && $util.isInteger(message.timeLockedBalance.high)))
                    return "timeLockedBalance: integer|Long expected";
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                switch (message.closeType) {
                default:
                    return "closeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.openInitiator != null && message.hasOwnProperty("openInitiator"))
                switch (message.openInitiator) {
                default:
                    return "openInitiator: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.closeInitiator != null && message.hasOwnProperty("closeInitiator"))
                switch (message.closeInitiator) {
                default:
                    return "closeInitiator: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.resolutions != null && message.hasOwnProperty("resolutions")) {
                if (!Array.isArray(message.resolutions))
                    return "resolutions: array expected";
                for (let i = 0; i < message.resolutions.length; ++i) {
                    let error = $root.lnrpc.Resolution.verify(message.resolutions[i]);
                    if (error)
                        return "resolutions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChannelCloseSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         */
        ChannelCloseSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelCloseSummary)
                return object;
            let message = new $root.lnrpc.ChannelCloseSummary();
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chainHash != null)
                message.chainHash = String(object.chainHash);
            if (object.closingTxHash != null)
                message.closingTxHash = String(object.closingTxHash);
            if (object.remotePubkey != null)
                message.remotePubkey = String(object.remotePubkey);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.closeHeight != null)
                message.closeHeight = object.closeHeight >>> 0;
            if (object.settledBalance != null)
                if ($util.Long)
                    (message.settledBalance = $util.Long.fromValue(object.settledBalance)).unsigned = false;
                else if (typeof object.settledBalance === "string")
                    message.settledBalance = parseInt(object.settledBalance, 10);
                else if (typeof object.settledBalance === "number")
                    message.settledBalance = object.settledBalance;
                else if (typeof object.settledBalance === "object")
                    message.settledBalance = new $util.LongBits(object.settledBalance.low >>> 0, object.settledBalance.high >>> 0).toNumber();
            if (object.timeLockedBalance != null)
                if ($util.Long)
                    (message.timeLockedBalance = $util.Long.fromValue(object.timeLockedBalance)).unsigned = false;
                else if (typeof object.timeLockedBalance === "string")
                    message.timeLockedBalance = parseInt(object.timeLockedBalance, 10);
                else if (typeof object.timeLockedBalance === "number")
                    message.timeLockedBalance = object.timeLockedBalance;
                else if (typeof object.timeLockedBalance === "object")
                    message.timeLockedBalance = new $util.LongBits(object.timeLockedBalance.low >>> 0, object.timeLockedBalance.high >>> 0).toNumber();
            switch (object.closeType) {
            case "COOPERATIVE_CLOSE":
            case 0:
                message.closeType = 0;
                break;
            case "LOCAL_FORCE_CLOSE":
            case 1:
                message.closeType = 1;
                break;
            case "REMOTE_FORCE_CLOSE":
            case 2:
                message.closeType = 2;
                break;
            case "BREACH_CLOSE":
            case 3:
                message.closeType = 3;
                break;
            case "FUNDING_CANCELED":
            case 4:
                message.closeType = 4;
                break;
            case "ABANDONED":
            case 5:
                message.closeType = 5;
                break;
            }
            switch (object.openInitiator) {
            case "INITIATOR_UNKNOWN":
            case 0:
                message.openInitiator = 0;
                break;
            case "INITIATOR_LOCAL":
            case 1:
                message.openInitiator = 1;
                break;
            case "INITIATOR_REMOTE":
            case 2:
                message.openInitiator = 2;
                break;
            case "INITIATOR_BOTH":
            case 3:
                message.openInitiator = 3;
                break;
            }
            switch (object.closeInitiator) {
            case "INITIATOR_UNKNOWN":
            case 0:
                message.closeInitiator = 0;
                break;
            case "INITIATOR_LOCAL":
            case 1:
                message.closeInitiator = 1;
                break;
            case "INITIATOR_REMOTE":
            case 2:
                message.closeInitiator = 2;
                break;
            case "INITIATOR_BOTH":
            case 3:
                message.closeInitiator = 3;
                break;
            }
            if (object.resolutions) {
                if (!Array.isArray(object.resolutions))
                    throw TypeError(".lnrpc.ChannelCloseSummary.resolutions: array expected");
                message.resolutions = [];
                for (let i = 0; i < object.resolutions.length; ++i) {
                    if (typeof object.resolutions[i] !== "object")
                        throw TypeError(".lnrpc.ChannelCloseSummary.resolutions: object expected");
                    message.resolutions[i] = $root.lnrpc.Resolution.fromObject(object.resolutions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.ChannelCloseSummary} message ChannelCloseSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resolutions = [];
            if (options.defaults) {
                object.channelPoint = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.chainHash = "";
                object.closingTxHash = "";
                object.remotePubkey = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.closeHeight = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.settledBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settledBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timeLockedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeLockedBalance = options.longs === String ? "0" : 0;
                object.closeType = options.enums === String ? "COOPERATIVE_CLOSE" : 0;
                object.openInitiator = options.enums === String ? "INITIATOR_UNKNOWN" : 0;
                object.closeInitiator = options.enums === String ? "INITIATOR_UNKNOWN" : 0;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                object.chainHash = message.chainHash;
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                object.closingTxHash = message.closingTxHash;
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                object.remotePubkey = message.remotePubkey;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                object.closeHeight = message.closeHeight;
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                if (typeof message.settledBalance === "number")
                    object.settledBalance = options.longs === String ? String(message.settledBalance) : message.settledBalance;
                else
                    object.settledBalance = options.longs === String ? $util.Long.prototype.toString.call(message.settledBalance) : options.longs === Number ? new $util.LongBits(message.settledBalance.low >>> 0, message.settledBalance.high >>> 0).toNumber() : message.settledBalance;
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                if (typeof message.timeLockedBalance === "number")
                    object.timeLockedBalance = options.longs === String ? String(message.timeLockedBalance) : message.timeLockedBalance;
                else
                    object.timeLockedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.timeLockedBalance) : options.longs === Number ? new $util.LongBits(message.timeLockedBalance.low >>> 0, message.timeLockedBalance.high >>> 0).toNumber() : message.timeLockedBalance;
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                object.closeType = options.enums === String ? $root.lnrpc.ChannelCloseSummary.ClosureType[message.closeType] : message.closeType;
            if (message.openInitiator != null && message.hasOwnProperty("openInitiator"))
                object.openInitiator = options.enums === String ? $root.lnrpc.Initiator[message.openInitiator] : message.openInitiator;
            if (message.closeInitiator != null && message.hasOwnProperty("closeInitiator"))
                object.closeInitiator = options.enums === String ? $root.lnrpc.Initiator[message.closeInitiator] : message.closeInitiator;
            if (message.resolutions && message.resolutions.length) {
                object.resolutions = [];
                for (let j = 0; j < message.resolutions.length; ++j)
                    object.resolutions[j] = $root.lnrpc.Resolution.toObject(message.resolutions[j], options);
            }
            return object;
        };

        /**
         * Converts this ChannelCloseSummary to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ClosureType enum.
         * @name lnrpc.ChannelCloseSummary.ClosureType
         * @enum {number}
         * @property {number} COOPERATIVE_CLOSE=0 COOPERATIVE_CLOSE value
         * @property {number} LOCAL_FORCE_CLOSE=1 LOCAL_FORCE_CLOSE value
         * @property {number} REMOTE_FORCE_CLOSE=2 REMOTE_FORCE_CLOSE value
         * @property {number} BREACH_CLOSE=3 BREACH_CLOSE value
         * @property {number} FUNDING_CANCELED=4 FUNDING_CANCELED value
         * @property {number} ABANDONED=5 ABANDONED value
         */
        ChannelCloseSummary.ClosureType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COOPERATIVE_CLOSE"] = 0;
            values[valuesById[1] = "LOCAL_FORCE_CLOSE"] = 1;
            values[valuesById[2] = "REMOTE_FORCE_CLOSE"] = 2;
            values[valuesById[3] = "BREACH_CLOSE"] = 3;
            values[valuesById[4] = "FUNDING_CANCELED"] = 4;
            values[valuesById[5] = "ABANDONED"] = 5;
            return values;
        })();

        return ChannelCloseSummary;
    })();

    /**
     * ResolutionType enum.
     * @name lnrpc.ResolutionType
     * @enum {number}
     * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
     * @property {number} ANCHOR=1 ANCHOR value
     * @property {number} INCOMING_HTLC=2 INCOMING_HTLC value
     * @property {number} OUTGOING_HTLC=3 OUTGOING_HTLC value
     * @property {number} COMMIT=4 COMMIT value
     */
    lnrpc.ResolutionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "ANCHOR"] = 1;
        values[valuesById[2] = "INCOMING_HTLC"] = 2;
        values[valuesById[3] = "OUTGOING_HTLC"] = 3;
        values[valuesById[4] = "COMMIT"] = 4;
        return values;
    })();

    /**
     * ResolutionOutcome enum.
     * @name lnrpc.ResolutionOutcome
     * @enum {number}
     * @property {number} OUTCOME_UNKNOWN=0 OUTCOME_UNKNOWN value
     * @property {number} CLAIMED=1 CLAIMED value
     * @property {number} UNCLAIMED=2 UNCLAIMED value
     * @property {number} ABANDONED=3 ABANDONED value
     * @property {number} FIRST_STAGE=4 FIRST_STAGE value
     * @property {number} TIMEOUT=5 TIMEOUT value
     */
    lnrpc.ResolutionOutcome = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OUTCOME_UNKNOWN"] = 0;
        values[valuesById[1] = "CLAIMED"] = 1;
        values[valuesById[2] = "UNCLAIMED"] = 2;
        values[valuesById[3] = "ABANDONED"] = 3;
        values[valuesById[4] = "FIRST_STAGE"] = 4;
        values[valuesById[5] = "TIMEOUT"] = 5;
        return values;
    })();

    lnrpc.Resolution = (function() {

        /**
         * Properties of a Resolution.
         * @memberof lnrpc
         * @interface IResolution
         * @property {lnrpc.ResolutionType|null} [resolutionType] Resolution resolutionType
         * @property {lnrpc.ResolutionOutcome|null} [outcome] Resolution outcome
         * @property {lnrpc.IOutPoint|null} [outpoint] Resolution outpoint
         * @property {number|Long|null} [amountSat] Resolution amountSat
         * @property {string|null} [sweepTxid] Resolution sweepTxid
         */

        /**
         * Constructs a new Resolution.
         * @memberof lnrpc
         * @classdesc Represents a Resolution.
         * @implements IResolution
         * @constructor
         * @param {lnrpc.IResolution=} [properties] Properties to set
         */
        function Resolution(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resolution resolutionType.
         * @member {lnrpc.ResolutionType} resolutionType
         * @memberof lnrpc.Resolution
         * @instance
         */
        Resolution.prototype.resolutionType = 0;

        /**
         * Resolution outcome.
         * @member {lnrpc.ResolutionOutcome} outcome
         * @memberof lnrpc.Resolution
         * @instance
         */
        Resolution.prototype.outcome = 0;

        /**
         * Resolution outpoint.
         * @member {lnrpc.IOutPoint|null|undefined} outpoint
         * @memberof lnrpc.Resolution
         * @instance
         */
        Resolution.prototype.outpoint = null;

        /**
         * Resolution amountSat.
         * @member {number|Long} amountSat
         * @memberof lnrpc.Resolution
         * @instance
         */
        Resolution.prototype.amountSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Resolution sweepTxid.
         * @member {string} sweepTxid
         * @memberof lnrpc.Resolution
         * @instance
         */
        Resolution.prototype.sweepTxid = "";

        /**
         * Creates a new Resolution instance using the specified properties.
         * @function create
         * @memberof lnrpc.Resolution
         * @static
         * @param {lnrpc.IResolution=} [properties] Properties to set
         * @returns {lnrpc.Resolution} Resolution instance
         */
        Resolution.create = function create(properties) {
            return new Resolution(properties);
        };

        /**
         * Encodes the specified Resolution message. Does not implicitly {@link lnrpc.Resolution.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Resolution
         * @static
         * @param {lnrpc.IResolution} message Resolution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resolution.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resolutionType != null && Object.hasOwnProperty.call(message, "resolutionType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resolutionType);
            if (message.outcome != null && Object.hasOwnProperty.call(message, "outcome"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.outcome);
            if (message.outpoint != null && Object.hasOwnProperty.call(message, "outpoint"))
                $root.lnrpc.OutPoint.encode(message.outpoint, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.amountSat != null && Object.hasOwnProperty.call(message, "amountSat"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.amountSat);
            if (message.sweepTxid != null && Object.hasOwnProperty.call(message, "sweepTxid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.sweepTxid);
            return writer;
        };

        /**
         * Encodes the specified Resolution message, length delimited. Does not implicitly {@link lnrpc.Resolution.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Resolution
         * @static
         * @param {lnrpc.IResolution} message Resolution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resolution.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resolution message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Resolution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Resolution} Resolution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resolution.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Resolution();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resolutionType = reader.int32();
                    break;
                case 2:
                    message.outcome = reader.int32();
                    break;
                case 3:
                    message.outpoint = $root.lnrpc.OutPoint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.amountSat = reader.uint64();
                    break;
                case 5:
                    message.sweepTxid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resolution message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Resolution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Resolution} Resolution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resolution.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resolution message.
         * @function verify
         * @memberof lnrpc.Resolution
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resolution.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resolutionType != null && message.hasOwnProperty("resolutionType"))
                switch (message.resolutionType) {
                default:
                    return "resolutionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.outcome != null && message.hasOwnProperty("outcome"))
                switch (message.outcome) {
                default:
                    return "outcome: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.outpoint != null && message.hasOwnProperty("outpoint")) {
                let error = $root.lnrpc.OutPoint.verify(message.outpoint);
                if (error)
                    return "outpoint." + error;
            }
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                if (!$util.isInteger(message.amountSat) && !(message.amountSat && $util.isInteger(message.amountSat.low) && $util.isInteger(message.amountSat.high)))
                    return "amountSat: integer|Long expected";
            if (message.sweepTxid != null && message.hasOwnProperty("sweepTxid"))
                if (!$util.isString(message.sweepTxid))
                    return "sweepTxid: string expected";
            return null;
        };

        /**
         * Creates a Resolution message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Resolution
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Resolution} Resolution
         */
        Resolution.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Resolution)
                return object;
            let message = new $root.lnrpc.Resolution();
            switch (object.resolutionType) {
            case "TYPE_UNKNOWN":
            case 0:
                message.resolutionType = 0;
                break;
            case "ANCHOR":
            case 1:
                message.resolutionType = 1;
                break;
            case "INCOMING_HTLC":
            case 2:
                message.resolutionType = 2;
                break;
            case "OUTGOING_HTLC":
            case 3:
                message.resolutionType = 3;
                break;
            case "COMMIT":
            case 4:
                message.resolutionType = 4;
                break;
            }
            switch (object.outcome) {
            case "OUTCOME_UNKNOWN":
            case 0:
                message.outcome = 0;
                break;
            case "CLAIMED":
            case 1:
                message.outcome = 1;
                break;
            case "UNCLAIMED":
            case 2:
                message.outcome = 2;
                break;
            case "ABANDONED":
            case 3:
                message.outcome = 3;
                break;
            case "FIRST_STAGE":
            case 4:
                message.outcome = 4;
                break;
            case "TIMEOUT":
            case 5:
                message.outcome = 5;
                break;
            }
            if (object.outpoint != null) {
                if (typeof object.outpoint !== "object")
                    throw TypeError(".lnrpc.Resolution.outpoint: object expected");
                message.outpoint = $root.lnrpc.OutPoint.fromObject(object.outpoint);
            }
            if (object.amountSat != null)
                if ($util.Long)
                    (message.amountSat = $util.Long.fromValue(object.amountSat)).unsigned = true;
                else if (typeof object.amountSat === "string")
                    message.amountSat = parseInt(object.amountSat, 10);
                else if (typeof object.amountSat === "number")
                    message.amountSat = object.amountSat;
                else if (typeof object.amountSat === "object")
                    message.amountSat = new $util.LongBits(object.amountSat.low >>> 0, object.amountSat.high >>> 0).toNumber(true);
            if (object.sweepTxid != null)
                message.sweepTxid = String(object.sweepTxid);
            return message;
        };

        /**
         * Creates a plain object from a Resolution message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Resolution
         * @static
         * @param {lnrpc.Resolution} message Resolution
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resolution.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.resolutionType = options.enums === String ? "TYPE_UNKNOWN" : 0;
                object.outcome = options.enums === String ? "OUTCOME_UNKNOWN" : 0;
                object.outpoint = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amountSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amountSat = options.longs === String ? "0" : 0;
                object.sweepTxid = "";
            }
            if (message.resolutionType != null && message.hasOwnProperty("resolutionType"))
                object.resolutionType = options.enums === String ? $root.lnrpc.ResolutionType[message.resolutionType] : message.resolutionType;
            if (message.outcome != null && message.hasOwnProperty("outcome"))
                object.outcome = options.enums === String ? $root.lnrpc.ResolutionOutcome[message.outcome] : message.outcome;
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                object.outpoint = $root.lnrpc.OutPoint.toObject(message.outpoint, options);
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                if (typeof message.amountSat === "number")
                    object.amountSat = options.longs === String ? String(message.amountSat) : message.amountSat;
                else
                    object.amountSat = options.longs === String ? $util.Long.prototype.toString.call(message.amountSat) : options.longs === Number ? new $util.LongBits(message.amountSat.low >>> 0, message.amountSat.high >>> 0).toNumber(true) : message.amountSat;
            if (message.sweepTxid != null && message.hasOwnProperty("sweepTxid"))
                object.sweepTxid = message.sweepTxid;
            return object;
        };

        /**
         * Converts this Resolution to JSON.
         * @function toJSON
         * @memberof lnrpc.Resolution
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resolution.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Resolution;
    })();

    lnrpc.ClosedChannelsRequest = (function() {

        /**
         * Properties of a ClosedChannelsRequest.
         * @memberof lnrpc
         * @interface IClosedChannelsRequest
         * @property {boolean|null} [cooperative] ClosedChannelsRequest cooperative
         * @property {boolean|null} [localForce] ClosedChannelsRequest localForce
         * @property {boolean|null} [remoteForce] ClosedChannelsRequest remoteForce
         * @property {boolean|null} [breach] ClosedChannelsRequest breach
         * @property {boolean|null} [fundingCanceled] ClosedChannelsRequest fundingCanceled
         * @property {boolean|null} [abandoned] ClosedChannelsRequest abandoned
         */

        /**
         * Constructs a new ClosedChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelsRequest.
         * @implements IClosedChannelsRequest
         * @constructor
         * @param {lnrpc.IClosedChannelsRequest=} [properties] Properties to set
         */
        function ClosedChannelsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelsRequest cooperative.
         * @member {boolean} cooperative
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.cooperative = false;

        /**
         * ClosedChannelsRequest localForce.
         * @member {boolean} localForce
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.localForce = false;

        /**
         * ClosedChannelsRequest remoteForce.
         * @member {boolean} remoteForce
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.remoteForce = false;

        /**
         * ClosedChannelsRequest breach.
         * @member {boolean} breach
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.breach = false;

        /**
         * ClosedChannelsRequest fundingCanceled.
         * @member {boolean} fundingCanceled
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.fundingCanceled = false;

        /**
         * ClosedChannelsRequest abandoned.
         * @member {boolean} abandoned
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.abandoned = false;

        /**
         * Creates a new ClosedChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest instance
         */
        ClosedChannelsRequest.create = function create(properties) {
            return new ClosedChannelsRequest(properties);
        };

        /**
         * Encodes the specified ClosedChannelsRequest message. Does not implicitly {@link lnrpc.ClosedChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest} message ClosedChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cooperative != null && Object.hasOwnProperty.call(message, "cooperative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.cooperative);
            if (message.localForce != null && Object.hasOwnProperty.call(message, "localForce"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.localForce);
            if (message.remoteForce != null && Object.hasOwnProperty.call(message, "remoteForce"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.remoteForce);
            if (message.breach != null && Object.hasOwnProperty.call(message, "breach"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.breach);
            if (message.fundingCanceled != null && Object.hasOwnProperty.call(message, "fundingCanceled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fundingCanceled);
            if (message.abandoned != null && Object.hasOwnProperty.call(message, "abandoned"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.abandoned);
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest} message ClosedChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cooperative = reader.bool();
                    break;
                case 2:
                    message.localForce = reader.bool();
                    break;
                case 3:
                    message.remoteForce = reader.bool();
                    break;
                case 4:
                    message.breach = reader.bool();
                    break;
                case 5:
                    message.fundingCanceled = reader.bool();
                    break;
                case 6:
                    message.abandoned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelsRequest message.
         * @function verify
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                if (typeof message.cooperative !== "boolean")
                    return "cooperative: boolean expected";
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                if (typeof message.localForce !== "boolean")
                    return "localForce: boolean expected";
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                if (typeof message.remoteForce !== "boolean")
                    return "remoteForce: boolean expected";
            if (message.breach != null && message.hasOwnProperty("breach"))
                if (typeof message.breach !== "boolean")
                    return "breach: boolean expected";
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                if (typeof message.fundingCanceled !== "boolean")
                    return "fundingCanceled: boolean expected";
            if (message.abandoned != null && message.hasOwnProperty("abandoned"))
                if (typeof message.abandoned !== "boolean")
                    return "abandoned: boolean expected";
            return null;
        };

        /**
         * Creates a ClosedChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         */
        ClosedChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelsRequest)
                return object;
            let message = new $root.lnrpc.ClosedChannelsRequest();
            if (object.cooperative != null)
                message.cooperative = Boolean(object.cooperative);
            if (object.localForce != null)
                message.localForce = Boolean(object.localForce);
            if (object.remoteForce != null)
                message.remoteForce = Boolean(object.remoteForce);
            if (object.breach != null)
                message.breach = Boolean(object.breach);
            if (object.fundingCanceled != null)
                message.fundingCanceled = Boolean(object.fundingCanceled);
            if (object.abandoned != null)
                message.abandoned = Boolean(object.abandoned);
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.ClosedChannelsRequest} message ClosedChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cooperative = false;
                object.localForce = false;
                object.remoteForce = false;
                object.breach = false;
                object.fundingCanceled = false;
                object.abandoned = false;
            }
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                object.cooperative = message.cooperative;
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                object.localForce = message.localForce;
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                object.remoteForce = message.remoteForce;
            if (message.breach != null && message.hasOwnProperty("breach"))
                object.breach = message.breach;
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                object.fundingCanceled = message.fundingCanceled;
            if (message.abandoned != null && message.hasOwnProperty("abandoned"))
                object.abandoned = message.abandoned;
            return object;
        };

        /**
         * Converts this ClosedChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelsRequest;
    })();

    lnrpc.ClosedChannelsResponse = (function() {

        /**
         * Properties of a ClosedChannelsResponse.
         * @memberof lnrpc
         * @interface IClosedChannelsResponse
         * @property {Array.<lnrpc.IChannelCloseSummary>|null} [channels] ClosedChannelsResponse channels
         */

        /**
         * Constructs a new ClosedChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelsResponse.
         * @implements IClosedChannelsResponse
         * @constructor
         * @param {lnrpc.IClosedChannelsResponse=} [properties] Properties to set
         */
        function ClosedChannelsResponse(properties) {
            this.channels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelsResponse channels.
         * @member {Array.<lnrpc.IChannelCloseSummary>} channels
         * @memberof lnrpc.ClosedChannelsResponse
         * @instance
         */
        ClosedChannelsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ClosedChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse instance
         */
        ClosedChannelsResponse.create = function create(properties) {
            return new ClosedChannelsResponse(properties);
        };

        /**
         * Encodes the specified ClosedChannelsResponse message. Does not implicitly {@link lnrpc.ClosedChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse} message ClosedChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.ChannelCloseSummary.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse} message ClosedChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.ChannelCloseSummary.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelsResponse message.
         * @function verify
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.lnrpc.ChannelCloseSummary.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClosedChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         */
        ClosedChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelsResponse)
                return object;
            let message = new $root.lnrpc.ClosedChannelsResponse();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.ClosedChannelsResponse.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.ClosedChannelsResponse.channels: object expected");
                    message.channels[i] = $root.lnrpc.ChannelCloseSummary.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.ClosedChannelsResponse} message ClosedChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.ChannelCloseSummary.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this ClosedChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelsResponse;
    })();

    lnrpc.Peer = (function() {

        /**
         * Properties of a Peer.
         * @memberof lnrpc
         * @interface IPeer
         * @property {string|null} [pubKey] Peer pubKey
         * @property {string|null} [address] Peer address
         * @property {number|Long|null} [bytesSent] Peer bytesSent
         * @property {number|Long|null} [bytesRecv] Peer bytesRecv
         * @property {number|Long|null} [satSent] Peer satSent
         * @property {number|Long|null} [satRecv] Peer satRecv
         * @property {boolean|null} [inbound] Peer inbound
         * @property {number|Long|null} [pingTime] Peer pingTime
         * @property {lnrpc.Peer.SyncType|null} [syncType] Peer syncType
         * @property {Object.<string,lnrpc.IFeature>|null} [features] Peer features
         * @property {Array.<lnrpc.ITimestampedError>|null} [errors] Peer errors
         * @property {number|null} [flapCount] Peer flapCount
         * @property {number|Long|null} [lastFlapNs] Peer lastFlapNs
         */

        /**
         * Constructs a new Peer.
         * @memberof lnrpc
         * @classdesc Represents a Peer.
         * @implements IPeer
         * @constructor
         * @param {lnrpc.IPeer=} [properties] Properties to set
         */
        function Peer(properties) {
            this.features = {};
            this.errors = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Peer pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.pubKey = "";

        /**
         * Peer address.
         * @member {string} address
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.address = "";

        /**
         * Peer bytesSent.
         * @member {number|Long} bytesSent
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.bytesSent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Peer bytesRecv.
         * @member {number|Long} bytesRecv
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.bytesRecv = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Peer satSent.
         * @member {number|Long} satSent
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.satSent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Peer satRecv.
         * @member {number|Long} satRecv
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.satRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Peer inbound.
         * @member {boolean} inbound
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.inbound = false;

        /**
         * Peer pingTime.
         * @member {number|Long} pingTime
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.pingTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Peer syncType.
         * @member {lnrpc.Peer.SyncType} syncType
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.syncType = 0;

        /**
         * Peer features.
         * @member {Object.<string,lnrpc.IFeature>} features
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.features = $util.emptyObject;

        /**
         * Peer errors.
         * @member {Array.<lnrpc.ITimestampedError>} errors
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.errors = $util.emptyArray;

        /**
         * Peer flapCount.
         * @member {number} flapCount
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.flapCount = 0;

        /**
         * Peer lastFlapNs.
         * @member {number|Long} lastFlapNs
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.lastFlapNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Peer instance using the specified properties.
         * @function create
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer=} [properties] Properties to set
         * @returns {lnrpc.Peer} Peer instance
         */
        Peer.create = function create(properties) {
            return new Peer(properties);
        };

        /**
         * Encodes the specified Peer message. Does not implicitly {@link lnrpc.Peer.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer} message Peer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Peer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            if (message.bytesSent != null && Object.hasOwnProperty.call(message, "bytesSent"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.bytesSent);
            if (message.bytesRecv != null && Object.hasOwnProperty.call(message, "bytesRecv"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.bytesRecv);
            if (message.satSent != null && Object.hasOwnProperty.call(message, "satSent"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.satSent);
            if (message.satRecv != null && Object.hasOwnProperty.call(message, "satRecv"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.satRecv);
            if (message.inbound != null && Object.hasOwnProperty.call(message, "inbound"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.inbound);
            if (message.pingTime != null && Object.hasOwnProperty.call(message, "pingTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.pingTime);
            if (message.syncType != null && Object.hasOwnProperty.call(message, "syncType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.syncType);
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.lnrpc.Feature.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.errors != null && message.errors.length)
                for (let i = 0; i < message.errors.length; ++i)
                    $root.lnrpc.TimestampedError.encode(message.errors[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.flapCount != null && Object.hasOwnProperty.call(message, "flapCount"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.flapCount);
            if (message.lastFlapNs != null && Object.hasOwnProperty.call(message, "lastFlapNs"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.lastFlapNs);
            return writer;
        };

        /**
         * Encodes the specified Peer message, length delimited. Does not implicitly {@link lnrpc.Peer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer} message Peer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Peer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Peer message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Peer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Peer} Peer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Peer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Peer(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                case 4:
                    message.bytesSent = reader.uint64();
                    break;
                case 5:
                    message.bytesRecv = reader.uint64();
                    break;
                case 6:
                    message.satSent = reader.int64();
                    break;
                case 7:
                    message.satRecv = reader.int64();
                    break;
                case 8:
                    message.inbound = reader.bool();
                    break;
                case 9:
                    message.pingTime = reader.int64();
                    break;
                case 10:
                    message.syncType = reader.int32();
                    break;
                case 11:
                    if (message.features === $util.emptyObject)
                        message.features = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint32();
                            break;
                        case 2:
                            value = $root.lnrpc.Feature.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.features[key] = value;
                    break;
                case 12:
                    if (!(message.errors && message.errors.length))
                        message.errors = [];
                    message.errors.push($root.lnrpc.TimestampedError.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.flapCount = reader.int32();
                    break;
                case 14:
                    message.lastFlapNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Peer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Peer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Peer} Peer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Peer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Peer message.
         * @function verify
         * @memberof lnrpc.Peer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Peer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (!$util.isInteger(message.bytesSent) && !(message.bytesSent && $util.isInteger(message.bytesSent.low) && $util.isInteger(message.bytesSent.high)))
                    return "bytesSent: integer|Long expected";
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                if (!$util.isInteger(message.bytesRecv) && !(message.bytesRecv && $util.isInteger(message.bytesRecv.low) && $util.isInteger(message.bytesRecv.high)))
                    return "bytesRecv: integer|Long expected";
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                if (!$util.isInteger(message.satSent) && !(message.satSent && $util.isInteger(message.satSent.low) && $util.isInteger(message.satSent.high)))
                    return "satSent: integer|Long expected";
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                if (!$util.isInteger(message.satRecv) && !(message.satRecv && $util.isInteger(message.satRecv.low) && $util.isInteger(message.satRecv.high)))
                    return "satRecv: integer|Long expected";
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                if (typeof message.inbound !== "boolean")
                    return "inbound: boolean expected";
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                if (!$util.isInteger(message.pingTime) && !(message.pingTime && $util.isInteger(message.pingTime.low) && $util.isInteger(message.pingTime.high)))
                    return "pingTime: integer|Long expected";
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                switch (message.syncType) {
                default:
                    return "syncType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "features: integer key{k:uint32} expected";
                    {
                        let error = $root.lnrpc.Feature.verify(message.features[key[i]]);
                        if (error)
                            return "features." + error;
                    }
                }
            }
            if (message.errors != null && message.hasOwnProperty("errors")) {
                if (!Array.isArray(message.errors))
                    return "errors: array expected";
                for (let i = 0; i < message.errors.length; ++i) {
                    let error = $root.lnrpc.TimestampedError.verify(message.errors[i]);
                    if (error)
                        return "errors." + error;
                }
            }
            if (message.flapCount != null && message.hasOwnProperty("flapCount"))
                if (!$util.isInteger(message.flapCount))
                    return "flapCount: integer expected";
            if (message.lastFlapNs != null && message.hasOwnProperty("lastFlapNs"))
                if (!$util.isInteger(message.lastFlapNs) && !(message.lastFlapNs && $util.isInteger(message.lastFlapNs.low) && $util.isInteger(message.lastFlapNs.high)))
                    return "lastFlapNs: integer|Long expected";
            return null;
        };

        /**
         * Creates a Peer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Peer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Peer} Peer
         */
        Peer.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Peer)
                return object;
            let message = new $root.lnrpc.Peer();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.address != null)
                message.address = String(object.address);
            if (object.bytesSent != null)
                if ($util.Long)
                    (message.bytesSent = $util.Long.fromValue(object.bytesSent)).unsigned = true;
                else if (typeof object.bytesSent === "string")
                    message.bytesSent = parseInt(object.bytesSent, 10);
                else if (typeof object.bytesSent === "number")
                    message.bytesSent = object.bytesSent;
                else if (typeof object.bytesSent === "object")
                    message.bytesSent = new $util.LongBits(object.bytesSent.low >>> 0, object.bytesSent.high >>> 0).toNumber(true);
            if (object.bytesRecv != null)
                if ($util.Long)
                    (message.bytesRecv = $util.Long.fromValue(object.bytesRecv)).unsigned = true;
                else if (typeof object.bytesRecv === "string")
                    message.bytesRecv = parseInt(object.bytesRecv, 10);
                else if (typeof object.bytesRecv === "number")
                    message.bytesRecv = object.bytesRecv;
                else if (typeof object.bytesRecv === "object")
                    message.bytesRecv = new $util.LongBits(object.bytesRecv.low >>> 0, object.bytesRecv.high >>> 0).toNumber(true);
            if (object.satSent != null)
                if ($util.Long)
                    (message.satSent = $util.Long.fromValue(object.satSent)).unsigned = false;
                else if (typeof object.satSent === "string")
                    message.satSent = parseInt(object.satSent, 10);
                else if (typeof object.satSent === "number")
                    message.satSent = object.satSent;
                else if (typeof object.satSent === "object")
                    message.satSent = new $util.LongBits(object.satSent.low >>> 0, object.satSent.high >>> 0).toNumber();
            if (object.satRecv != null)
                if ($util.Long)
                    (message.satRecv = $util.Long.fromValue(object.satRecv)).unsigned = false;
                else if (typeof object.satRecv === "string")
                    message.satRecv = parseInt(object.satRecv, 10);
                else if (typeof object.satRecv === "number")
                    message.satRecv = object.satRecv;
                else if (typeof object.satRecv === "object")
                    message.satRecv = new $util.LongBits(object.satRecv.low >>> 0, object.satRecv.high >>> 0).toNumber();
            if (object.inbound != null)
                message.inbound = Boolean(object.inbound);
            if (object.pingTime != null)
                if ($util.Long)
                    (message.pingTime = $util.Long.fromValue(object.pingTime)).unsigned = false;
                else if (typeof object.pingTime === "string")
                    message.pingTime = parseInt(object.pingTime, 10);
                else if (typeof object.pingTime === "number")
                    message.pingTime = object.pingTime;
                else if (typeof object.pingTime === "object")
                    message.pingTime = new $util.LongBits(object.pingTime.low >>> 0, object.pingTime.high >>> 0).toNumber();
            switch (object.syncType) {
            case "UNKNOWN_SYNC":
            case 0:
                message.syncType = 0;
                break;
            case "ACTIVE_SYNC":
            case 1:
                message.syncType = 1;
                break;
            case "PASSIVE_SYNC":
            case 2:
                message.syncType = 2;
                break;
            }
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".lnrpc.Peer.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".lnrpc.Peer.features: object expected");
                    message.features[keys[i]] = $root.lnrpc.Feature.fromObject(object.features[keys[i]]);
                }
            }
            if (object.errors) {
                if (!Array.isArray(object.errors))
                    throw TypeError(".lnrpc.Peer.errors: array expected");
                message.errors = [];
                for (let i = 0; i < object.errors.length; ++i) {
                    if (typeof object.errors[i] !== "object")
                        throw TypeError(".lnrpc.Peer.errors: object expected");
                    message.errors[i] = $root.lnrpc.TimestampedError.fromObject(object.errors[i]);
                }
            }
            if (object.flapCount != null)
                message.flapCount = object.flapCount | 0;
            if (object.lastFlapNs != null)
                if ($util.Long)
                    (message.lastFlapNs = $util.Long.fromValue(object.lastFlapNs)).unsigned = false;
                else if (typeof object.lastFlapNs === "string")
                    message.lastFlapNs = parseInt(object.lastFlapNs, 10);
                else if (typeof object.lastFlapNs === "number")
                    message.lastFlapNs = object.lastFlapNs;
                else if (typeof object.lastFlapNs === "object")
                    message.lastFlapNs = new $util.LongBits(object.lastFlapNs.low >>> 0, object.lastFlapNs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Peer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.Peer} message Peer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Peer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.errors = [];
            if (options.objects || options.defaults)
                object.features = {};
            if (options.defaults) {
                object.pubKey = "";
                object.address = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.bytesSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.bytesRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesRecv = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satRecv = options.longs === String ? "0" : 0;
                object.inbound = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pingTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pingTime = options.longs === String ? "0" : 0;
                object.syncType = options.enums === String ? "UNKNOWN_SYNC" : 0;
                object.flapCount = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastFlapNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastFlapNs = options.longs === String ? "0" : 0;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (typeof message.bytesSent === "number")
                    object.bytesSent = options.longs === String ? String(message.bytesSent) : message.bytesSent;
                else
                    object.bytesSent = options.longs === String ? $util.Long.prototype.toString.call(message.bytesSent) : options.longs === Number ? new $util.LongBits(message.bytesSent.low >>> 0, message.bytesSent.high >>> 0).toNumber(true) : message.bytesSent;
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                if (typeof message.bytesRecv === "number")
                    object.bytesRecv = options.longs === String ? String(message.bytesRecv) : message.bytesRecv;
                else
                    object.bytesRecv = options.longs === String ? $util.Long.prototype.toString.call(message.bytesRecv) : options.longs === Number ? new $util.LongBits(message.bytesRecv.low >>> 0, message.bytesRecv.high >>> 0).toNumber(true) : message.bytesRecv;
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                if (typeof message.satSent === "number")
                    object.satSent = options.longs === String ? String(message.satSent) : message.satSent;
                else
                    object.satSent = options.longs === String ? $util.Long.prototype.toString.call(message.satSent) : options.longs === Number ? new $util.LongBits(message.satSent.low >>> 0, message.satSent.high >>> 0).toNumber() : message.satSent;
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                if (typeof message.satRecv === "number")
                    object.satRecv = options.longs === String ? String(message.satRecv) : message.satRecv;
                else
                    object.satRecv = options.longs === String ? $util.Long.prototype.toString.call(message.satRecv) : options.longs === Number ? new $util.LongBits(message.satRecv.low >>> 0, message.satRecv.high >>> 0).toNumber() : message.satRecv;
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                object.inbound = message.inbound;
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                if (typeof message.pingTime === "number")
                    object.pingTime = options.longs === String ? String(message.pingTime) : message.pingTime;
                else
                    object.pingTime = options.longs === String ? $util.Long.prototype.toString.call(message.pingTime) : options.longs === Number ? new $util.LongBits(message.pingTime.low >>> 0, message.pingTime.high >>> 0).toNumber() : message.pingTime;
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                object.syncType = options.enums === String ? $root.lnrpc.Peer.SyncType[message.syncType] : message.syncType;
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.lnrpc.Feature.toObject(message.features[keys2[j]], options);
            }
            if (message.errors && message.errors.length) {
                object.errors = [];
                for (let j = 0; j < message.errors.length; ++j)
                    object.errors[j] = $root.lnrpc.TimestampedError.toObject(message.errors[j], options);
            }
            if (message.flapCount != null && message.hasOwnProperty("flapCount"))
                object.flapCount = message.flapCount;
            if (message.lastFlapNs != null && message.hasOwnProperty("lastFlapNs"))
                if (typeof message.lastFlapNs === "number")
                    object.lastFlapNs = options.longs === String ? String(message.lastFlapNs) : message.lastFlapNs;
                else
                    object.lastFlapNs = options.longs === String ? $util.Long.prototype.toString.call(message.lastFlapNs) : options.longs === Number ? new $util.LongBits(message.lastFlapNs.low >>> 0, message.lastFlapNs.high >>> 0).toNumber() : message.lastFlapNs;
            return object;
        };

        /**
         * Converts this Peer to JSON.
         * @function toJSON
         * @memberof lnrpc.Peer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Peer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * SyncType enum.
         * @name lnrpc.Peer.SyncType
         * @enum {number}
         * @property {number} UNKNOWN_SYNC=0 UNKNOWN_SYNC value
         * @property {number} ACTIVE_SYNC=1 ACTIVE_SYNC value
         * @property {number} PASSIVE_SYNC=2 PASSIVE_SYNC value
         */
        Peer.SyncType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_SYNC"] = 0;
            values[valuesById[1] = "ACTIVE_SYNC"] = 1;
            values[valuesById[2] = "PASSIVE_SYNC"] = 2;
            return values;
        })();

        return Peer;
    })();

    lnrpc.TimestampedError = (function() {

        /**
         * Properties of a TimestampedError.
         * @memberof lnrpc
         * @interface ITimestampedError
         * @property {number|Long|null} [timestamp] TimestampedError timestamp
         * @property {string|null} [error] TimestampedError error
         */

        /**
         * Constructs a new TimestampedError.
         * @memberof lnrpc
         * @classdesc Represents a TimestampedError.
         * @implements ITimestampedError
         * @constructor
         * @param {lnrpc.ITimestampedError=} [properties] Properties to set
         */
        function TimestampedError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimestampedError timestamp.
         * @member {number|Long} timestamp
         * @memberof lnrpc.TimestampedError
         * @instance
         */
        TimestampedError.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TimestampedError error.
         * @member {string} error
         * @memberof lnrpc.TimestampedError
         * @instance
         */
        TimestampedError.prototype.error = "";

        /**
         * Creates a new TimestampedError instance using the specified properties.
         * @function create
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {lnrpc.ITimestampedError=} [properties] Properties to set
         * @returns {lnrpc.TimestampedError} TimestampedError instance
         */
        TimestampedError.create = function create(properties) {
            return new TimestampedError(properties);
        };

        /**
         * Encodes the specified TimestampedError message. Does not implicitly {@link lnrpc.TimestampedError.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {lnrpc.ITimestampedError} message TimestampedError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampedError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
            return writer;
        };

        /**
         * Encodes the specified TimestampedError message, length delimited. Does not implicitly {@link lnrpc.TimestampedError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {lnrpc.ITimestampedError} message TimestampedError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampedError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimestampedError message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.TimestampedError} TimestampedError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampedError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.TimestampedError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TimestampedError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.TimestampedError} TimestampedError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampedError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimestampedError message.
         * @function verify
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimestampedError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.error != null && message.hasOwnProperty("error"))
                if (!$util.isString(message.error))
                    return "error: string expected";
            return null;
        };

        /**
         * Creates a TimestampedError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.TimestampedError} TimestampedError
         */
        TimestampedError.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.TimestampedError)
                return object;
            let message = new $root.lnrpc.TimestampedError();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.error != null)
                message.error = String(object.error);
            return message;
        };

        /**
         * Creates a plain object from a TimestampedError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.TimestampedError
         * @static
         * @param {lnrpc.TimestampedError} message TimestampedError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimestampedError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.error = "";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = message.error;
            return object;
        };

        /**
         * Converts this TimestampedError to JSON.
         * @function toJSON
         * @memberof lnrpc.TimestampedError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimestampedError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimestampedError;
    })();

    lnrpc.ListPeersRequest = (function() {

        /**
         * Properties of a ListPeersRequest.
         * @memberof lnrpc
         * @interface IListPeersRequest
         * @property {boolean|null} [latestError] ListPeersRequest latestError
         */

        /**
         * Constructs a new ListPeersRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPeersRequest.
         * @implements IListPeersRequest
         * @constructor
         * @param {lnrpc.IListPeersRequest=} [properties] Properties to set
         */
        function ListPeersRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPeersRequest latestError.
         * @member {boolean} latestError
         * @memberof lnrpc.ListPeersRequest
         * @instance
         */
        ListPeersRequest.prototype.latestError = false;

        /**
         * Creates a new ListPeersRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest instance
         */
        ListPeersRequest.create = function create(properties) {
            return new ListPeersRequest(properties);
        };

        /**
         * Encodes the specified ListPeersRequest message. Does not implicitly {@link lnrpc.ListPeersRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest} message ListPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.latestError != null && Object.hasOwnProperty.call(message, "latestError"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.latestError);
            return writer;
        };

        /**
         * Encodes the specified ListPeersRequest message, length delimited. Does not implicitly {@link lnrpc.ListPeersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest} message ListPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPeersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPeersRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.latestError = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPeersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPeersRequest message.
         * @function verify
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPeersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.latestError != null && message.hasOwnProperty("latestError"))
                if (typeof message.latestError !== "boolean")
                    return "latestError: boolean expected";
            return null;
        };

        /**
         * Creates a ListPeersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         */
        ListPeersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPeersRequest)
                return object;
            let message = new $root.lnrpc.ListPeersRequest();
            if (object.latestError != null)
                message.latestError = Boolean(object.latestError);
            return message;
        };

        /**
         * Creates a plain object from a ListPeersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.ListPeersRequest} message ListPeersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPeersRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.latestError = false;
            if (message.latestError != null && message.hasOwnProperty("latestError"))
                object.latestError = message.latestError;
            return object;
        };

        /**
         * Converts this ListPeersRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPeersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPeersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPeersRequest;
    })();

    lnrpc.ListPeersResponse = (function() {

        /**
         * Properties of a ListPeersResponse.
         * @memberof lnrpc
         * @interface IListPeersResponse
         * @property {Array.<lnrpc.IPeer>|null} [peers] ListPeersResponse peers
         */

        /**
         * Constructs a new ListPeersResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPeersResponse.
         * @implements IListPeersResponse
         * @constructor
         * @param {lnrpc.IListPeersResponse=} [properties] Properties to set
         */
        function ListPeersResponse(properties) {
            this.peers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPeersResponse peers.
         * @member {Array.<lnrpc.IPeer>} peers
         * @memberof lnrpc.ListPeersResponse
         * @instance
         */
        ListPeersResponse.prototype.peers = $util.emptyArray;

        /**
         * Creates a new ListPeersResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse instance
         */
        ListPeersResponse.create = function create(properties) {
            return new ListPeersResponse(properties);
        };

        /**
         * Encodes the specified ListPeersResponse message. Does not implicitly {@link lnrpc.ListPeersResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse} message ListPeersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peers != null && message.peers.length)
                for (let i = 0; i < message.peers.length; ++i)
                    $root.lnrpc.Peer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListPeersResponse message, length delimited. Does not implicitly {@link lnrpc.ListPeersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse} message ListPeersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPeersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPeersResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.peers && message.peers.length))
                        message.peers = [];
                    message.peers.push($root.lnrpc.Peer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPeersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPeersResponse message.
         * @function verify
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPeersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peers != null && message.hasOwnProperty("peers")) {
                if (!Array.isArray(message.peers))
                    return "peers: array expected";
                for (let i = 0; i < message.peers.length; ++i) {
                    let error = $root.lnrpc.Peer.verify(message.peers[i]);
                    if (error)
                        return "peers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPeersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         */
        ListPeersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPeersResponse)
                return object;
            let message = new $root.lnrpc.ListPeersResponse();
            if (object.peers) {
                if (!Array.isArray(object.peers))
                    throw TypeError(".lnrpc.ListPeersResponse.peers: array expected");
                message.peers = [];
                for (let i = 0; i < object.peers.length; ++i) {
                    if (typeof object.peers[i] !== "object")
                        throw TypeError(".lnrpc.ListPeersResponse.peers: object expected");
                    message.peers[i] = $root.lnrpc.Peer.fromObject(object.peers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPeersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.ListPeersResponse} message ListPeersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPeersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.peers = [];
            if (message.peers && message.peers.length) {
                object.peers = [];
                for (let j = 0; j < message.peers.length; ++j)
                    object.peers[j] = $root.lnrpc.Peer.toObject(message.peers[j], options);
            }
            return object;
        };

        /**
         * Converts this ListPeersResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPeersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPeersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPeersResponse;
    })();

    lnrpc.PeerEventSubscription = (function() {

        /**
         * Properties of a PeerEventSubscription.
         * @memberof lnrpc
         * @interface IPeerEventSubscription
         */

        /**
         * Constructs a new PeerEventSubscription.
         * @memberof lnrpc
         * @classdesc Represents a PeerEventSubscription.
         * @implements IPeerEventSubscription
         * @constructor
         * @param {lnrpc.IPeerEventSubscription=} [properties] Properties to set
         */
        function PeerEventSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PeerEventSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {lnrpc.IPeerEventSubscription=} [properties] Properties to set
         * @returns {lnrpc.PeerEventSubscription} PeerEventSubscription instance
         */
        PeerEventSubscription.create = function create(properties) {
            return new PeerEventSubscription(properties);
        };

        /**
         * Encodes the specified PeerEventSubscription message. Does not implicitly {@link lnrpc.PeerEventSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {lnrpc.IPeerEventSubscription} message PeerEventSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerEventSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PeerEventSubscription message, length delimited. Does not implicitly {@link lnrpc.PeerEventSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {lnrpc.IPeerEventSubscription} message PeerEventSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerEventSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PeerEventSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PeerEventSubscription} PeerEventSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerEventSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PeerEventSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeerEventSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PeerEventSubscription} PeerEventSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerEventSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PeerEventSubscription message.
         * @function verify
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PeerEventSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PeerEventSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PeerEventSubscription} PeerEventSubscription
         */
        PeerEventSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PeerEventSubscription)
                return object;
            return new $root.lnrpc.PeerEventSubscription();
        };

        /**
         * Creates a plain object from a PeerEventSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PeerEventSubscription
         * @static
         * @param {lnrpc.PeerEventSubscription} message PeerEventSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PeerEventSubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PeerEventSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.PeerEventSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PeerEventSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PeerEventSubscription;
    })();

    lnrpc.PeerEvent = (function() {

        /**
         * Properties of a PeerEvent.
         * @memberof lnrpc
         * @interface IPeerEvent
         * @property {string|null} [pubKey] PeerEvent pubKey
         * @property {lnrpc.PeerEvent.EventType|null} [type] PeerEvent type
         */

        /**
         * Constructs a new PeerEvent.
         * @memberof lnrpc
         * @classdesc Represents a PeerEvent.
         * @implements IPeerEvent
         * @constructor
         * @param {lnrpc.IPeerEvent=} [properties] Properties to set
         */
        function PeerEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PeerEvent pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.PeerEvent
         * @instance
         */
        PeerEvent.prototype.pubKey = "";

        /**
         * PeerEvent type.
         * @member {lnrpc.PeerEvent.EventType} type
         * @memberof lnrpc.PeerEvent
         * @instance
         */
        PeerEvent.prototype.type = 0;

        /**
         * Creates a new PeerEvent instance using the specified properties.
         * @function create
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {lnrpc.IPeerEvent=} [properties] Properties to set
         * @returns {lnrpc.PeerEvent} PeerEvent instance
         */
        PeerEvent.create = function create(properties) {
            return new PeerEvent(properties);
        };

        /**
         * Encodes the specified PeerEvent message. Does not implicitly {@link lnrpc.PeerEvent.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {lnrpc.IPeerEvent} message PeerEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified PeerEvent message, length delimited. Does not implicitly {@link lnrpc.PeerEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {lnrpc.IPeerEvent} message PeerEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeerEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PeerEvent message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PeerEvent} PeerEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PeerEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeerEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PeerEvent} PeerEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeerEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PeerEvent message.
         * @function verify
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PeerEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PeerEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PeerEvent} PeerEvent
         */
        PeerEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PeerEvent)
                return object;
            let message = new $root.lnrpc.PeerEvent();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            switch (object.type) {
            case "PEER_ONLINE":
            case 0:
                message.type = 0;
                break;
            case "PEER_OFFLINE":
            case 1:
                message.type = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PeerEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PeerEvent
         * @static
         * @param {lnrpc.PeerEvent} message PeerEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PeerEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pubKey = "";
                object.type = options.enums === String ? "PEER_ONLINE" : 0;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.PeerEvent.EventType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this PeerEvent to JSON.
         * @function toJSON
         * @memberof lnrpc.PeerEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PeerEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * EventType enum.
         * @name lnrpc.PeerEvent.EventType
         * @enum {number}
         * @property {number} PEER_ONLINE=0 PEER_ONLINE value
         * @property {number} PEER_OFFLINE=1 PEER_OFFLINE value
         */
        PeerEvent.EventType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PEER_ONLINE"] = 0;
            values[valuesById[1] = "PEER_OFFLINE"] = 1;
            return values;
        })();

        return PeerEvent;
    })();

    lnrpc.GetInfoRequest = (function() {

        /**
         * Properties of a GetInfoRequest.
         * @memberof lnrpc
         * @interface IGetInfoRequest
         */

        /**
         * Constructs a new GetInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetInfoRequest.
         * @implements IGetInfoRequest
         * @constructor
         * @param {lnrpc.IGetInfoRequest=} [properties] Properties to set
         */
        function GetInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest instance
         */
        GetInfoRequest.create = function create(properties) {
            return new GetInfoRequest(properties);
        };

        /**
         * Encodes the specified GetInfoRequest message. Does not implicitly {@link lnrpc.GetInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest} message GetInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetInfoRequest message, length delimited. Does not implicitly {@link lnrpc.GetInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest} message GetInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetInfoRequest message.
         * @function verify
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         */
        GetInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetInfoRequest)
                return object;
            return new $root.lnrpc.GetInfoRequest();
        };

        /**
         * Creates a plain object from a GetInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.GetInfoRequest} message GetInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetInfoRequest;
    })();

    lnrpc.GetInfoResponse = (function() {

        /**
         * Properties of a GetInfoResponse.
         * @memberof lnrpc
         * @interface IGetInfoResponse
         * @property {string|null} [version] GetInfoResponse version
         * @property {string|null} [commitHash] GetInfoResponse commitHash
         * @property {string|null} [identityPubkey] GetInfoResponse identityPubkey
         * @property {string|null} [alias] GetInfoResponse alias
         * @property {string|null} [color] GetInfoResponse color
         * @property {number|null} [numPendingChannels] GetInfoResponse numPendingChannels
         * @property {number|null} [numActiveChannels] GetInfoResponse numActiveChannels
         * @property {number|null} [numInactiveChannels] GetInfoResponse numInactiveChannels
         * @property {number|null} [numPeers] GetInfoResponse numPeers
         * @property {number|null} [blockHeight] GetInfoResponse blockHeight
         * @property {string|null} [blockHash] GetInfoResponse blockHash
         * @property {number|Long|null} [bestHeaderTimestamp] GetInfoResponse bestHeaderTimestamp
         * @property {boolean|null} [syncedToChain] GetInfoResponse syncedToChain
         * @property {boolean|null} [syncedToGraph] GetInfoResponse syncedToGraph
         * @property {boolean|null} [testnet] GetInfoResponse testnet
         * @property {Array.<lnrpc.IChain>|null} [chains] GetInfoResponse chains
         * @property {Array.<string>|null} [uris] GetInfoResponse uris
         * @property {Object.<string,lnrpc.IFeature>|null} [features] GetInfoResponse features
         */

        /**
         * Constructs a new GetInfoResponse.
         * @memberof lnrpc
         * @classdesc Represents a GetInfoResponse.
         * @implements IGetInfoResponse
         * @constructor
         * @param {lnrpc.IGetInfoResponse=} [properties] Properties to set
         */
        function GetInfoResponse(properties) {
            this.chains = [];
            this.uris = [];
            this.features = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetInfoResponse version.
         * @member {string} version
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.version = "";

        /**
         * GetInfoResponse commitHash.
         * @member {string} commitHash
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.commitHash = "";

        /**
         * GetInfoResponse identityPubkey.
         * @member {string} identityPubkey
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.identityPubkey = "";

        /**
         * GetInfoResponse alias.
         * @member {string} alias
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.alias = "";

        /**
         * GetInfoResponse color.
         * @member {string} color
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.color = "";

        /**
         * GetInfoResponse numPendingChannels.
         * @member {number} numPendingChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numPendingChannels = 0;

        /**
         * GetInfoResponse numActiveChannels.
         * @member {number} numActiveChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numActiveChannels = 0;

        /**
         * GetInfoResponse numInactiveChannels.
         * @member {number} numInactiveChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numInactiveChannels = 0;

        /**
         * GetInfoResponse numPeers.
         * @member {number} numPeers
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numPeers = 0;

        /**
         * GetInfoResponse blockHeight.
         * @member {number} blockHeight
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.blockHeight = 0;

        /**
         * GetInfoResponse blockHash.
         * @member {string} blockHash
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.blockHash = "";

        /**
         * GetInfoResponse bestHeaderTimestamp.
         * @member {number|Long} bestHeaderTimestamp
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.bestHeaderTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetInfoResponse syncedToChain.
         * @member {boolean} syncedToChain
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.syncedToChain = false;

        /**
         * GetInfoResponse syncedToGraph.
         * @member {boolean} syncedToGraph
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.syncedToGraph = false;

        /**
         * GetInfoResponse testnet.
         * @member {boolean} testnet
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.testnet = false;

        /**
         * GetInfoResponse chains.
         * @member {Array.<lnrpc.IChain>} chains
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.chains = $util.emptyArray;

        /**
         * GetInfoResponse uris.
         * @member {Array.<string>} uris
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.uris = $util.emptyArray;

        /**
         * GetInfoResponse features.
         * @member {Object.<string,lnrpc.IFeature>} features
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.features = $util.emptyObject;

        /**
         * Creates a new GetInfoResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse=} [properties] Properties to set
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse instance
         */
        GetInfoResponse.create = function create(properties) {
            return new GetInfoResponse(properties);
        };

        /**
         * Encodes the specified GetInfoResponse message. Does not implicitly {@link lnrpc.GetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identityPubkey != null && Object.hasOwnProperty.call(message, "identityPubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.identityPubkey);
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
            if (message.numPendingChannels != null && Object.hasOwnProperty.call(message, "numPendingChannels"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numPendingChannels);
            if (message.numActiveChannels != null && Object.hasOwnProperty.call(message, "numActiveChannels"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numActiveChannels);
            if (message.numPeers != null && Object.hasOwnProperty.call(message, "numPeers"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numPeers);
            if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.blockHeight);
            if (message.blockHash != null && Object.hasOwnProperty.call(message, "blockHash"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.blockHash);
            if (message.syncedToChain != null && Object.hasOwnProperty.call(message, "syncedToChain"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.syncedToChain);
            if (message.testnet != null && Object.hasOwnProperty.call(message, "testnet"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.testnet);
            if (message.uris != null && message.uris.length)
                for (let i = 0; i < message.uris.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.uris[i]);
            if (message.bestHeaderTimestamp != null && Object.hasOwnProperty.call(message, "bestHeaderTimestamp"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.bestHeaderTimestamp);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.version);
            if (message.numInactiveChannels != null && Object.hasOwnProperty.call(message, "numInactiveChannels"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.numInactiveChannels);
            if (message.chains != null && message.chains.length)
                for (let i = 0; i < message.chains.length; ++i)
                    $root.lnrpc.Chain.encode(message.chains[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.color);
            if (message.syncedToGraph != null && Object.hasOwnProperty.call(message, "syncedToGraph"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.syncedToGraph);
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 19, wireType 2 =*/154).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.lnrpc.Feature.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.commitHash != null && Object.hasOwnProperty.call(message, "commitHash"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.commitHash);
            return writer;
        };

        /**
         * Encodes the specified GetInfoResponse message, length delimited. Does not implicitly {@link lnrpc.GetInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetInfoResponse(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 14:
                    message.version = reader.string();
                    break;
                case 20:
                    message.commitHash = reader.string();
                    break;
                case 1:
                    message.identityPubkey = reader.string();
                    break;
                case 2:
                    message.alias = reader.string();
                    break;
                case 17:
                    message.color = reader.string();
                    break;
                case 3:
                    message.numPendingChannels = reader.uint32();
                    break;
                case 4:
                    message.numActiveChannels = reader.uint32();
                    break;
                case 15:
                    message.numInactiveChannels = reader.uint32();
                    break;
                case 5:
                    message.numPeers = reader.uint32();
                    break;
                case 6:
                    message.blockHeight = reader.uint32();
                    break;
                case 8:
                    message.blockHash = reader.string();
                    break;
                case 13:
                    message.bestHeaderTimestamp = reader.int64();
                    break;
                case 9:
                    message.syncedToChain = reader.bool();
                    break;
                case 18:
                    message.syncedToGraph = reader.bool();
                    break;
                case 10:
                    message.testnet = reader.bool();
                    break;
                case 16:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.lnrpc.Chain.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.uris && message.uris.length))
                        message.uris = [];
                    message.uris.push(reader.string());
                    break;
                case 19:
                    if (message.features === $util.emptyObject)
                        message.features = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint32();
                            break;
                        case 2:
                            value = $root.lnrpc.Feature.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.features[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetInfoResponse message.
         * @function verify
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.commitHash != null && message.hasOwnProperty("commitHash"))
                if (!$util.isString(message.commitHash))
                    return "commitHash: string expected";
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                if (!$util.isString(message.identityPubkey))
                    return "identityPubkey: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                if (!$util.isInteger(message.numPendingChannels))
                    return "numPendingChannels: integer expected";
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                if (!$util.isInteger(message.numActiveChannels))
                    return "numActiveChannels: integer expected";
            if (message.numInactiveChannels != null && message.hasOwnProperty("numInactiveChannels"))
                if (!$util.isInteger(message.numInactiveChannels))
                    return "numInactiveChannels: integer expected";
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                if (!$util.isInteger(message.numPeers))
                    return "numPeers: integer expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                if (!$util.isInteger(message.bestHeaderTimestamp) && !(message.bestHeaderTimestamp && $util.isInteger(message.bestHeaderTimestamp.low) && $util.isInteger(message.bestHeaderTimestamp.high)))
                    return "bestHeaderTimestamp: integer|Long expected";
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                if (typeof message.syncedToChain !== "boolean")
                    return "syncedToChain: boolean expected";
            if (message.syncedToGraph != null && message.hasOwnProperty("syncedToGraph"))
                if (typeof message.syncedToGraph !== "boolean")
                    return "syncedToGraph: boolean expected";
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                if (typeof message.testnet !== "boolean")
                    return "testnet: boolean expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (let i = 0; i < message.chains.length; ++i) {
                    let error = $root.lnrpc.Chain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            if (message.uris != null && message.hasOwnProperty("uris")) {
                if (!Array.isArray(message.uris))
                    return "uris: array expected";
                for (let i = 0; i < message.uris.length; ++i)
                    if (!$util.isString(message.uris[i]))
                        return "uris: string[] expected";
            }
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "features: integer key{k:uint32} expected";
                    {
                        let error = $root.lnrpc.Feature.verify(message.features[key[i]]);
                        if (error)
                            return "features." + error;
                    }
                }
            }
            return null;
        };

        /**
         * Creates a GetInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         */
        GetInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetInfoResponse)
                return object;
            let message = new $root.lnrpc.GetInfoResponse();
            if (object.version != null)
                message.version = String(object.version);
            if (object.commitHash != null)
                message.commitHash = String(object.commitHash);
            if (object.identityPubkey != null)
                message.identityPubkey = String(object.identityPubkey);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.color != null)
                message.color = String(object.color);
            if (object.numPendingChannels != null)
                message.numPendingChannels = object.numPendingChannels >>> 0;
            if (object.numActiveChannels != null)
                message.numActiveChannels = object.numActiveChannels >>> 0;
            if (object.numInactiveChannels != null)
                message.numInactiveChannels = object.numInactiveChannels >>> 0;
            if (object.numPeers != null)
                message.numPeers = object.numPeers >>> 0;
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight >>> 0;
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.bestHeaderTimestamp != null)
                if ($util.Long)
                    (message.bestHeaderTimestamp = $util.Long.fromValue(object.bestHeaderTimestamp)).unsigned = false;
                else if (typeof object.bestHeaderTimestamp === "string")
                    message.bestHeaderTimestamp = parseInt(object.bestHeaderTimestamp, 10);
                else if (typeof object.bestHeaderTimestamp === "number")
                    message.bestHeaderTimestamp = object.bestHeaderTimestamp;
                else if (typeof object.bestHeaderTimestamp === "object")
                    message.bestHeaderTimestamp = new $util.LongBits(object.bestHeaderTimestamp.low >>> 0, object.bestHeaderTimestamp.high >>> 0).toNumber();
            if (object.syncedToChain != null)
                message.syncedToChain = Boolean(object.syncedToChain);
            if (object.syncedToGraph != null)
                message.syncedToGraph = Boolean(object.syncedToGraph);
            if (object.testnet != null)
                message.testnet = Boolean(object.testnet);
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".lnrpc.GetInfoResponse.chains: array expected");
                message.chains = [];
                for (let i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".lnrpc.GetInfoResponse.chains: object expected");
                    message.chains[i] = $root.lnrpc.Chain.fromObject(object.chains[i]);
                }
            }
            if (object.uris) {
                if (!Array.isArray(object.uris))
                    throw TypeError(".lnrpc.GetInfoResponse.uris: array expected");
                message.uris = [];
                for (let i = 0; i < object.uris.length; ++i)
                    message.uris[i] = String(object.uris[i]);
            }
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".lnrpc.GetInfoResponse.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".lnrpc.GetInfoResponse.features: object expected");
                    message.features[keys[i]] = $root.lnrpc.Feature.fromObject(object.features[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.GetInfoResponse} message GetInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.uris = [];
                object.chains = [];
            }
            if (options.objects || options.defaults)
                object.features = {};
            if (options.defaults) {
                object.identityPubkey = "";
                object.alias = "";
                object.numPendingChannels = 0;
                object.numActiveChannels = 0;
                object.numPeers = 0;
                object.blockHeight = 0;
                object.blockHash = "";
                object.syncedToChain = false;
                object.testnet = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bestHeaderTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bestHeaderTimestamp = options.longs === String ? "0" : 0;
                object.version = "";
                object.numInactiveChannels = 0;
                object.color = "";
                object.syncedToGraph = false;
                object.commitHash = "";
            }
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                object.identityPubkey = message.identityPubkey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                object.numPendingChannels = message.numPendingChannels;
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                object.numActiveChannels = message.numActiveChannels;
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                object.numPeers = message.numPeers;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                object.syncedToChain = message.syncedToChain;
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                object.testnet = message.testnet;
            if (message.uris && message.uris.length) {
                object.uris = [];
                for (let j = 0; j < message.uris.length; ++j)
                    object.uris[j] = message.uris[j];
            }
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                if (typeof message.bestHeaderTimestamp === "number")
                    object.bestHeaderTimestamp = options.longs === String ? String(message.bestHeaderTimestamp) : message.bestHeaderTimestamp;
                else
                    object.bestHeaderTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.bestHeaderTimestamp) : options.longs === Number ? new $util.LongBits(message.bestHeaderTimestamp.low >>> 0, message.bestHeaderTimestamp.high >>> 0).toNumber() : message.bestHeaderTimestamp;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.numInactiveChannels != null && message.hasOwnProperty("numInactiveChannels"))
                object.numInactiveChannels = message.numInactiveChannels;
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (let j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.lnrpc.Chain.toObject(message.chains[j], options);
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.syncedToGraph != null && message.hasOwnProperty("syncedToGraph"))
                object.syncedToGraph = message.syncedToGraph;
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.lnrpc.Feature.toObject(message.features[keys2[j]], options);
            }
            if (message.commitHash != null && message.hasOwnProperty("commitHash"))
                object.commitHash = message.commitHash;
            return object;
        };

        /**
         * Converts this GetInfoResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.GetInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetInfoResponse;
    })();

    lnrpc.GetRecoveryInfoRequest = (function() {

        /**
         * Properties of a GetRecoveryInfoRequest.
         * @memberof lnrpc
         * @interface IGetRecoveryInfoRequest
         */

        /**
         * Constructs a new GetRecoveryInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetRecoveryInfoRequest.
         * @implements IGetRecoveryInfoRequest
         * @constructor
         * @param {lnrpc.IGetRecoveryInfoRequest=} [properties] Properties to set
         */
        function GetRecoveryInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetRecoveryInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {lnrpc.IGetRecoveryInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.GetRecoveryInfoRequest} GetRecoveryInfoRequest instance
         */
        GetRecoveryInfoRequest.create = function create(properties) {
            return new GetRecoveryInfoRequest(properties);
        };

        /**
         * Encodes the specified GetRecoveryInfoRequest message. Does not implicitly {@link lnrpc.GetRecoveryInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {lnrpc.IGetRecoveryInfoRequest} message GetRecoveryInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRecoveryInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetRecoveryInfoRequest message, length delimited. Does not implicitly {@link lnrpc.GetRecoveryInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {lnrpc.IGetRecoveryInfoRequest} message GetRecoveryInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRecoveryInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRecoveryInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetRecoveryInfoRequest} GetRecoveryInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRecoveryInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetRecoveryInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRecoveryInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetRecoveryInfoRequest} GetRecoveryInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRecoveryInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRecoveryInfoRequest message.
         * @function verify
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRecoveryInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetRecoveryInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetRecoveryInfoRequest} GetRecoveryInfoRequest
         */
        GetRecoveryInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetRecoveryInfoRequest)
                return object;
            return new $root.lnrpc.GetRecoveryInfoRequest();
        };

        /**
         * Creates a plain object from a GetRecoveryInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @static
         * @param {lnrpc.GetRecoveryInfoRequest} message GetRecoveryInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRecoveryInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetRecoveryInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetRecoveryInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRecoveryInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRecoveryInfoRequest;
    })();

    lnrpc.GetRecoveryInfoResponse = (function() {

        /**
         * Properties of a GetRecoveryInfoResponse.
         * @memberof lnrpc
         * @interface IGetRecoveryInfoResponse
         * @property {boolean|null} [recoveryMode] GetRecoveryInfoResponse recoveryMode
         * @property {boolean|null} [recoveryFinished] GetRecoveryInfoResponse recoveryFinished
         * @property {number|null} [progress] GetRecoveryInfoResponse progress
         */

        /**
         * Constructs a new GetRecoveryInfoResponse.
         * @memberof lnrpc
         * @classdesc Represents a GetRecoveryInfoResponse.
         * @implements IGetRecoveryInfoResponse
         * @constructor
         * @param {lnrpc.IGetRecoveryInfoResponse=} [properties] Properties to set
         */
        function GetRecoveryInfoResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRecoveryInfoResponse recoveryMode.
         * @member {boolean} recoveryMode
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @instance
         */
        GetRecoveryInfoResponse.prototype.recoveryMode = false;

        /**
         * GetRecoveryInfoResponse recoveryFinished.
         * @member {boolean} recoveryFinished
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @instance
         */
        GetRecoveryInfoResponse.prototype.recoveryFinished = false;

        /**
         * GetRecoveryInfoResponse progress.
         * @member {number} progress
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @instance
         */
        GetRecoveryInfoResponse.prototype.progress = 0;

        /**
         * Creates a new GetRecoveryInfoResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {lnrpc.IGetRecoveryInfoResponse=} [properties] Properties to set
         * @returns {lnrpc.GetRecoveryInfoResponse} GetRecoveryInfoResponse instance
         */
        GetRecoveryInfoResponse.create = function create(properties) {
            return new GetRecoveryInfoResponse(properties);
        };

        /**
         * Encodes the specified GetRecoveryInfoResponse message. Does not implicitly {@link lnrpc.GetRecoveryInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {lnrpc.IGetRecoveryInfoResponse} message GetRecoveryInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRecoveryInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recoveryMode != null && Object.hasOwnProperty.call(message, "recoveryMode"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.recoveryMode);
            if (message.recoveryFinished != null && Object.hasOwnProperty.call(message, "recoveryFinished"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recoveryFinished);
            if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.progress);
            return writer;
        };

        /**
         * Encodes the specified GetRecoveryInfoResponse message, length delimited. Does not implicitly {@link lnrpc.GetRecoveryInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {lnrpc.IGetRecoveryInfoResponse} message GetRecoveryInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRecoveryInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRecoveryInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetRecoveryInfoResponse} GetRecoveryInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRecoveryInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetRecoveryInfoResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recoveryMode = reader.bool();
                    break;
                case 2:
                    message.recoveryFinished = reader.bool();
                    break;
                case 3:
                    message.progress = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRecoveryInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetRecoveryInfoResponse} GetRecoveryInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRecoveryInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRecoveryInfoResponse message.
         * @function verify
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRecoveryInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recoveryMode != null && message.hasOwnProperty("recoveryMode"))
                if (typeof message.recoveryMode !== "boolean")
                    return "recoveryMode: boolean expected";
            if (message.recoveryFinished != null && message.hasOwnProperty("recoveryFinished"))
                if (typeof message.recoveryFinished !== "boolean")
                    return "recoveryFinished: boolean expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (typeof message.progress !== "number")
                    return "progress: number expected";
            return null;
        };

        /**
         * Creates a GetRecoveryInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetRecoveryInfoResponse} GetRecoveryInfoResponse
         */
        GetRecoveryInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetRecoveryInfoResponse)
                return object;
            let message = new $root.lnrpc.GetRecoveryInfoResponse();
            if (object.recoveryMode != null)
                message.recoveryMode = Boolean(object.recoveryMode);
            if (object.recoveryFinished != null)
                message.recoveryFinished = Boolean(object.recoveryFinished);
            if (object.progress != null)
                message.progress = Number(object.progress);
            return message;
        };

        /**
         * Creates a plain object from a GetRecoveryInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @static
         * @param {lnrpc.GetRecoveryInfoResponse} message GetRecoveryInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRecoveryInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.recoveryMode = false;
                object.recoveryFinished = false;
                object.progress = 0;
            }
            if (message.recoveryMode != null && message.hasOwnProperty("recoveryMode"))
                object.recoveryMode = message.recoveryMode;
            if (message.recoveryFinished != null && message.hasOwnProperty("recoveryFinished"))
                object.recoveryFinished = message.recoveryFinished;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = options.json && !isFinite(message.progress) ? String(message.progress) : message.progress;
            return object;
        };

        /**
         * Converts this GetRecoveryInfoResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.GetRecoveryInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRecoveryInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRecoveryInfoResponse;
    })();

    lnrpc.Chain = (function() {

        /**
         * Properties of a Chain.
         * @memberof lnrpc
         * @interface IChain
         * @property {string|null} [chain] Chain chain
         * @property {string|null} [network] Chain network
         */

        /**
         * Constructs a new Chain.
         * @memberof lnrpc
         * @classdesc Represents a Chain.
         * @implements IChain
         * @constructor
         * @param {lnrpc.IChain=} [properties] Properties to set
         */
        function Chain(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Chain chain.
         * @member {string} chain
         * @memberof lnrpc.Chain
         * @instance
         */
        Chain.prototype.chain = "";

        /**
         * Chain network.
         * @member {string} network
         * @memberof lnrpc.Chain
         * @instance
         */
        Chain.prototype.network = "";

        /**
         * Creates a new Chain instance using the specified properties.
         * @function create
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.IChain=} [properties] Properties to set
         * @returns {lnrpc.Chain} Chain instance
         */
        Chain.create = function create(properties) {
            return new Chain(properties);
        };

        /**
         * Encodes the specified Chain message. Does not implicitly {@link lnrpc.Chain.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.IChain} message Chain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chain != null && Object.hasOwnProperty.call(message, "chain"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chain);
            if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.network);
            return writer;
        };

        /**
         * Encodes the specified Chain message, length delimited. Does not implicitly {@link lnrpc.Chain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.IChain} message Chain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chain message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Chain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Chain} Chain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Chain();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.network = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Chain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Chain} Chain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chain message.
         * @function verify
         * @memberof lnrpc.Chain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chain != null && message.hasOwnProperty("chain"))
                if (!$util.isString(message.chain))
                    return "chain: string expected";
            if (message.network != null && message.hasOwnProperty("network"))
                if (!$util.isString(message.network))
                    return "network: string expected";
            return null;
        };

        /**
         * Creates a Chain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Chain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Chain} Chain
         */
        Chain.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Chain)
                return object;
            let message = new $root.lnrpc.Chain();
            if (object.chain != null)
                message.chain = String(object.chain);
            if (object.network != null)
                message.network = String(object.network);
            return message;
        };

        /**
         * Creates a plain object from a Chain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.Chain} message Chain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Chain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chain = "";
                object.network = "";
            }
            if (message.chain != null && message.hasOwnProperty("chain"))
                object.chain = message.chain;
            if (message.network != null && message.hasOwnProperty("network"))
                object.network = message.network;
            return object;
        };

        /**
         * Converts this Chain to JSON.
         * @function toJSON
         * @memberof lnrpc.Chain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Chain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Chain;
    })();

    lnrpc.ConfirmationUpdate = (function() {

        /**
         * Properties of a ConfirmationUpdate.
         * @memberof lnrpc
         * @interface IConfirmationUpdate
         * @property {Uint8Array|null} [blockSha] ConfirmationUpdate blockSha
         * @property {number|null} [blockHeight] ConfirmationUpdate blockHeight
         * @property {number|null} [numConfsLeft] ConfirmationUpdate numConfsLeft
         */

        /**
         * Constructs a new ConfirmationUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ConfirmationUpdate.
         * @implements IConfirmationUpdate
         * @constructor
         * @param {lnrpc.IConfirmationUpdate=} [properties] Properties to set
         */
        function ConfirmationUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfirmationUpdate blockSha.
         * @member {Uint8Array} blockSha
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.blockSha = $util.newBuffer([]);

        /**
         * ConfirmationUpdate blockHeight.
         * @member {number} blockHeight
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.blockHeight = 0;

        /**
         * ConfirmationUpdate numConfsLeft.
         * @member {number} numConfsLeft
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.numConfsLeft = 0;

        /**
         * Creates a new ConfirmationUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate=} [properties] Properties to set
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate instance
         */
        ConfirmationUpdate.create = function create(properties) {
            return new ConfirmationUpdate(properties);
        };

        /**
         * Encodes the specified ConfirmationUpdate message. Does not implicitly {@link lnrpc.ConfirmationUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate} message ConfirmationUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfirmationUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSha != null && Object.hasOwnProperty.call(message, "blockSha"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockSha);
            if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.blockHeight);
            if (message.numConfsLeft != null && Object.hasOwnProperty.call(message, "numConfsLeft"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numConfsLeft);
            return writer;
        };

        /**
         * Encodes the specified ConfirmationUpdate message, length delimited. Does not implicitly {@link lnrpc.ConfirmationUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate} message ConfirmationUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfirmationUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfirmationUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfirmationUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConfirmationUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSha = reader.bytes();
                    break;
                case 2:
                    message.blockHeight = reader.int32();
                    break;
                case 3:
                    message.numConfsLeft = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfirmationUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfirmationUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfirmationUpdate message.
         * @function verify
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfirmationUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                if (!(message.blockSha && typeof message.blockSha.length === "number" || $util.isString(message.blockSha)))
                    return "blockSha: buffer expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                if (!$util.isInteger(message.numConfsLeft))
                    return "numConfsLeft: integer expected";
            return null;
        };

        /**
         * Creates a ConfirmationUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         */
        ConfirmationUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConfirmationUpdate)
                return object;
            let message = new $root.lnrpc.ConfirmationUpdate();
            if (object.blockSha != null)
                if (typeof object.blockSha === "string")
                    $util.base64.decode(object.blockSha, message.blockSha = $util.newBuffer($util.base64.length(object.blockSha)), 0);
                else if (object.blockSha.length)
                    message.blockSha = object.blockSha;
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight | 0;
            if (object.numConfsLeft != null)
                message.numConfsLeft = object.numConfsLeft >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ConfirmationUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.ConfirmationUpdate} message ConfirmationUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfirmationUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockSha = "";
                else {
                    object.blockSha = [];
                    if (options.bytes !== Array)
                        object.blockSha = $util.newBuffer(object.blockSha);
                }
                object.blockHeight = 0;
                object.numConfsLeft = 0;
            }
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                object.blockSha = options.bytes === String ? $util.base64.encode(message.blockSha, 0, message.blockSha.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockSha) : message.blockSha;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                object.numConfsLeft = message.numConfsLeft;
            return object;
        };

        /**
         * Converts this ConfirmationUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfirmationUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfirmationUpdate;
    })();

    lnrpc.ChannelOpenUpdate = (function() {

        /**
         * Properties of a ChannelOpenUpdate.
         * @memberof lnrpc
         * @interface IChannelOpenUpdate
         * @property {lnrpc.IChannelPoint|null} [channelPoint] ChannelOpenUpdate channelPoint
         */

        /**
         * Constructs a new ChannelOpenUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelOpenUpdate.
         * @implements IChannelOpenUpdate
         * @constructor
         * @param {lnrpc.IChannelOpenUpdate=} [properties] Properties to set
         */
        function ChannelOpenUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelOpenUpdate channelPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.ChannelOpenUpdate
         * @instance
         */
        ChannelOpenUpdate.prototype.channelPoint = null;

        /**
         * Creates a new ChannelOpenUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate instance
         */
        ChannelOpenUpdate.create = function create(properties) {
            return new ChannelOpenUpdate(properties);
        };

        /**
         * Encodes the specified ChannelOpenUpdate message. Does not implicitly {@link lnrpc.ChannelOpenUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate} message ChannelOpenUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelOpenUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelOpenUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate} message ChannelOpenUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelOpenUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelOpenUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelOpenUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelOpenUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelOpenUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelOpenUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         */
        ChannelOpenUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelOpenUpdate)
                return object;
            let message = new $root.lnrpc.ChannelOpenUpdate();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.ChannelOpenUpdate.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelOpenUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.ChannelOpenUpdate} message ChannelOpenUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelOpenUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.channelPoint = null;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            return object;
        };

        /**
         * Converts this ChannelOpenUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelOpenUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelOpenUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelOpenUpdate;
    })();

    lnrpc.ChannelCloseUpdate = (function() {

        /**
         * Properties of a ChannelCloseUpdate.
         * @memberof lnrpc
         * @interface IChannelCloseUpdate
         * @property {Uint8Array|null} [closingTxid] ChannelCloseUpdate closingTxid
         * @property {boolean|null} [success] ChannelCloseUpdate success
         */

        /**
         * Constructs a new ChannelCloseUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelCloseUpdate.
         * @implements IChannelCloseUpdate
         * @constructor
         * @param {lnrpc.IChannelCloseUpdate=} [properties] Properties to set
         */
        function ChannelCloseUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelCloseUpdate closingTxid.
         * @member {Uint8Array} closingTxid
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         */
        ChannelCloseUpdate.prototype.closingTxid = $util.newBuffer([]);

        /**
         * ChannelCloseUpdate success.
         * @member {boolean} success
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         */
        ChannelCloseUpdate.prototype.success = false;

        /**
         * Creates a new ChannelCloseUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate instance
         */
        ChannelCloseUpdate.create = function create(properties) {
            return new ChannelCloseUpdate(properties);
        };

        /**
         * Encodes the specified ChannelCloseUpdate message. Does not implicitly {@link lnrpc.ChannelCloseUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate} message ChannelCloseUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closingTxid != null && Object.hasOwnProperty.call(message, "closingTxid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.closingTxid);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelCloseUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate} message ChannelCloseUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelCloseUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.closingTxid = reader.bytes();
                    break;
                case 2:
                    message.success = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                if (!(message.closingTxid && typeof message.closingTxid.length === "number" || $util.isString(message.closingTxid)))
                    return "closingTxid: buffer expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ChannelCloseUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         */
        ChannelCloseUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelCloseUpdate)
                return object;
            let message = new $root.lnrpc.ChannelCloseUpdate();
            if (object.closingTxid != null)
                if (typeof object.closingTxid === "string")
                    $util.base64.decode(object.closingTxid, message.closingTxid = $util.newBuffer($util.base64.length(object.closingTxid)), 0);
                else if (object.closingTxid.length)
                    message.closingTxid = object.closingTxid;
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.ChannelCloseUpdate} message ChannelCloseUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.closingTxid = "";
                else {
                    object.closingTxid = [];
                    if (options.bytes !== Array)
                        object.closingTxid = $util.newBuffer(object.closingTxid);
                }
                object.success = false;
            }
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                object.closingTxid = options.bytes === String ? $util.base64.encode(message.closingTxid, 0, message.closingTxid.length) : options.bytes === Array ? Array.prototype.slice.call(message.closingTxid) : message.closingTxid;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ChannelCloseUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelCloseUpdate;
    })();

    lnrpc.CloseChannelRequest = (function() {

        /**
         * Properties of a CloseChannelRequest.
         * @memberof lnrpc
         * @interface ICloseChannelRequest
         * @property {lnrpc.IChannelPoint|null} [channelPoint] CloseChannelRequest channelPoint
         * @property {boolean|null} [force] CloseChannelRequest force
         * @property {number|null} [targetConf] CloseChannelRequest targetConf
         * @property {number|Long|null} [satPerByte] CloseChannelRequest satPerByte
         * @property {string|null} [deliveryAddress] CloseChannelRequest deliveryAddress
         */

        /**
         * Constructs a new CloseChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents a CloseChannelRequest.
         * @implements ICloseChannelRequest
         * @constructor
         * @param {lnrpc.ICloseChannelRequest=} [properties] Properties to set
         */
        function CloseChannelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseChannelRequest channelPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.channelPoint = null;

        /**
         * CloseChannelRequest force.
         * @member {boolean} force
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.force = false;

        /**
         * CloseChannelRequest targetConf.
         * @member {number} targetConf
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.targetConf = 0;

        /**
         * CloseChannelRequest satPerByte.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CloseChannelRequest deliveryAddress.
         * @member {string} deliveryAddress
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.deliveryAddress = "";

        /**
         * Creates a new CloseChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest instance
         */
        CloseChannelRequest.create = function create(properties) {
            return new CloseChannelRequest(properties);
        };

        /**
         * Encodes the specified CloseChannelRequest message. Does not implicitly {@link lnrpc.CloseChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest} message CloseChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.force);
            if (message.targetConf != null && Object.hasOwnProperty.call(message, "targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && Object.hasOwnProperty.call(message, "satPerByte"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.satPerByte);
            if (message.deliveryAddress != null && Object.hasOwnProperty.call(message, "deliveryAddress"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.deliveryAddress);
            return writer;
        };

        /**
         * Encodes the specified CloseChannelRequest message, length delimited. Does not implicitly {@link lnrpc.CloseChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest} message CloseChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.CloseChannelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.force = reader.bool();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 4:
                    message.satPerByte = reader.int64();
                    break;
                case 5:
                    message.deliveryAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseChannelRequest message.
         * @function verify
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message.deliveryAddress != null && message.hasOwnProperty("deliveryAddress"))
                if (!$util.isString(message.deliveryAddress))
                    return "deliveryAddress: string expected";
            return null;
        };

        /**
         * Creates a CloseChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         */
        CloseChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.CloseChannelRequest)
                return object;
            let message = new $root.lnrpc.CloseChannelRequest();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.CloseChannelRequest.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object.deliveryAddress != null)
                message.deliveryAddress = String(object.deliveryAddress);
            return message;
        };

        /**
         * Creates a plain object from a CloseChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.CloseChannelRequest} message CloseChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.channelPoint = null;
                object.force = false;
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object.deliveryAddress = "";
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message.deliveryAddress != null && message.hasOwnProperty("deliveryAddress"))
                object.deliveryAddress = message.deliveryAddress;
            return object;
        };

        /**
         * Converts this CloseChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseChannelRequest;
    })();

    lnrpc.CloseStatusUpdate = (function() {

        /**
         * Properties of a CloseStatusUpdate.
         * @memberof lnrpc
         * @interface ICloseStatusUpdate
         * @property {lnrpc.IPendingUpdate|null} [closePending] CloseStatusUpdate closePending
         * @property {lnrpc.IChannelCloseUpdate|null} [chanClose] CloseStatusUpdate chanClose
         */

        /**
         * Constructs a new CloseStatusUpdate.
         * @memberof lnrpc
         * @classdesc Represents a CloseStatusUpdate.
         * @implements ICloseStatusUpdate
         * @constructor
         * @param {lnrpc.ICloseStatusUpdate=} [properties] Properties to set
         */
        function CloseStatusUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseStatusUpdate closePending.
         * @member {lnrpc.IPendingUpdate|null|undefined} closePending
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.closePending = null;

        /**
         * CloseStatusUpdate chanClose.
         * @member {lnrpc.IChannelCloseUpdate|null|undefined} chanClose
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.chanClose = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CloseStatusUpdate update.
         * @member {"closePending"|"chanClose"|undefined} update
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        Object.defineProperty(CloseStatusUpdate.prototype, "update", {
            get: $util.oneOfGetter($oneOfFields = ["closePending", "chanClose"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CloseStatusUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate=} [properties] Properties to set
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate instance
         */
        CloseStatusUpdate.create = function create(properties) {
            return new CloseStatusUpdate(properties);
        };

        /**
         * Encodes the specified CloseStatusUpdate message. Does not implicitly {@link lnrpc.CloseStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate} message CloseStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closePending != null && Object.hasOwnProperty.call(message, "closePending"))
                $root.lnrpc.PendingUpdate.encode(message.closePending, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chanClose != null && Object.hasOwnProperty.call(message, "chanClose"))
                $root.lnrpc.ChannelCloseUpdate.encode(message.chanClose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CloseStatusUpdate message, length delimited. Does not implicitly {@link lnrpc.CloseStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate} message CloseStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.CloseStatusUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.closePending = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chanClose = $root.lnrpc.ChannelCloseUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseStatusUpdate message.
         * @function verify
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.closePending != null && message.hasOwnProperty("closePending")) {
                properties.update = 1;
                {
                    let error = $root.lnrpc.PendingUpdate.verify(message.closePending);
                    if (error)
                        return "closePending." + error;
                }
            }
            if (message.chanClose != null && message.hasOwnProperty("chanClose")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    let error = $root.lnrpc.ChannelCloseUpdate.verify(message.chanClose);
                    if (error)
                        return "chanClose." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CloseStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         */
        CloseStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.CloseStatusUpdate)
                return object;
            let message = new $root.lnrpc.CloseStatusUpdate();
            if (object.closePending != null) {
                if (typeof object.closePending !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.closePending: object expected");
                message.closePending = $root.lnrpc.PendingUpdate.fromObject(object.closePending);
            }
            if (object.chanClose != null) {
                if (typeof object.chanClose !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.chanClose: object expected");
                message.chanClose = $root.lnrpc.ChannelCloseUpdate.fromObject(object.chanClose);
            }
            return message;
        };

        /**
         * Creates a plain object from a CloseStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.CloseStatusUpdate} message CloseStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.closePending != null && message.hasOwnProperty("closePending")) {
                object.closePending = $root.lnrpc.PendingUpdate.toObject(message.closePending, options);
                if (options.oneofs)
                    object.update = "closePending";
            }
            if (message.chanClose != null && message.hasOwnProperty("chanClose")) {
                object.chanClose = $root.lnrpc.ChannelCloseUpdate.toObject(message.chanClose, options);
                if (options.oneofs)
                    object.update = "chanClose";
            }
            return object;
        };

        /**
         * Converts this CloseStatusUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseStatusUpdate;
    })();

    lnrpc.PendingUpdate = (function() {

        /**
         * Properties of a PendingUpdate.
         * @memberof lnrpc
         * @interface IPendingUpdate
         * @property {Uint8Array|null} [txid] PendingUpdate txid
         * @property {number|null} [outputIndex] PendingUpdate outputIndex
         */

        /**
         * Constructs a new PendingUpdate.
         * @memberof lnrpc
         * @classdesc Represents a PendingUpdate.
         * @implements IPendingUpdate
         * @constructor
         * @param {lnrpc.IPendingUpdate=} [properties] Properties to set
         */
        function PendingUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingUpdate txid.
         * @member {Uint8Array} txid
         * @memberof lnrpc.PendingUpdate
         * @instance
         */
        PendingUpdate.prototype.txid = $util.newBuffer([]);

        /**
         * PendingUpdate outputIndex.
         * @member {number} outputIndex
         * @memberof lnrpc.PendingUpdate
         * @instance
         */
        PendingUpdate.prototype.outputIndex = 0;

        /**
         * Creates a new PendingUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate=} [properties] Properties to set
         * @returns {lnrpc.PendingUpdate} PendingUpdate instance
         */
        PendingUpdate.create = function create(properties) {
            return new PendingUpdate(properties);
        };

        /**
         * Encodes the specified PendingUpdate message. Does not implicitly {@link lnrpc.PendingUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate} message PendingUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txid);
            if (message.outputIndex != null && Object.hasOwnProperty.call(message, "outputIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified PendingUpdate message, length delimited. Does not implicitly {@link lnrpc.PendingUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate} message PendingUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                case 2:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingUpdate message.
         * @function verify
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!(message.txid && typeof message.txid.length === "number" || $util.isString(message.txid)))
                    return "txid: buffer expected";
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates a PendingUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         */
        PendingUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingUpdate)
                return object;
            let message = new $root.lnrpc.PendingUpdate();
            if (object.txid != null)
                if (typeof object.txid === "string")
                    $util.base64.decode(object.txid, message.txid = $util.newBuffer($util.base64.length(object.txid)), 0);
                else if (object.txid.length)
                    message.txid = object.txid;
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendingUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.PendingUpdate} message PendingUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.txid = "";
                else {
                    object.txid = [];
                    if (options.bytes !== Array)
                        object.txid = $util.newBuffer(object.txid);
                }
                object.outputIndex = 0;
            }
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = options.bytes === String ? $util.base64.encode(message.txid, 0, message.txid.length) : options.bytes === Array ? Array.prototype.slice.call(message.txid) : message.txid;
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this PendingUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingUpdate;
    })();

    lnrpc.ReadyForPsbtFunding = (function() {

        /**
         * Properties of a ReadyForPsbtFunding.
         * @memberof lnrpc
         * @interface IReadyForPsbtFunding
         * @property {string|null} [fundingAddress] ReadyForPsbtFunding fundingAddress
         * @property {number|Long|null} [fundingAmount] ReadyForPsbtFunding fundingAmount
         * @property {Uint8Array|null} [psbt] ReadyForPsbtFunding psbt
         */

        /**
         * Constructs a new ReadyForPsbtFunding.
         * @memberof lnrpc
         * @classdesc Represents a ReadyForPsbtFunding.
         * @implements IReadyForPsbtFunding
         * @constructor
         * @param {lnrpc.IReadyForPsbtFunding=} [properties] Properties to set
         */
        function ReadyForPsbtFunding(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadyForPsbtFunding fundingAddress.
         * @member {string} fundingAddress
         * @memberof lnrpc.ReadyForPsbtFunding
         * @instance
         */
        ReadyForPsbtFunding.prototype.fundingAddress = "";

        /**
         * ReadyForPsbtFunding fundingAmount.
         * @member {number|Long} fundingAmount
         * @memberof lnrpc.ReadyForPsbtFunding
         * @instance
         */
        ReadyForPsbtFunding.prototype.fundingAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReadyForPsbtFunding psbt.
         * @member {Uint8Array} psbt
         * @memberof lnrpc.ReadyForPsbtFunding
         * @instance
         */
        ReadyForPsbtFunding.prototype.psbt = $util.newBuffer([]);

        /**
         * Creates a new ReadyForPsbtFunding instance using the specified properties.
         * @function create
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {lnrpc.IReadyForPsbtFunding=} [properties] Properties to set
         * @returns {lnrpc.ReadyForPsbtFunding} ReadyForPsbtFunding instance
         */
        ReadyForPsbtFunding.create = function create(properties) {
            return new ReadyForPsbtFunding(properties);
        };

        /**
         * Encodes the specified ReadyForPsbtFunding message. Does not implicitly {@link lnrpc.ReadyForPsbtFunding.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {lnrpc.IReadyForPsbtFunding} message ReadyForPsbtFunding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadyForPsbtFunding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fundingAddress != null && Object.hasOwnProperty.call(message, "fundingAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fundingAddress);
            if (message.fundingAmount != null && Object.hasOwnProperty.call(message, "fundingAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fundingAmount);
            if (message.psbt != null && Object.hasOwnProperty.call(message, "psbt"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.psbt);
            return writer;
        };

        /**
         * Encodes the specified ReadyForPsbtFunding message, length delimited. Does not implicitly {@link lnrpc.ReadyForPsbtFunding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {lnrpc.IReadyForPsbtFunding} message ReadyForPsbtFunding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadyForPsbtFunding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadyForPsbtFunding message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ReadyForPsbtFunding} ReadyForPsbtFunding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadyForPsbtFunding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ReadyForPsbtFunding();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fundingAddress = reader.string();
                    break;
                case 2:
                    message.fundingAmount = reader.int64();
                    break;
                case 3:
                    message.psbt = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadyForPsbtFunding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ReadyForPsbtFunding} ReadyForPsbtFunding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadyForPsbtFunding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadyForPsbtFunding message.
         * @function verify
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadyForPsbtFunding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fundingAddress != null && message.hasOwnProperty("fundingAddress"))
                if (!$util.isString(message.fundingAddress))
                    return "fundingAddress: string expected";
            if (message.fundingAmount != null && message.hasOwnProperty("fundingAmount"))
                if (!$util.isInteger(message.fundingAmount) && !(message.fundingAmount && $util.isInteger(message.fundingAmount.low) && $util.isInteger(message.fundingAmount.high)))
                    return "fundingAmount: integer|Long expected";
            if (message.psbt != null && message.hasOwnProperty("psbt"))
                if (!(message.psbt && typeof message.psbt.length === "number" || $util.isString(message.psbt)))
                    return "psbt: buffer expected";
            return null;
        };

        /**
         * Creates a ReadyForPsbtFunding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ReadyForPsbtFunding} ReadyForPsbtFunding
         */
        ReadyForPsbtFunding.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ReadyForPsbtFunding)
                return object;
            let message = new $root.lnrpc.ReadyForPsbtFunding();
            if (object.fundingAddress != null)
                message.fundingAddress = String(object.fundingAddress);
            if (object.fundingAmount != null)
                if ($util.Long)
                    (message.fundingAmount = $util.Long.fromValue(object.fundingAmount)).unsigned = false;
                else if (typeof object.fundingAmount === "string")
                    message.fundingAmount = parseInt(object.fundingAmount, 10);
                else if (typeof object.fundingAmount === "number")
                    message.fundingAmount = object.fundingAmount;
                else if (typeof object.fundingAmount === "object")
                    message.fundingAmount = new $util.LongBits(object.fundingAmount.low >>> 0, object.fundingAmount.high >>> 0).toNumber();
            if (object.psbt != null)
                if (typeof object.psbt === "string")
                    $util.base64.decode(object.psbt, message.psbt = $util.newBuffer($util.base64.length(object.psbt)), 0);
                else if (object.psbt.length)
                    message.psbt = object.psbt;
            return message;
        };

        /**
         * Creates a plain object from a ReadyForPsbtFunding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ReadyForPsbtFunding
         * @static
         * @param {lnrpc.ReadyForPsbtFunding} message ReadyForPsbtFunding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReadyForPsbtFunding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.fundingAddress = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fundingAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fundingAmount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.psbt = "";
                else {
                    object.psbt = [];
                    if (options.bytes !== Array)
                        object.psbt = $util.newBuffer(object.psbt);
                }
            }
            if (message.fundingAddress != null && message.hasOwnProperty("fundingAddress"))
                object.fundingAddress = message.fundingAddress;
            if (message.fundingAmount != null && message.hasOwnProperty("fundingAmount"))
                if (typeof message.fundingAmount === "number")
                    object.fundingAmount = options.longs === String ? String(message.fundingAmount) : message.fundingAmount;
                else
                    object.fundingAmount = options.longs === String ? $util.Long.prototype.toString.call(message.fundingAmount) : options.longs === Number ? new $util.LongBits(message.fundingAmount.low >>> 0, message.fundingAmount.high >>> 0).toNumber() : message.fundingAmount;
            if (message.psbt != null && message.hasOwnProperty("psbt"))
                object.psbt = options.bytes === String ? $util.base64.encode(message.psbt, 0, message.psbt.length) : options.bytes === Array ? Array.prototype.slice.call(message.psbt) : message.psbt;
            return object;
        };

        /**
         * Converts this ReadyForPsbtFunding to JSON.
         * @function toJSON
         * @memberof lnrpc.ReadyForPsbtFunding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReadyForPsbtFunding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReadyForPsbtFunding;
    })();

    lnrpc.OpenChannelRequest = (function() {

        /**
         * Properties of an OpenChannelRequest.
         * @memberof lnrpc
         * @interface IOpenChannelRequest
         * @property {Uint8Array|null} [nodePubkey] OpenChannelRequest nodePubkey
         * @property {string|null} [nodePubkeyString] OpenChannelRequest nodePubkeyString
         * @property {number|Long|null} [localFundingAmount] OpenChannelRequest localFundingAmount
         * @property {number|Long|null} [pushSat] OpenChannelRequest pushSat
         * @property {number|null} [targetConf] OpenChannelRequest targetConf
         * @property {number|Long|null} [satPerByte] OpenChannelRequest satPerByte
         * @property {boolean|null} ["private"] OpenChannelRequest private
         * @property {number|Long|null} [minHtlcMsat] OpenChannelRequest minHtlcMsat
         * @property {number|null} [remoteCsvDelay] OpenChannelRequest remoteCsvDelay
         * @property {number|null} [minConfs] OpenChannelRequest minConfs
         * @property {boolean|null} [spendUnconfirmed] OpenChannelRequest spendUnconfirmed
         * @property {string|null} [closeAddress] OpenChannelRequest closeAddress
         * @property {lnrpc.IFundingShim|null} [fundingShim] OpenChannelRequest fundingShim
         * @property {number|Long|null} [remoteMaxValueInFlightMsat] OpenChannelRequest remoteMaxValueInFlightMsat
         * @property {number|null} [remoteMaxHtlcs] OpenChannelRequest remoteMaxHtlcs
         */

        /**
         * Constructs a new OpenChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents an OpenChannelRequest.
         * @implements IOpenChannelRequest
         * @constructor
         * @param {lnrpc.IOpenChannelRequest=} [properties] Properties to set
         */
        function OpenChannelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenChannelRequest nodePubkey.
         * @member {Uint8Array} nodePubkey
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.nodePubkey = $util.newBuffer([]);

        /**
         * OpenChannelRequest nodePubkeyString.
         * @member {string} nodePubkeyString
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.nodePubkeyString = "";

        /**
         * OpenChannelRequest localFundingAmount.
         * @member {number|Long} localFundingAmount
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.localFundingAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OpenChannelRequest pushSat.
         * @member {number|Long} pushSat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.pushSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OpenChannelRequest targetConf.
         * @member {number} targetConf
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.targetConf = 0;

        /**
         * OpenChannelRequest satPerByte.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OpenChannelRequest private.
         * @member {boolean} private
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype["private"] = false;

        /**
         * OpenChannelRequest minHtlcMsat.
         * @member {number|Long} minHtlcMsat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.minHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OpenChannelRequest remoteCsvDelay.
         * @member {number} remoteCsvDelay
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.remoteCsvDelay = 0;

        /**
         * OpenChannelRequest minConfs.
         * @member {number} minConfs
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.minConfs = 0;

        /**
         * OpenChannelRequest spendUnconfirmed.
         * @member {boolean} spendUnconfirmed
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.spendUnconfirmed = false;

        /**
         * OpenChannelRequest closeAddress.
         * @member {string} closeAddress
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.closeAddress = "";

        /**
         * OpenChannelRequest fundingShim.
         * @member {lnrpc.IFundingShim|null|undefined} fundingShim
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.fundingShim = null;

        /**
         * OpenChannelRequest remoteMaxValueInFlightMsat.
         * @member {number|Long} remoteMaxValueInFlightMsat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.remoteMaxValueInFlightMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OpenChannelRequest remoteMaxHtlcs.
         * @member {number} remoteMaxHtlcs
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.remoteMaxHtlcs = 0;

        /**
         * Creates a new OpenChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest instance
         */
        OpenChannelRequest.create = function create(properties) {
            return new OpenChannelRequest(properties);
        };

        /**
         * Encodes the specified OpenChannelRequest message. Does not implicitly {@link lnrpc.OpenChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest} message OpenChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodePubkey != null && Object.hasOwnProperty.call(message, "nodePubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nodePubkey);
            if (message.nodePubkeyString != null && Object.hasOwnProperty.call(message, "nodePubkeyString"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nodePubkeyString);
            if (message.localFundingAmount != null && Object.hasOwnProperty.call(message, "localFundingAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.localFundingAmount);
            if (message.pushSat != null && Object.hasOwnProperty.call(message, "pushSat"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.pushSat);
            if (message.targetConf != null && Object.hasOwnProperty.call(message, "targetConf"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.targetConf);
            if (message.satPerByte != null && Object.hasOwnProperty.call(message, "satPerByte"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.satPerByte);
            if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message["private"]);
            if (message.minHtlcMsat != null && Object.hasOwnProperty.call(message, "minHtlcMsat"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.minHtlcMsat);
            if (message.remoteCsvDelay != null && Object.hasOwnProperty.call(message, "remoteCsvDelay"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.remoteCsvDelay);
            if (message.minConfs != null && Object.hasOwnProperty.call(message, "minConfs"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.minConfs);
            if (message.spendUnconfirmed != null && Object.hasOwnProperty.call(message, "spendUnconfirmed"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.spendUnconfirmed);
            if (message.closeAddress != null && Object.hasOwnProperty.call(message, "closeAddress"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.closeAddress);
            if (message.fundingShim != null && Object.hasOwnProperty.call(message, "fundingShim"))
                $root.lnrpc.FundingShim.encode(message.fundingShim, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.remoteMaxValueInFlightMsat != null && Object.hasOwnProperty.call(message, "remoteMaxValueInFlightMsat"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.remoteMaxValueInFlightMsat);
            if (message.remoteMaxHtlcs != null && Object.hasOwnProperty.call(message, "remoteMaxHtlcs"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.remoteMaxHtlcs);
            return writer;
        };

        /**
         * Encodes the specified OpenChannelRequest message, length delimited. Does not implicitly {@link lnrpc.OpenChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest} message OpenChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OpenChannelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.nodePubkey = reader.bytes();
                    break;
                case 3:
                    message.nodePubkeyString = reader.string();
                    break;
                case 4:
                    message.localFundingAmount = reader.int64();
                    break;
                case 5:
                    message.pushSat = reader.int64();
                    break;
                case 6:
                    message.targetConf = reader.int32();
                    break;
                case 7:
                    message.satPerByte = reader.int64();
                    break;
                case 8:
                    message["private"] = reader.bool();
                    break;
                case 9:
                    message.minHtlcMsat = reader.int64();
                    break;
                case 10:
                    message.remoteCsvDelay = reader.uint32();
                    break;
                case 11:
                    message.minConfs = reader.int32();
                    break;
                case 12:
                    message.spendUnconfirmed = reader.bool();
                    break;
                case 13:
                    message.closeAddress = reader.string();
                    break;
                case 14:
                    message.fundingShim = $root.lnrpc.FundingShim.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.remoteMaxValueInFlightMsat = reader.uint64();
                    break;
                case 16:
                    message.remoteMaxHtlcs = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenChannelRequest message.
         * @function verify
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                if (!(message.nodePubkey && typeof message.nodePubkey.length === "number" || $util.isString(message.nodePubkey)))
                    return "nodePubkey: buffer expected";
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                if (!$util.isString(message.nodePubkeyString))
                    return "nodePubkeyString: string expected";
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                if (!$util.isInteger(message.localFundingAmount) && !(message.localFundingAmount && $util.isInteger(message.localFundingAmount.low) && $util.isInteger(message.localFundingAmount.high)))
                    return "localFundingAmount: integer|Long expected";
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                if (!$util.isInteger(message.pushSat) && !(message.pushSat && $util.isInteger(message.pushSat.low) && $util.isInteger(message.pushSat.high)))
                    return "pushSat: integer|Long expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (!$util.isInteger(message.minHtlcMsat) && !(message.minHtlcMsat && $util.isInteger(message.minHtlcMsat.low) && $util.isInteger(message.minHtlcMsat.high)))
                    return "minHtlcMsat: integer|Long expected";
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                if (!$util.isInteger(message.remoteCsvDelay))
                    return "remoteCsvDelay: integer expected";
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                if (!$util.isInteger(message.minConfs))
                    return "minConfs: integer expected";
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                if (typeof message.spendUnconfirmed !== "boolean")
                    return "spendUnconfirmed: boolean expected";
            if (message.closeAddress != null && message.hasOwnProperty("closeAddress"))
                if (!$util.isString(message.closeAddress))
                    return "closeAddress: string expected";
            if (message.fundingShim != null && message.hasOwnProperty("fundingShim")) {
                let error = $root.lnrpc.FundingShim.verify(message.fundingShim);
                if (error)
                    return "fundingShim." + error;
            }
            if (message.remoteMaxValueInFlightMsat != null && message.hasOwnProperty("remoteMaxValueInFlightMsat"))
                if (!$util.isInteger(message.remoteMaxValueInFlightMsat) && !(message.remoteMaxValueInFlightMsat && $util.isInteger(message.remoteMaxValueInFlightMsat.low) && $util.isInteger(message.remoteMaxValueInFlightMsat.high)))
                    return "remoteMaxValueInFlightMsat: integer|Long expected";
            if (message.remoteMaxHtlcs != null && message.hasOwnProperty("remoteMaxHtlcs"))
                if (!$util.isInteger(message.remoteMaxHtlcs))
                    return "remoteMaxHtlcs: integer expected";
            return null;
        };

        /**
         * Creates an OpenChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         */
        OpenChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OpenChannelRequest)
                return object;
            let message = new $root.lnrpc.OpenChannelRequest();
            if (object.nodePubkey != null)
                if (typeof object.nodePubkey === "string")
                    $util.base64.decode(object.nodePubkey, message.nodePubkey = $util.newBuffer($util.base64.length(object.nodePubkey)), 0);
                else if (object.nodePubkey.length)
                    message.nodePubkey = object.nodePubkey;
            if (object.nodePubkeyString != null)
                message.nodePubkeyString = String(object.nodePubkeyString);
            if (object.localFundingAmount != null)
                if ($util.Long)
                    (message.localFundingAmount = $util.Long.fromValue(object.localFundingAmount)).unsigned = false;
                else if (typeof object.localFundingAmount === "string")
                    message.localFundingAmount = parseInt(object.localFundingAmount, 10);
                else if (typeof object.localFundingAmount === "number")
                    message.localFundingAmount = object.localFundingAmount;
                else if (typeof object.localFundingAmount === "object")
                    message.localFundingAmount = new $util.LongBits(object.localFundingAmount.low >>> 0, object.localFundingAmount.high >>> 0).toNumber();
            if (object.pushSat != null)
                if ($util.Long)
                    (message.pushSat = $util.Long.fromValue(object.pushSat)).unsigned = false;
                else if (typeof object.pushSat === "string")
                    message.pushSat = parseInt(object.pushSat, 10);
                else if (typeof object.pushSat === "number")
                    message.pushSat = object.pushSat;
                else if (typeof object.pushSat === "object")
                    message.pushSat = new $util.LongBits(object.pushSat.low >>> 0, object.pushSat.high >>> 0).toNumber();
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.minHtlcMsat != null)
                if ($util.Long)
                    (message.minHtlcMsat = $util.Long.fromValue(object.minHtlcMsat)).unsigned = false;
                else if (typeof object.minHtlcMsat === "string")
                    message.minHtlcMsat = parseInt(object.minHtlcMsat, 10);
                else if (typeof object.minHtlcMsat === "number")
                    message.minHtlcMsat = object.minHtlcMsat;
                else if (typeof object.minHtlcMsat === "object")
                    message.minHtlcMsat = new $util.LongBits(object.minHtlcMsat.low >>> 0, object.minHtlcMsat.high >>> 0).toNumber();
            if (object.remoteCsvDelay != null)
                message.remoteCsvDelay = object.remoteCsvDelay >>> 0;
            if (object.minConfs != null)
                message.minConfs = object.minConfs | 0;
            if (object.spendUnconfirmed != null)
                message.spendUnconfirmed = Boolean(object.spendUnconfirmed);
            if (object.closeAddress != null)
                message.closeAddress = String(object.closeAddress);
            if (object.fundingShim != null) {
                if (typeof object.fundingShim !== "object")
                    throw TypeError(".lnrpc.OpenChannelRequest.fundingShim: object expected");
                message.fundingShim = $root.lnrpc.FundingShim.fromObject(object.fundingShim);
            }
            if (object.remoteMaxValueInFlightMsat != null)
                if ($util.Long)
                    (message.remoteMaxValueInFlightMsat = $util.Long.fromValue(object.remoteMaxValueInFlightMsat)).unsigned = true;
                else if (typeof object.remoteMaxValueInFlightMsat === "string")
                    message.remoteMaxValueInFlightMsat = parseInt(object.remoteMaxValueInFlightMsat, 10);
                else if (typeof object.remoteMaxValueInFlightMsat === "number")
                    message.remoteMaxValueInFlightMsat = object.remoteMaxValueInFlightMsat;
                else if (typeof object.remoteMaxValueInFlightMsat === "object")
                    message.remoteMaxValueInFlightMsat = new $util.LongBits(object.remoteMaxValueInFlightMsat.low >>> 0, object.remoteMaxValueInFlightMsat.high >>> 0).toNumber(true);
            if (object.remoteMaxHtlcs != null)
                message.remoteMaxHtlcs = object.remoteMaxHtlcs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an OpenChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.OpenChannelRequest} message OpenChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nodePubkey = "";
                else {
                    object.nodePubkey = [];
                    if (options.bytes !== Array)
                        object.nodePubkey = $util.newBuffer(object.nodePubkey);
                }
                object.nodePubkeyString = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.localFundingAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localFundingAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pushSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pushSat = options.longs === String ? "0" : 0;
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object["private"] = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.minHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlcMsat = options.longs === String ? "0" : 0;
                object.remoteCsvDelay = 0;
                object.minConfs = 0;
                object.spendUnconfirmed = false;
                object.closeAddress = "";
                object.fundingShim = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.remoteMaxValueInFlightMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remoteMaxValueInFlightMsat = options.longs === String ? "0" : 0;
                object.remoteMaxHtlcs = 0;
            }
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                object.nodePubkey = options.bytes === String ? $util.base64.encode(message.nodePubkey, 0, message.nodePubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodePubkey) : message.nodePubkey;
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                object.nodePubkeyString = message.nodePubkeyString;
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                if (typeof message.localFundingAmount === "number")
                    object.localFundingAmount = options.longs === String ? String(message.localFundingAmount) : message.localFundingAmount;
                else
                    object.localFundingAmount = options.longs === String ? $util.Long.prototype.toString.call(message.localFundingAmount) : options.longs === Number ? new $util.LongBits(message.localFundingAmount.low >>> 0, message.localFundingAmount.high >>> 0).toNumber() : message.localFundingAmount;
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                if (typeof message.pushSat === "number")
                    object.pushSat = options.longs === String ? String(message.pushSat) : message.pushSat;
                else
                    object.pushSat = options.longs === String ? $util.Long.prototype.toString.call(message.pushSat) : options.longs === Number ? new $util.LongBits(message.pushSat.low >>> 0, message.pushSat.high >>> 0).toNumber() : message.pushSat;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (typeof message.minHtlcMsat === "number")
                    object.minHtlcMsat = options.longs === String ? String(message.minHtlcMsat) : message.minHtlcMsat;
                else
                    object.minHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlcMsat) : options.longs === Number ? new $util.LongBits(message.minHtlcMsat.low >>> 0, message.minHtlcMsat.high >>> 0).toNumber() : message.minHtlcMsat;
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                object.remoteCsvDelay = message.remoteCsvDelay;
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                object.minConfs = message.minConfs;
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                object.spendUnconfirmed = message.spendUnconfirmed;
            if (message.closeAddress != null && message.hasOwnProperty("closeAddress"))
                object.closeAddress = message.closeAddress;
            if (message.fundingShim != null && message.hasOwnProperty("fundingShim"))
                object.fundingShim = $root.lnrpc.FundingShim.toObject(message.fundingShim, options);
            if (message.remoteMaxValueInFlightMsat != null && message.hasOwnProperty("remoteMaxValueInFlightMsat"))
                if (typeof message.remoteMaxValueInFlightMsat === "number")
                    object.remoteMaxValueInFlightMsat = options.longs === String ? String(message.remoteMaxValueInFlightMsat) : message.remoteMaxValueInFlightMsat;
                else
                    object.remoteMaxValueInFlightMsat = options.longs === String ? $util.Long.prototype.toString.call(message.remoteMaxValueInFlightMsat) : options.longs === Number ? new $util.LongBits(message.remoteMaxValueInFlightMsat.low >>> 0, message.remoteMaxValueInFlightMsat.high >>> 0).toNumber(true) : message.remoteMaxValueInFlightMsat;
            if (message.remoteMaxHtlcs != null && message.hasOwnProperty("remoteMaxHtlcs"))
                object.remoteMaxHtlcs = message.remoteMaxHtlcs;
            return object;
        };

        /**
         * Converts this OpenChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenChannelRequest;
    })();

    lnrpc.OpenStatusUpdate = (function() {

        /**
         * Properties of an OpenStatusUpdate.
         * @memberof lnrpc
         * @interface IOpenStatusUpdate
         * @property {lnrpc.IPendingUpdate|null} [chanPending] OpenStatusUpdate chanPending
         * @property {lnrpc.IChannelOpenUpdate|null} [chanOpen] OpenStatusUpdate chanOpen
         * @property {lnrpc.IReadyForPsbtFunding|null} [psbtFund] OpenStatusUpdate psbtFund
         * @property {Uint8Array|null} [pendingChanId] OpenStatusUpdate pendingChanId
         */

        /**
         * Constructs a new OpenStatusUpdate.
         * @memberof lnrpc
         * @classdesc Represents an OpenStatusUpdate.
         * @implements IOpenStatusUpdate
         * @constructor
         * @param {lnrpc.IOpenStatusUpdate=} [properties] Properties to set
         */
        function OpenStatusUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenStatusUpdate chanPending.
         * @member {lnrpc.IPendingUpdate|null|undefined} chanPending
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.chanPending = null;

        /**
         * OpenStatusUpdate chanOpen.
         * @member {lnrpc.IChannelOpenUpdate|null|undefined} chanOpen
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.chanOpen = null;

        /**
         * OpenStatusUpdate psbtFund.
         * @member {lnrpc.IReadyForPsbtFunding|null|undefined} psbtFund
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.psbtFund = null;

        /**
         * OpenStatusUpdate pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.pendingChanId = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * OpenStatusUpdate update.
         * @member {"chanPending"|"chanOpen"|"psbtFund"|undefined} update
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        Object.defineProperty(OpenStatusUpdate.prototype, "update", {
            get: $util.oneOfGetter($oneOfFields = ["chanPending", "chanOpen", "psbtFund"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new OpenStatusUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate=} [properties] Properties to set
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate instance
         */
        OpenStatusUpdate.create = function create(properties) {
            return new OpenStatusUpdate(properties);
        };

        /**
         * Encodes the specified OpenStatusUpdate message. Does not implicitly {@link lnrpc.OpenStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate} message OpenStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPending != null && Object.hasOwnProperty.call(message, "chanPending"))
                $root.lnrpc.PendingUpdate.encode(message.chanPending, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chanOpen != null && Object.hasOwnProperty.call(message, "chanOpen"))
                $root.lnrpc.ChannelOpenUpdate.encode(message.chanOpen, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.pendingChanId);
            if (message.psbtFund != null && Object.hasOwnProperty.call(message, "psbtFund"))
                $root.lnrpc.ReadyForPsbtFunding.encode(message.psbtFund, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenStatusUpdate message, length delimited. Does not implicitly {@link lnrpc.OpenStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate} message OpenStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OpenStatusUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPending = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chanOpen = $root.lnrpc.ChannelOpenUpdate.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.psbtFund = $root.lnrpc.ReadyForPsbtFunding.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.pendingChanId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenStatusUpdate message.
         * @function verify
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.chanPending != null && message.hasOwnProperty("chanPending")) {
                properties.update = 1;
                {
                    let error = $root.lnrpc.PendingUpdate.verify(message.chanPending);
                    if (error)
                        return "chanPending." + error;
                }
            }
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    let error = $root.lnrpc.ChannelOpenUpdate.verify(message.chanOpen);
                    if (error)
                        return "chanOpen." + error;
                }
            }
            if (message.psbtFund != null && message.hasOwnProperty("psbtFund")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    let error = $root.lnrpc.ReadyForPsbtFunding.verify(message.psbtFund);
                    if (error)
                        return "psbtFund." + error;
                }
            }
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            return null;
        };

        /**
         * Creates an OpenStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         */
        OpenStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OpenStatusUpdate)
                return object;
            let message = new $root.lnrpc.OpenStatusUpdate();
            if (object.chanPending != null) {
                if (typeof object.chanPending !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.chanPending: object expected");
                message.chanPending = $root.lnrpc.PendingUpdate.fromObject(object.chanPending);
            }
            if (object.chanOpen != null) {
                if (typeof object.chanOpen !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.chanOpen: object expected");
                message.chanOpen = $root.lnrpc.ChannelOpenUpdate.fromObject(object.chanOpen);
            }
            if (object.psbtFund != null) {
                if (typeof object.psbtFund !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.psbtFund: object expected");
                message.psbtFund = $root.lnrpc.ReadyForPsbtFunding.fromObject(object.psbtFund);
            }
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            return message;
        };

        /**
         * Creates a plain object from an OpenStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.OpenStatusUpdate} message OpenStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
            if (message.chanPending != null && message.hasOwnProperty("chanPending")) {
                object.chanPending = $root.lnrpc.PendingUpdate.toObject(message.chanPending, options);
                if (options.oneofs)
                    object.update = "chanPending";
            }
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen")) {
                object.chanOpen = $root.lnrpc.ChannelOpenUpdate.toObject(message.chanOpen, options);
                if (options.oneofs)
                    object.update = "chanOpen";
            }
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            if (message.psbtFund != null && message.hasOwnProperty("psbtFund")) {
                object.psbtFund = $root.lnrpc.ReadyForPsbtFunding.toObject(message.psbtFund, options);
                if (options.oneofs)
                    object.update = "psbtFund";
            }
            return object;
        };

        /**
         * Converts this OpenStatusUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenStatusUpdate;
    })();

    lnrpc.KeyLocator = (function() {

        /**
         * Properties of a KeyLocator.
         * @memberof lnrpc
         * @interface IKeyLocator
         * @property {number|null} [keyFamily] KeyLocator keyFamily
         * @property {number|null} [keyIndex] KeyLocator keyIndex
         */

        /**
         * Constructs a new KeyLocator.
         * @memberof lnrpc
         * @classdesc Represents a KeyLocator.
         * @implements IKeyLocator
         * @constructor
         * @param {lnrpc.IKeyLocator=} [properties] Properties to set
         */
        function KeyLocator(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyLocator keyFamily.
         * @member {number} keyFamily
         * @memberof lnrpc.KeyLocator
         * @instance
         */
        KeyLocator.prototype.keyFamily = 0;

        /**
         * KeyLocator keyIndex.
         * @member {number} keyIndex
         * @memberof lnrpc.KeyLocator
         * @instance
         */
        KeyLocator.prototype.keyIndex = 0;

        /**
         * Creates a new KeyLocator instance using the specified properties.
         * @function create
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {lnrpc.IKeyLocator=} [properties] Properties to set
         * @returns {lnrpc.KeyLocator} KeyLocator instance
         */
        KeyLocator.create = function create(properties) {
            return new KeyLocator(properties);
        };

        /**
         * Encodes the specified KeyLocator message. Does not implicitly {@link lnrpc.KeyLocator.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {lnrpc.IKeyLocator} message KeyLocator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyLocator.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyFamily != null && Object.hasOwnProperty.call(message, "keyFamily"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.keyFamily);
            if (message.keyIndex != null && Object.hasOwnProperty.call(message, "keyIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.keyIndex);
            return writer;
        };

        /**
         * Encodes the specified KeyLocator message, length delimited. Does not implicitly {@link lnrpc.KeyLocator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {lnrpc.IKeyLocator} message KeyLocator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyLocator.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyLocator message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.KeyLocator} KeyLocator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyLocator.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.KeyLocator();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyFamily = reader.int32();
                    break;
                case 2:
                    message.keyIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyLocator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.KeyLocator} KeyLocator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyLocator.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyLocator message.
         * @function verify
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyLocator.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyFamily != null && message.hasOwnProperty("keyFamily"))
                if (!$util.isInteger(message.keyFamily))
                    return "keyFamily: integer expected";
            if (message.keyIndex != null && message.hasOwnProperty("keyIndex"))
                if (!$util.isInteger(message.keyIndex))
                    return "keyIndex: integer expected";
            return null;
        };

        /**
         * Creates a KeyLocator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.KeyLocator} KeyLocator
         */
        KeyLocator.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.KeyLocator)
                return object;
            let message = new $root.lnrpc.KeyLocator();
            if (object.keyFamily != null)
                message.keyFamily = object.keyFamily | 0;
            if (object.keyIndex != null)
                message.keyIndex = object.keyIndex | 0;
            return message;
        };

        /**
         * Creates a plain object from a KeyLocator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.KeyLocator
         * @static
         * @param {lnrpc.KeyLocator} message KeyLocator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyLocator.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.keyFamily = 0;
                object.keyIndex = 0;
            }
            if (message.keyFamily != null && message.hasOwnProperty("keyFamily"))
                object.keyFamily = message.keyFamily;
            if (message.keyIndex != null && message.hasOwnProperty("keyIndex"))
                object.keyIndex = message.keyIndex;
            return object;
        };

        /**
         * Converts this KeyLocator to JSON.
         * @function toJSON
         * @memberof lnrpc.KeyLocator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyLocator.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyLocator;
    })();

    lnrpc.KeyDescriptor = (function() {

        /**
         * Properties of a KeyDescriptor.
         * @memberof lnrpc
         * @interface IKeyDescriptor
         * @property {Uint8Array|null} [rawKeyBytes] KeyDescriptor rawKeyBytes
         * @property {lnrpc.IKeyLocator|null} [keyLoc] KeyDescriptor keyLoc
         */

        /**
         * Constructs a new KeyDescriptor.
         * @memberof lnrpc
         * @classdesc Represents a KeyDescriptor.
         * @implements IKeyDescriptor
         * @constructor
         * @param {lnrpc.IKeyDescriptor=} [properties] Properties to set
         */
        function KeyDescriptor(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyDescriptor rawKeyBytes.
         * @member {Uint8Array} rawKeyBytes
         * @memberof lnrpc.KeyDescriptor
         * @instance
         */
        KeyDescriptor.prototype.rawKeyBytes = $util.newBuffer([]);

        /**
         * KeyDescriptor keyLoc.
         * @member {lnrpc.IKeyLocator|null|undefined} keyLoc
         * @memberof lnrpc.KeyDescriptor
         * @instance
         */
        KeyDescriptor.prototype.keyLoc = null;

        /**
         * Creates a new KeyDescriptor instance using the specified properties.
         * @function create
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {lnrpc.IKeyDescriptor=} [properties] Properties to set
         * @returns {lnrpc.KeyDescriptor} KeyDescriptor instance
         */
        KeyDescriptor.create = function create(properties) {
            return new KeyDescriptor(properties);
        };

        /**
         * Encodes the specified KeyDescriptor message. Does not implicitly {@link lnrpc.KeyDescriptor.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {lnrpc.IKeyDescriptor} message KeyDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawKeyBytes != null && Object.hasOwnProperty.call(message, "rawKeyBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rawKeyBytes);
            if (message.keyLoc != null && Object.hasOwnProperty.call(message, "keyLoc"))
                $root.lnrpc.KeyLocator.encode(message.keyLoc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified KeyDescriptor message, length delimited. Does not implicitly {@link lnrpc.KeyDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {lnrpc.IKeyDescriptor} message KeyDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.KeyDescriptor} KeyDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.KeyDescriptor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rawKeyBytes = reader.bytes();
                    break;
                case 2:
                    message.keyLoc = $root.lnrpc.KeyLocator.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.KeyDescriptor} KeyDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyDescriptor message.
         * @function verify
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawKeyBytes != null && message.hasOwnProperty("rawKeyBytes"))
                if (!(message.rawKeyBytes && typeof message.rawKeyBytes.length === "number" || $util.isString(message.rawKeyBytes)))
                    return "rawKeyBytes: buffer expected";
            if (message.keyLoc != null && message.hasOwnProperty("keyLoc")) {
                let error = $root.lnrpc.KeyLocator.verify(message.keyLoc);
                if (error)
                    return "keyLoc." + error;
            }
            return null;
        };

        /**
         * Creates a KeyDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.KeyDescriptor} KeyDescriptor
         */
        KeyDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.KeyDescriptor)
                return object;
            let message = new $root.lnrpc.KeyDescriptor();
            if (object.rawKeyBytes != null)
                if (typeof object.rawKeyBytes === "string")
                    $util.base64.decode(object.rawKeyBytes, message.rawKeyBytes = $util.newBuffer($util.base64.length(object.rawKeyBytes)), 0);
                else if (object.rawKeyBytes.length)
                    message.rawKeyBytes = object.rawKeyBytes;
            if (object.keyLoc != null) {
                if (typeof object.keyLoc !== "object")
                    throw TypeError(".lnrpc.KeyDescriptor.keyLoc: object expected");
                message.keyLoc = $root.lnrpc.KeyLocator.fromObject(object.keyLoc);
            }
            return message;
        };

        /**
         * Creates a plain object from a KeyDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.KeyDescriptor
         * @static
         * @param {lnrpc.KeyDescriptor} message KeyDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.rawKeyBytes = "";
                else {
                    object.rawKeyBytes = [];
                    if (options.bytes !== Array)
                        object.rawKeyBytes = $util.newBuffer(object.rawKeyBytes);
                }
                object.keyLoc = null;
            }
            if (message.rawKeyBytes != null && message.hasOwnProperty("rawKeyBytes"))
                object.rawKeyBytes = options.bytes === String ? $util.base64.encode(message.rawKeyBytes, 0, message.rawKeyBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawKeyBytes) : message.rawKeyBytes;
            if (message.keyLoc != null && message.hasOwnProperty("keyLoc"))
                object.keyLoc = $root.lnrpc.KeyLocator.toObject(message.keyLoc, options);
            return object;
        };

        /**
         * Converts this KeyDescriptor to JSON.
         * @function toJSON
         * @memberof lnrpc.KeyDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyDescriptor;
    })();

    lnrpc.ChanPointShim = (function() {

        /**
         * Properties of a ChanPointShim.
         * @memberof lnrpc
         * @interface IChanPointShim
         * @property {number|Long|null} [amt] ChanPointShim amt
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ChanPointShim chanPoint
         * @property {lnrpc.IKeyDescriptor|null} [localKey] ChanPointShim localKey
         * @property {Uint8Array|null} [remoteKey] ChanPointShim remoteKey
         * @property {Uint8Array|null} [pendingChanId] ChanPointShim pendingChanId
         * @property {number|null} [thawHeight] ChanPointShim thawHeight
         */

        /**
         * Constructs a new ChanPointShim.
         * @memberof lnrpc
         * @classdesc Represents a ChanPointShim.
         * @implements IChanPointShim
         * @constructor
         * @param {lnrpc.IChanPointShim=} [properties] Properties to set
         */
        function ChanPointShim(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChanPointShim amt.
         * @member {number|Long} amt
         * @memberof lnrpc.ChanPointShim
         * @instance
         */
        ChanPointShim.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChanPointShim chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ChanPointShim
         * @instance
         */
        ChanPointShim.prototype.chanPoint = null;

        /**
         * ChanPointShim localKey.
         * @member {lnrpc.IKeyDescriptor|null|undefined} localKey
         * @memberof lnrpc.ChanPointShim
         * @instance
         */
        ChanPointShim.prototype.localKey = null;

        /**
         * ChanPointShim remoteKey.
         * @member {Uint8Array} remoteKey
         * @memberof lnrpc.ChanPointShim
         * @instance
         */
        ChanPointShim.prototype.remoteKey = $util.newBuffer([]);

        /**
         * ChanPointShim pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.ChanPointShim
         * @instance
         */
        ChanPointShim.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * ChanPointShim thawHeight.
         * @member {number} thawHeight
         * @memberof lnrpc.ChanPointShim
         * @instance
         */
        ChanPointShim.prototype.thawHeight = 0;

        /**
         * Creates a new ChanPointShim instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {lnrpc.IChanPointShim=} [properties] Properties to set
         * @returns {lnrpc.ChanPointShim} ChanPointShim instance
         */
        ChanPointShim.create = function create(properties) {
            return new ChanPointShim(properties);
        };

        /**
         * Encodes the specified ChanPointShim message. Does not implicitly {@link lnrpc.ChanPointShim.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {lnrpc.IChanPointShim} message ChanPointShim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanPointShim.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.amt != null && Object.hasOwnProperty.call(message, "amt"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amt);
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.localKey != null && Object.hasOwnProperty.call(message, "localKey"))
                $root.lnrpc.KeyDescriptor.encode(message.localKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.remoteKey != null && Object.hasOwnProperty.call(message, "remoteKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.remoteKey);
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.pendingChanId);
            if (message.thawHeight != null && Object.hasOwnProperty.call(message, "thawHeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.thawHeight);
            return writer;
        };

        /**
         * Encodes the specified ChanPointShim message, length delimited. Does not implicitly {@link lnrpc.ChanPointShim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {lnrpc.IChanPointShim} message ChanPointShim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanPointShim.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanPointShim message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanPointShim} ChanPointShim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanPointShim.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanPointShim();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.amt = reader.int64();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.localKey = $root.lnrpc.KeyDescriptor.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.remoteKey = reader.bytes();
                    break;
                case 5:
                    message.pendingChanId = reader.bytes();
                    break;
                case 6:
                    message.thawHeight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanPointShim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanPointShim} ChanPointShim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanPointShim.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanPointShim message.
         * @function verify
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanPointShim.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            if (message.localKey != null && message.hasOwnProperty("localKey")) {
                let error = $root.lnrpc.KeyDescriptor.verify(message.localKey);
                if (error)
                    return "localKey." + error;
            }
            if (message.remoteKey != null && message.hasOwnProperty("remoteKey"))
                if (!(message.remoteKey && typeof message.remoteKey.length === "number" || $util.isString(message.remoteKey)))
                    return "remoteKey: buffer expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            if (message.thawHeight != null && message.hasOwnProperty("thawHeight"))
                if (!$util.isInteger(message.thawHeight))
                    return "thawHeight: integer expected";
            return null;
        };

        /**
         * Creates a ChanPointShim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanPointShim} ChanPointShim
         */
        ChanPointShim.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanPointShim)
                return object;
            let message = new $root.lnrpc.ChanPointShim();
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ChanPointShim.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.localKey != null) {
                if (typeof object.localKey !== "object")
                    throw TypeError(".lnrpc.ChanPointShim.localKey: object expected");
                message.localKey = $root.lnrpc.KeyDescriptor.fromObject(object.localKey);
            }
            if (object.remoteKey != null)
                if (typeof object.remoteKey === "string")
                    $util.base64.decode(object.remoteKey, message.remoteKey = $util.newBuffer($util.base64.length(object.remoteKey)), 0);
                else if (object.remoteKey.length)
                    message.remoteKey = object.remoteKey;
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            if (object.thawHeight != null)
                message.thawHeight = object.thawHeight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChanPointShim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanPointShim
         * @static
         * @param {lnrpc.ChanPointShim} message ChanPointShim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanPointShim.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                object.chanPoint = null;
                object.localKey = null;
                if (options.bytes === String)
                    object.remoteKey = "";
                else {
                    object.remoteKey = [];
                    if (options.bytes !== Array)
                        object.remoteKey = $util.newBuffer(object.remoteKey);
                }
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
                object.thawHeight = 0;
            }
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            if (message.localKey != null && message.hasOwnProperty("localKey"))
                object.localKey = $root.lnrpc.KeyDescriptor.toObject(message.localKey, options);
            if (message.remoteKey != null && message.hasOwnProperty("remoteKey"))
                object.remoteKey = options.bytes === String ? $util.base64.encode(message.remoteKey, 0, message.remoteKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.remoteKey) : message.remoteKey;
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            if (message.thawHeight != null && message.hasOwnProperty("thawHeight"))
                object.thawHeight = message.thawHeight;
            return object;
        };

        /**
         * Converts this ChanPointShim to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanPointShim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanPointShim.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanPointShim;
    })();

    lnrpc.PsbtShim = (function() {

        /**
         * Properties of a PsbtShim.
         * @memberof lnrpc
         * @interface IPsbtShim
         * @property {Uint8Array|null} [pendingChanId] PsbtShim pendingChanId
         * @property {Uint8Array|null} [basePsbt] PsbtShim basePsbt
         * @property {boolean|null} [noPublish] PsbtShim noPublish
         */

        /**
         * Constructs a new PsbtShim.
         * @memberof lnrpc
         * @classdesc Represents a PsbtShim.
         * @implements IPsbtShim
         * @constructor
         * @param {lnrpc.IPsbtShim=} [properties] Properties to set
         */
        function PsbtShim(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PsbtShim pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.PsbtShim
         * @instance
         */
        PsbtShim.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * PsbtShim basePsbt.
         * @member {Uint8Array} basePsbt
         * @memberof lnrpc.PsbtShim
         * @instance
         */
        PsbtShim.prototype.basePsbt = $util.newBuffer([]);

        /**
         * PsbtShim noPublish.
         * @member {boolean} noPublish
         * @memberof lnrpc.PsbtShim
         * @instance
         */
        PsbtShim.prototype.noPublish = false;

        /**
         * Creates a new PsbtShim instance using the specified properties.
         * @function create
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {lnrpc.IPsbtShim=} [properties] Properties to set
         * @returns {lnrpc.PsbtShim} PsbtShim instance
         */
        PsbtShim.create = function create(properties) {
            return new PsbtShim(properties);
        };

        /**
         * Encodes the specified PsbtShim message. Does not implicitly {@link lnrpc.PsbtShim.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {lnrpc.IPsbtShim} message PsbtShim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PsbtShim.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pendingChanId);
            if (message.basePsbt != null && Object.hasOwnProperty.call(message, "basePsbt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.basePsbt);
            if (message.noPublish != null && Object.hasOwnProperty.call(message, "noPublish"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.noPublish);
            return writer;
        };

        /**
         * Encodes the specified PsbtShim message, length delimited. Does not implicitly {@link lnrpc.PsbtShim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {lnrpc.IPsbtShim} message PsbtShim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PsbtShim.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PsbtShim message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PsbtShim} PsbtShim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PsbtShim.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PsbtShim();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pendingChanId = reader.bytes();
                    break;
                case 2:
                    message.basePsbt = reader.bytes();
                    break;
                case 3:
                    message.noPublish = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PsbtShim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PsbtShim} PsbtShim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PsbtShim.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PsbtShim message.
         * @function verify
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PsbtShim.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            if (message.basePsbt != null && message.hasOwnProperty("basePsbt"))
                if (!(message.basePsbt && typeof message.basePsbt.length === "number" || $util.isString(message.basePsbt)))
                    return "basePsbt: buffer expected";
            if (message.noPublish != null && message.hasOwnProperty("noPublish"))
                if (typeof message.noPublish !== "boolean")
                    return "noPublish: boolean expected";
            return null;
        };

        /**
         * Creates a PsbtShim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PsbtShim} PsbtShim
         */
        PsbtShim.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PsbtShim)
                return object;
            let message = new $root.lnrpc.PsbtShim();
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            if (object.basePsbt != null)
                if (typeof object.basePsbt === "string")
                    $util.base64.decode(object.basePsbt, message.basePsbt = $util.newBuffer($util.base64.length(object.basePsbt)), 0);
                else if (object.basePsbt.length)
                    message.basePsbt = object.basePsbt;
            if (object.noPublish != null)
                message.noPublish = Boolean(object.noPublish);
            return message;
        };

        /**
         * Creates a plain object from a PsbtShim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PsbtShim
         * @static
         * @param {lnrpc.PsbtShim} message PsbtShim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PsbtShim.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
                if (options.bytes === String)
                    object.basePsbt = "";
                else {
                    object.basePsbt = [];
                    if (options.bytes !== Array)
                        object.basePsbt = $util.newBuffer(object.basePsbt);
                }
                object.noPublish = false;
            }
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            if (message.basePsbt != null && message.hasOwnProperty("basePsbt"))
                object.basePsbt = options.bytes === String ? $util.base64.encode(message.basePsbt, 0, message.basePsbt.length) : options.bytes === Array ? Array.prototype.slice.call(message.basePsbt) : message.basePsbt;
            if (message.noPublish != null && message.hasOwnProperty("noPublish"))
                object.noPublish = message.noPublish;
            return object;
        };

        /**
         * Converts this PsbtShim to JSON.
         * @function toJSON
         * @memberof lnrpc.PsbtShim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PsbtShim.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PsbtShim;
    })();

    lnrpc.FundingShim = (function() {

        /**
         * Properties of a FundingShim.
         * @memberof lnrpc
         * @interface IFundingShim
         * @property {lnrpc.IChanPointShim|null} [chanPointShim] FundingShim chanPointShim
         * @property {lnrpc.IPsbtShim|null} [psbtShim] FundingShim psbtShim
         */

        /**
         * Constructs a new FundingShim.
         * @memberof lnrpc
         * @classdesc Represents a FundingShim.
         * @implements IFundingShim
         * @constructor
         * @param {lnrpc.IFundingShim=} [properties] Properties to set
         */
        function FundingShim(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingShim chanPointShim.
         * @member {lnrpc.IChanPointShim|null|undefined} chanPointShim
         * @memberof lnrpc.FundingShim
         * @instance
         */
        FundingShim.prototype.chanPointShim = null;

        /**
         * FundingShim psbtShim.
         * @member {lnrpc.IPsbtShim|null|undefined} psbtShim
         * @memberof lnrpc.FundingShim
         * @instance
         */
        FundingShim.prototype.psbtShim = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * FundingShim shim.
         * @member {"chanPointShim"|"psbtShim"|undefined} shim
         * @memberof lnrpc.FundingShim
         * @instance
         */
        Object.defineProperty(FundingShim.prototype, "shim", {
            get: $util.oneOfGetter($oneOfFields = ["chanPointShim", "psbtShim"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FundingShim instance using the specified properties.
         * @function create
         * @memberof lnrpc.FundingShim
         * @static
         * @param {lnrpc.IFundingShim=} [properties] Properties to set
         * @returns {lnrpc.FundingShim} FundingShim instance
         */
        FundingShim.create = function create(properties) {
            return new FundingShim(properties);
        };

        /**
         * Encodes the specified FundingShim message. Does not implicitly {@link lnrpc.FundingShim.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FundingShim
         * @static
         * @param {lnrpc.IFundingShim} message FundingShim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingShim.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPointShim != null && Object.hasOwnProperty.call(message, "chanPointShim"))
                $root.lnrpc.ChanPointShim.encode(message.chanPointShim, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.psbtShim != null && Object.hasOwnProperty.call(message, "psbtShim"))
                $root.lnrpc.PsbtShim.encode(message.psbtShim, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FundingShim message, length delimited. Does not implicitly {@link lnrpc.FundingShim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FundingShim
         * @static
         * @param {lnrpc.IFundingShim} message FundingShim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingShim.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingShim message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FundingShim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FundingShim} FundingShim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingShim.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FundingShim();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPointShim = $root.lnrpc.ChanPointShim.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.psbtShim = $root.lnrpc.PsbtShim.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingShim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FundingShim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FundingShim} FundingShim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingShim.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingShim message.
         * @function verify
         * @memberof lnrpc.FundingShim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingShim.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.chanPointShim != null && message.hasOwnProperty("chanPointShim")) {
                properties.shim = 1;
                {
                    let error = $root.lnrpc.ChanPointShim.verify(message.chanPointShim);
                    if (error)
                        return "chanPointShim." + error;
                }
            }
            if (message.psbtShim != null && message.hasOwnProperty("psbtShim")) {
                if (properties.shim === 1)
                    return "shim: multiple values";
                properties.shim = 1;
                {
                    let error = $root.lnrpc.PsbtShim.verify(message.psbtShim);
                    if (error)
                        return "psbtShim." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FundingShim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FundingShim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FundingShim} FundingShim
         */
        FundingShim.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FundingShim)
                return object;
            let message = new $root.lnrpc.FundingShim();
            if (object.chanPointShim != null) {
                if (typeof object.chanPointShim !== "object")
                    throw TypeError(".lnrpc.FundingShim.chanPointShim: object expected");
                message.chanPointShim = $root.lnrpc.ChanPointShim.fromObject(object.chanPointShim);
            }
            if (object.psbtShim != null) {
                if (typeof object.psbtShim !== "object")
                    throw TypeError(".lnrpc.FundingShim.psbtShim: object expected");
                message.psbtShim = $root.lnrpc.PsbtShim.fromObject(object.psbtShim);
            }
            return message;
        };

        /**
         * Creates a plain object from a FundingShim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FundingShim
         * @static
         * @param {lnrpc.FundingShim} message FundingShim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingShim.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.chanPointShim != null && message.hasOwnProperty("chanPointShim")) {
                object.chanPointShim = $root.lnrpc.ChanPointShim.toObject(message.chanPointShim, options);
                if (options.oneofs)
                    object.shim = "chanPointShim";
            }
            if (message.psbtShim != null && message.hasOwnProperty("psbtShim")) {
                object.psbtShim = $root.lnrpc.PsbtShim.toObject(message.psbtShim, options);
                if (options.oneofs)
                    object.shim = "psbtShim";
            }
            return object;
        };

        /**
         * Converts this FundingShim to JSON.
         * @function toJSON
         * @memberof lnrpc.FundingShim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingShim.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingShim;
    })();

    lnrpc.FundingShimCancel = (function() {

        /**
         * Properties of a FundingShimCancel.
         * @memberof lnrpc
         * @interface IFundingShimCancel
         * @property {Uint8Array|null} [pendingChanId] FundingShimCancel pendingChanId
         */

        /**
         * Constructs a new FundingShimCancel.
         * @memberof lnrpc
         * @classdesc Represents a FundingShimCancel.
         * @implements IFundingShimCancel
         * @constructor
         * @param {lnrpc.IFundingShimCancel=} [properties] Properties to set
         */
        function FundingShimCancel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingShimCancel pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.FundingShimCancel
         * @instance
         */
        FundingShimCancel.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * Creates a new FundingShimCancel instance using the specified properties.
         * @function create
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {lnrpc.IFundingShimCancel=} [properties] Properties to set
         * @returns {lnrpc.FundingShimCancel} FundingShimCancel instance
         */
        FundingShimCancel.create = function create(properties) {
            return new FundingShimCancel(properties);
        };

        /**
         * Encodes the specified FundingShimCancel message. Does not implicitly {@link lnrpc.FundingShimCancel.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {lnrpc.IFundingShimCancel} message FundingShimCancel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingShimCancel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pendingChanId);
            return writer;
        };

        /**
         * Encodes the specified FundingShimCancel message, length delimited. Does not implicitly {@link lnrpc.FundingShimCancel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {lnrpc.IFundingShimCancel} message FundingShimCancel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingShimCancel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingShimCancel message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FundingShimCancel} FundingShimCancel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingShimCancel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FundingShimCancel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pendingChanId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingShimCancel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FundingShimCancel} FundingShimCancel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingShimCancel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingShimCancel message.
         * @function verify
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingShimCancel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            return null;
        };

        /**
         * Creates a FundingShimCancel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FundingShimCancel} FundingShimCancel
         */
        FundingShimCancel.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FundingShimCancel)
                return object;
            let message = new $root.lnrpc.FundingShimCancel();
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            return message;
        };

        /**
         * Creates a plain object from a FundingShimCancel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FundingShimCancel
         * @static
         * @param {lnrpc.FundingShimCancel} message FundingShimCancel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingShimCancel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            return object;
        };

        /**
         * Converts this FundingShimCancel to JSON.
         * @function toJSON
         * @memberof lnrpc.FundingShimCancel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingShimCancel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingShimCancel;
    })();

    lnrpc.FundingPsbtVerify = (function() {

        /**
         * Properties of a FundingPsbtVerify.
         * @memberof lnrpc
         * @interface IFundingPsbtVerify
         * @property {Uint8Array|null} [fundedPsbt] FundingPsbtVerify fundedPsbt
         * @property {Uint8Array|null} [pendingChanId] FundingPsbtVerify pendingChanId
         */

        /**
         * Constructs a new FundingPsbtVerify.
         * @memberof lnrpc
         * @classdesc Represents a FundingPsbtVerify.
         * @implements IFundingPsbtVerify
         * @constructor
         * @param {lnrpc.IFundingPsbtVerify=} [properties] Properties to set
         */
        function FundingPsbtVerify(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingPsbtVerify fundedPsbt.
         * @member {Uint8Array} fundedPsbt
         * @memberof lnrpc.FundingPsbtVerify
         * @instance
         */
        FundingPsbtVerify.prototype.fundedPsbt = $util.newBuffer([]);

        /**
         * FundingPsbtVerify pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.FundingPsbtVerify
         * @instance
         */
        FundingPsbtVerify.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * Creates a new FundingPsbtVerify instance using the specified properties.
         * @function create
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {lnrpc.IFundingPsbtVerify=} [properties] Properties to set
         * @returns {lnrpc.FundingPsbtVerify} FundingPsbtVerify instance
         */
        FundingPsbtVerify.create = function create(properties) {
            return new FundingPsbtVerify(properties);
        };

        /**
         * Encodes the specified FundingPsbtVerify message. Does not implicitly {@link lnrpc.FundingPsbtVerify.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {lnrpc.IFundingPsbtVerify} message FundingPsbtVerify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingPsbtVerify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fundedPsbt != null && Object.hasOwnProperty.call(message, "fundedPsbt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fundedPsbt);
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pendingChanId);
            return writer;
        };

        /**
         * Encodes the specified FundingPsbtVerify message, length delimited. Does not implicitly {@link lnrpc.FundingPsbtVerify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {lnrpc.IFundingPsbtVerify} message FundingPsbtVerify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingPsbtVerify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingPsbtVerify message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FundingPsbtVerify} FundingPsbtVerify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingPsbtVerify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FundingPsbtVerify();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fundedPsbt = reader.bytes();
                    break;
                case 2:
                    message.pendingChanId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingPsbtVerify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FundingPsbtVerify} FundingPsbtVerify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingPsbtVerify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingPsbtVerify message.
         * @function verify
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingPsbtVerify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fundedPsbt != null && message.hasOwnProperty("fundedPsbt"))
                if (!(message.fundedPsbt && typeof message.fundedPsbt.length === "number" || $util.isString(message.fundedPsbt)))
                    return "fundedPsbt: buffer expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            return null;
        };

        /**
         * Creates a FundingPsbtVerify message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FundingPsbtVerify} FundingPsbtVerify
         */
        FundingPsbtVerify.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FundingPsbtVerify)
                return object;
            let message = new $root.lnrpc.FundingPsbtVerify();
            if (object.fundedPsbt != null)
                if (typeof object.fundedPsbt === "string")
                    $util.base64.decode(object.fundedPsbt, message.fundedPsbt = $util.newBuffer($util.base64.length(object.fundedPsbt)), 0);
                else if (object.fundedPsbt.length)
                    message.fundedPsbt = object.fundedPsbt;
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            return message;
        };

        /**
         * Creates a plain object from a FundingPsbtVerify message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FundingPsbtVerify
         * @static
         * @param {lnrpc.FundingPsbtVerify} message FundingPsbtVerify
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingPsbtVerify.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.fundedPsbt = "";
                else {
                    object.fundedPsbt = [];
                    if (options.bytes !== Array)
                        object.fundedPsbt = $util.newBuffer(object.fundedPsbt);
                }
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
            }
            if (message.fundedPsbt != null && message.hasOwnProperty("fundedPsbt"))
                object.fundedPsbt = options.bytes === String ? $util.base64.encode(message.fundedPsbt, 0, message.fundedPsbt.length) : options.bytes === Array ? Array.prototype.slice.call(message.fundedPsbt) : message.fundedPsbt;
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            return object;
        };

        /**
         * Converts this FundingPsbtVerify to JSON.
         * @function toJSON
         * @memberof lnrpc.FundingPsbtVerify
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingPsbtVerify.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingPsbtVerify;
    })();

    lnrpc.FundingPsbtFinalize = (function() {

        /**
         * Properties of a FundingPsbtFinalize.
         * @memberof lnrpc
         * @interface IFundingPsbtFinalize
         * @property {Uint8Array|null} [signedPsbt] FundingPsbtFinalize signedPsbt
         * @property {Uint8Array|null} [pendingChanId] FundingPsbtFinalize pendingChanId
         * @property {Uint8Array|null} [finalRawTx] FundingPsbtFinalize finalRawTx
         */

        /**
         * Constructs a new FundingPsbtFinalize.
         * @memberof lnrpc
         * @classdesc Represents a FundingPsbtFinalize.
         * @implements IFundingPsbtFinalize
         * @constructor
         * @param {lnrpc.IFundingPsbtFinalize=} [properties] Properties to set
         */
        function FundingPsbtFinalize(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingPsbtFinalize signedPsbt.
         * @member {Uint8Array} signedPsbt
         * @memberof lnrpc.FundingPsbtFinalize
         * @instance
         */
        FundingPsbtFinalize.prototype.signedPsbt = $util.newBuffer([]);

        /**
         * FundingPsbtFinalize pendingChanId.
         * @member {Uint8Array} pendingChanId
         * @memberof lnrpc.FundingPsbtFinalize
         * @instance
         */
        FundingPsbtFinalize.prototype.pendingChanId = $util.newBuffer([]);

        /**
         * FundingPsbtFinalize finalRawTx.
         * @member {Uint8Array} finalRawTx
         * @memberof lnrpc.FundingPsbtFinalize
         * @instance
         */
        FundingPsbtFinalize.prototype.finalRawTx = $util.newBuffer([]);

        /**
         * Creates a new FundingPsbtFinalize instance using the specified properties.
         * @function create
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {lnrpc.IFundingPsbtFinalize=} [properties] Properties to set
         * @returns {lnrpc.FundingPsbtFinalize} FundingPsbtFinalize instance
         */
        FundingPsbtFinalize.create = function create(properties) {
            return new FundingPsbtFinalize(properties);
        };

        /**
         * Encodes the specified FundingPsbtFinalize message. Does not implicitly {@link lnrpc.FundingPsbtFinalize.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {lnrpc.IFundingPsbtFinalize} message FundingPsbtFinalize message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingPsbtFinalize.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signedPsbt != null && Object.hasOwnProperty.call(message, "signedPsbt"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signedPsbt);
            if (message.pendingChanId != null && Object.hasOwnProperty.call(message, "pendingChanId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pendingChanId);
            if (message.finalRawTx != null && Object.hasOwnProperty.call(message, "finalRawTx"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.finalRawTx);
            return writer;
        };

        /**
         * Encodes the specified FundingPsbtFinalize message, length delimited. Does not implicitly {@link lnrpc.FundingPsbtFinalize.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {lnrpc.IFundingPsbtFinalize} message FundingPsbtFinalize message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingPsbtFinalize.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingPsbtFinalize message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FundingPsbtFinalize} FundingPsbtFinalize
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingPsbtFinalize.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FundingPsbtFinalize();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signedPsbt = reader.bytes();
                    break;
                case 2:
                    message.pendingChanId = reader.bytes();
                    break;
                case 3:
                    message.finalRawTx = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingPsbtFinalize message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FundingPsbtFinalize} FundingPsbtFinalize
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingPsbtFinalize.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingPsbtFinalize message.
         * @function verify
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingPsbtFinalize.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signedPsbt != null && message.hasOwnProperty("signedPsbt"))
                if (!(message.signedPsbt && typeof message.signedPsbt.length === "number" || $util.isString(message.signedPsbt)))
                    return "signedPsbt: buffer expected";
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                if (!(message.pendingChanId && typeof message.pendingChanId.length === "number" || $util.isString(message.pendingChanId)))
                    return "pendingChanId: buffer expected";
            if (message.finalRawTx != null && message.hasOwnProperty("finalRawTx"))
                if (!(message.finalRawTx && typeof message.finalRawTx.length === "number" || $util.isString(message.finalRawTx)))
                    return "finalRawTx: buffer expected";
            return null;
        };

        /**
         * Creates a FundingPsbtFinalize message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FundingPsbtFinalize} FundingPsbtFinalize
         */
        FundingPsbtFinalize.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FundingPsbtFinalize)
                return object;
            let message = new $root.lnrpc.FundingPsbtFinalize();
            if (object.signedPsbt != null)
                if (typeof object.signedPsbt === "string")
                    $util.base64.decode(object.signedPsbt, message.signedPsbt = $util.newBuffer($util.base64.length(object.signedPsbt)), 0);
                else if (object.signedPsbt.length)
                    message.signedPsbt = object.signedPsbt;
            if (object.pendingChanId != null)
                if (typeof object.pendingChanId === "string")
                    $util.base64.decode(object.pendingChanId, message.pendingChanId = $util.newBuffer($util.base64.length(object.pendingChanId)), 0);
                else if (object.pendingChanId.length)
                    message.pendingChanId = object.pendingChanId;
            if (object.finalRawTx != null)
                if (typeof object.finalRawTx === "string")
                    $util.base64.decode(object.finalRawTx, message.finalRawTx = $util.newBuffer($util.base64.length(object.finalRawTx)), 0);
                else if (object.finalRawTx.length)
                    message.finalRawTx = object.finalRawTx;
            return message;
        };

        /**
         * Creates a plain object from a FundingPsbtFinalize message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FundingPsbtFinalize
         * @static
         * @param {lnrpc.FundingPsbtFinalize} message FundingPsbtFinalize
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingPsbtFinalize.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.signedPsbt = "";
                else {
                    object.signedPsbt = [];
                    if (options.bytes !== Array)
                        object.signedPsbt = $util.newBuffer(object.signedPsbt);
                }
                if (options.bytes === String)
                    object.pendingChanId = "";
                else {
                    object.pendingChanId = [];
                    if (options.bytes !== Array)
                        object.pendingChanId = $util.newBuffer(object.pendingChanId);
                }
                if (options.bytes === String)
                    object.finalRawTx = "";
                else {
                    object.finalRawTx = [];
                    if (options.bytes !== Array)
                        object.finalRawTx = $util.newBuffer(object.finalRawTx);
                }
            }
            if (message.signedPsbt != null && message.hasOwnProperty("signedPsbt"))
                object.signedPsbt = options.bytes === String ? $util.base64.encode(message.signedPsbt, 0, message.signedPsbt.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedPsbt) : message.signedPsbt;
            if (message.pendingChanId != null && message.hasOwnProperty("pendingChanId"))
                object.pendingChanId = options.bytes === String ? $util.base64.encode(message.pendingChanId, 0, message.pendingChanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pendingChanId) : message.pendingChanId;
            if (message.finalRawTx != null && message.hasOwnProperty("finalRawTx"))
                object.finalRawTx = options.bytes === String ? $util.base64.encode(message.finalRawTx, 0, message.finalRawTx.length) : options.bytes === Array ? Array.prototype.slice.call(message.finalRawTx) : message.finalRawTx;
            return object;
        };

        /**
         * Converts this FundingPsbtFinalize to JSON.
         * @function toJSON
         * @memberof lnrpc.FundingPsbtFinalize
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingPsbtFinalize.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingPsbtFinalize;
    })();

    lnrpc.FundingTransitionMsg = (function() {

        /**
         * Properties of a FundingTransitionMsg.
         * @memberof lnrpc
         * @interface IFundingTransitionMsg
         * @property {lnrpc.IFundingShim|null} [shimRegister] FundingTransitionMsg shimRegister
         * @property {lnrpc.IFundingShimCancel|null} [shimCancel] FundingTransitionMsg shimCancel
         * @property {lnrpc.IFundingPsbtVerify|null} [psbtVerify] FundingTransitionMsg psbtVerify
         * @property {lnrpc.IFundingPsbtFinalize|null} [psbtFinalize] FundingTransitionMsg psbtFinalize
         */

        /**
         * Constructs a new FundingTransitionMsg.
         * @memberof lnrpc
         * @classdesc Represents a FundingTransitionMsg.
         * @implements IFundingTransitionMsg
         * @constructor
         * @param {lnrpc.IFundingTransitionMsg=} [properties] Properties to set
         */
        function FundingTransitionMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingTransitionMsg shimRegister.
         * @member {lnrpc.IFundingShim|null|undefined} shimRegister
         * @memberof lnrpc.FundingTransitionMsg
         * @instance
         */
        FundingTransitionMsg.prototype.shimRegister = null;

        /**
         * FundingTransitionMsg shimCancel.
         * @member {lnrpc.IFundingShimCancel|null|undefined} shimCancel
         * @memberof lnrpc.FundingTransitionMsg
         * @instance
         */
        FundingTransitionMsg.prototype.shimCancel = null;

        /**
         * FundingTransitionMsg psbtVerify.
         * @member {lnrpc.IFundingPsbtVerify|null|undefined} psbtVerify
         * @memberof lnrpc.FundingTransitionMsg
         * @instance
         */
        FundingTransitionMsg.prototype.psbtVerify = null;

        /**
         * FundingTransitionMsg psbtFinalize.
         * @member {lnrpc.IFundingPsbtFinalize|null|undefined} psbtFinalize
         * @memberof lnrpc.FundingTransitionMsg
         * @instance
         */
        FundingTransitionMsg.prototype.psbtFinalize = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * FundingTransitionMsg trigger.
         * @member {"shimRegister"|"shimCancel"|"psbtVerify"|"psbtFinalize"|undefined} trigger
         * @memberof lnrpc.FundingTransitionMsg
         * @instance
         */
        Object.defineProperty(FundingTransitionMsg.prototype, "trigger", {
            get: $util.oneOfGetter($oneOfFields = ["shimRegister", "shimCancel", "psbtVerify", "psbtFinalize"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FundingTransitionMsg instance using the specified properties.
         * @function create
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {lnrpc.IFundingTransitionMsg=} [properties] Properties to set
         * @returns {lnrpc.FundingTransitionMsg} FundingTransitionMsg instance
         */
        FundingTransitionMsg.create = function create(properties) {
            return new FundingTransitionMsg(properties);
        };

        /**
         * Encodes the specified FundingTransitionMsg message. Does not implicitly {@link lnrpc.FundingTransitionMsg.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {lnrpc.IFundingTransitionMsg} message FundingTransitionMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingTransitionMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shimRegister != null && Object.hasOwnProperty.call(message, "shimRegister"))
                $root.lnrpc.FundingShim.encode(message.shimRegister, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.shimCancel != null && Object.hasOwnProperty.call(message, "shimCancel"))
                $root.lnrpc.FundingShimCancel.encode(message.shimCancel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.psbtVerify != null && Object.hasOwnProperty.call(message, "psbtVerify"))
                $root.lnrpc.FundingPsbtVerify.encode(message.psbtVerify, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.psbtFinalize != null && Object.hasOwnProperty.call(message, "psbtFinalize"))
                $root.lnrpc.FundingPsbtFinalize.encode(message.psbtFinalize, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FundingTransitionMsg message, length delimited. Does not implicitly {@link lnrpc.FundingTransitionMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {lnrpc.IFundingTransitionMsg} message FundingTransitionMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingTransitionMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingTransitionMsg message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FundingTransitionMsg} FundingTransitionMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingTransitionMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FundingTransitionMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shimRegister = $root.lnrpc.FundingShim.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.shimCancel = $root.lnrpc.FundingShimCancel.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.psbtVerify = $root.lnrpc.FundingPsbtVerify.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.psbtFinalize = $root.lnrpc.FundingPsbtFinalize.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingTransitionMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FundingTransitionMsg} FundingTransitionMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingTransitionMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingTransitionMsg message.
         * @function verify
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingTransitionMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.shimRegister != null && message.hasOwnProperty("shimRegister")) {
                properties.trigger = 1;
                {
                    let error = $root.lnrpc.FundingShim.verify(message.shimRegister);
                    if (error)
                        return "shimRegister." + error;
                }
            }
            if (message.shimCancel != null && message.hasOwnProperty("shimCancel")) {
                if (properties.trigger === 1)
                    return "trigger: multiple values";
                properties.trigger = 1;
                {
                    let error = $root.lnrpc.FundingShimCancel.verify(message.shimCancel);
                    if (error)
                        return "shimCancel." + error;
                }
            }
            if (message.psbtVerify != null && message.hasOwnProperty("psbtVerify")) {
                if (properties.trigger === 1)
                    return "trigger: multiple values";
                properties.trigger = 1;
                {
                    let error = $root.lnrpc.FundingPsbtVerify.verify(message.psbtVerify);
                    if (error)
                        return "psbtVerify." + error;
                }
            }
            if (message.psbtFinalize != null && message.hasOwnProperty("psbtFinalize")) {
                if (properties.trigger === 1)
                    return "trigger: multiple values";
                properties.trigger = 1;
                {
                    let error = $root.lnrpc.FundingPsbtFinalize.verify(message.psbtFinalize);
                    if (error)
                        return "psbtFinalize." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FundingTransitionMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FundingTransitionMsg} FundingTransitionMsg
         */
        FundingTransitionMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FundingTransitionMsg)
                return object;
            let message = new $root.lnrpc.FundingTransitionMsg();
            if (object.shimRegister != null) {
                if (typeof object.shimRegister !== "object")
                    throw TypeError(".lnrpc.FundingTransitionMsg.shimRegister: object expected");
                message.shimRegister = $root.lnrpc.FundingShim.fromObject(object.shimRegister);
            }
            if (object.shimCancel != null) {
                if (typeof object.shimCancel !== "object")
                    throw TypeError(".lnrpc.FundingTransitionMsg.shimCancel: object expected");
                message.shimCancel = $root.lnrpc.FundingShimCancel.fromObject(object.shimCancel);
            }
            if (object.psbtVerify != null) {
                if (typeof object.psbtVerify !== "object")
                    throw TypeError(".lnrpc.FundingTransitionMsg.psbtVerify: object expected");
                message.psbtVerify = $root.lnrpc.FundingPsbtVerify.fromObject(object.psbtVerify);
            }
            if (object.psbtFinalize != null) {
                if (typeof object.psbtFinalize !== "object")
                    throw TypeError(".lnrpc.FundingTransitionMsg.psbtFinalize: object expected");
                message.psbtFinalize = $root.lnrpc.FundingPsbtFinalize.fromObject(object.psbtFinalize);
            }
            return message;
        };

        /**
         * Creates a plain object from a FundingTransitionMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FundingTransitionMsg
         * @static
         * @param {lnrpc.FundingTransitionMsg} message FundingTransitionMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingTransitionMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.shimRegister != null && message.hasOwnProperty("shimRegister")) {
                object.shimRegister = $root.lnrpc.FundingShim.toObject(message.shimRegister, options);
                if (options.oneofs)
                    object.trigger = "shimRegister";
            }
            if (message.shimCancel != null && message.hasOwnProperty("shimCancel")) {
                object.shimCancel = $root.lnrpc.FundingShimCancel.toObject(message.shimCancel, options);
                if (options.oneofs)
                    object.trigger = "shimCancel";
            }
            if (message.psbtVerify != null && message.hasOwnProperty("psbtVerify")) {
                object.psbtVerify = $root.lnrpc.FundingPsbtVerify.toObject(message.psbtVerify, options);
                if (options.oneofs)
                    object.trigger = "psbtVerify";
            }
            if (message.psbtFinalize != null && message.hasOwnProperty("psbtFinalize")) {
                object.psbtFinalize = $root.lnrpc.FundingPsbtFinalize.toObject(message.psbtFinalize, options);
                if (options.oneofs)
                    object.trigger = "psbtFinalize";
            }
            return object;
        };

        /**
         * Converts this FundingTransitionMsg to JSON.
         * @function toJSON
         * @memberof lnrpc.FundingTransitionMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingTransitionMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingTransitionMsg;
    })();

    lnrpc.FundingStateStepResp = (function() {

        /**
         * Properties of a FundingStateStepResp.
         * @memberof lnrpc
         * @interface IFundingStateStepResp
         */

        /**
         * Constructs a new FundingStateStepResp.
         * @memberof lnrpc
         * @classdesc Represents a FundingStateStepResp.
         * @implements IFundingStateStepResp
         * @constructor
         * @param {lnrpc.IFundingStateStepResp=} [properties] Properties to set
         */
        function FundingStateStepResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FundingStateStepResp instance using the specified properties.
         * @function create
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {lnrpc.IFundingStateStepResp=} [properties] Properties to set
         * @returns {lnrpc.FundingStateStepResp} FundingStateStepResp instance
         */
        FundingStateStepResp.create = function create(properties) {
            return new FundingStateStepResp(properties);
        };

        /**
         * Encodes the specified FundingStateStepResp message. Does not implicitly {@link lnrpc.FundingStateStepResp.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {lnrpc.IFundingStateStepResp} message FundingStateStepResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingStateStepResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FundingStateStepResp message, length delimited. Does not implicitly {@link lnrpc.FundingStateStepResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {lnrpc.IFundingStateStepResp} message FundingStateStepResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingStateStepResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingStateStepResp message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FundingStateStepResp} FundingStateStepResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingStateStepResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FundingStateStepResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingStateStepResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FundingStateStepResp} FundingStateStepResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingStateStepResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingStateStepResp message.
         * @function verify
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingStateStepResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FundingStateStepResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FundingStateStepResp} FundingStateStepResp
         */
        FundingStateStepResp.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FundingStateStepResp)
                return object;
            return new $root.lnrpc.FundingStateStepResp();
        };

        /**
         * Creates a plain object from a FundingStateStepResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FundingStateStepResp
         * @static
         * @param {lnrpc.FundingStateStepResp} message FundingStateStepResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingStateStepResp.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FundingStateStepResp to JSON.
         * @function toJSON
         * @memberof lnrpc.FundingStateStepResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingStateStepResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingStateStepResp;
    })();

    lnrpc.PendingHTLC = (function() {

        /**
         * Properties of a PendingHTLC.
         * @memberof lnrpc
         * @interface IPendingHTLC
         * @property {boolean|null} [incoming] PendingHTLC incoming
         * @property {number|Long|null} [amount] PendingHTLC amount
         * @property {string|null} [outpoint] PendingHTLC outpoint
         * @property {number|null} [maturityHeight] PendingHTLC maturityHeight
         * @property {number|null} [blocksTilMaturity] PendingHTLC blocksTilMaturity
         * @property {number|null} [stage] PendingHTLC stage
         */

        /**
         * Constructs a new PendingHTLC.
         * @memberof lnrpc
         * @classdesc Represents a PendingHTLC.
         * @implements IPendingHTLC
         * @constructor
         * @param {lnrpc.IPendingHTLC=} [properties] Properties to set
         */
        function PendingHTLC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingHTLC incoming.
         * @member {boolean} incoming
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.incoming = false;

        /**
         * PendingHTLC amount.
         * @member {number|Long} amount
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PendingHTLC outpoint.
         * @member {string} outpoint
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.outpoint = "";

        /**
         * PendingHTLC maturityHeight.
         * @member {number} maturityHeight
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.maturityHeight = 0;

        /**
         * PendingHTLC blocksTilMaturity.
         * @member {number} blocksTilMaturity
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.blocksTilMaturity = 0;

        /**
         * PendingHTLC stage.
         * @member {number} stage
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.stage = 0;

        /**
         * Creates a new PendingHTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC=} [properties] Properties to set
         * @returns {lnrpc.PendingHTLC} PendingHTLC instance
         */
        PendingHTLC.create = function create(properties) {
            return new PendingHTLC(properties);
        };

        /**
         * Encodes the specified PendingHTLC message. Does not implicitly {@link lnrpc.PendingHTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC} message PendingHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingHTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incoming != null && Object.hasOwnProperty.call(message, "incoming"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.incoming);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.outpoint != null && Object.hasOwnProperty.call(message, "outpoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.outpoint);
            if (message.maturityHeight != null && Object.hasOwnProperty.call(message, "maturityHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maturityHeight);
            if (message.blocksTilMaturity != null && Object.hasOwnProperty.call(message, "blocksTilMaturity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blocksTilMaturity);
            if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.stage);
            return writer;
        };

        /**
         * Encodes the specified PendingHTLC message, length delimited. Does not implicitly {@link lnrpc.PendingHTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC} message PendingHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingHTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingHTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingHTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingHTLC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incoming = reader.bool();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.outpoint = reader.string();
                    break;
                case 4:
                    message.maturityHeight = reader.uint32();
                    break;
                case 5:
                    message.blocksTilMaturity = reader.int32();
                    break;
                case 6:
                    message.stage = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingHTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingHTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingHTLC message.
         * @function verify
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingHTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                if (typeof message.incoming !== "boolean")
                    return "incoming: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                if (!$util.isString(message.outpoint))
                    return "outpoint: string expected";
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                if (!$util.isInteger(message.maturityHeight))
                    return "maturityHeight: integer expected";
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                if (!$util.isInteger(message.blocksTilMaturity))
                    return "blocksTilMaturity: integer expected";
            if (message.stage != null && message.hasOwnProperty("stage"))
                if (!$util.isInteger(message.stage))
                    return "stage: integer expected";
            return null;
        };

        /**
         * Creates a PendingHTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         */
        PendingHTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingHTLC)
                return object;
            let message = new $root.lnrpc.PendingHTLC();
            if (object.incoming != null)
                message.incoming = Boolean(object.incoming);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.outpoint != null)
                message.outpoint = String(object.outpoint);
            if (object.maturityHeight != null)
                message.maturityHeight = object.maturityHeight >>> 0;
            if (object.blocksTilMaturity != null)
                message.blocksTilMaturity = object.blocksTilMaturity | 0;
            if (object.stage != null)
                message.stage = object.stage >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendingHTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.PendingHTLC} message PendingHTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingHTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.incoming = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.outpoint = "";
                object.maturityHeight = 0;
                object.blocksTilMaturity = 0;
                object.stage = 0;
            }
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                object.incoming = message.incoming;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                object.outpoint = message.outpoint;
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                object.maturityHeight = message.maturityHeight;
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                object.blocksTilMaturity = message.blocksTilMaturity;
            if (message.stage != null && message.hasOwnProperty("stage"))
                object.stage = message.stage;
            return object;
        };

        /**
         * Converts this PendingHTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingHTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingHTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingHTLC;
    })();

    lnrpc.PendingChannelsRequest = (function() {

        /**
         * Properties of a PendingChannelsRequest.
         * @memberof lnrpc
         * @interface IPendingChannelsRequest
         */

        /**
         * Constructs a new PendingChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a PendingChannelsRequest.
         * @implements IPendingChannelsRequest
         * @constructor
         * @param {lnrpc.IPendingChannelsRequest=} [properties] Properties to set
         */
        function PendingChannelsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PendingChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest instance
         */
        PendingChannelsRequest.create = function create(properties) {
            return new PendingChannelsRequest(properties);
        };

        /**
         * Encodes the specified PendingChannelsRequest message. Does not implicitly {@link lnrpc.PendingChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest} message PendingChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PendingChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest} message PendingChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingChannelsRequest message.
         * @function verify
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PendingChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         */
        PendingChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingChannelsRequest)
                return object;
            return new $root.lnrpc.PendingChannelsRequest();
        };

        /**
         * Creates a plain object from a PendingChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.PendingChannelsRequest} message PendingChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingChannelsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PendingChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingChannelsRequest;
    })();

    lnrpc.PendingChannelsResponse = (function() {

        /**
         * Properties of a PendingChannelsResponse.
         * @memberof lnrpc
         * @interface IPendingChannelsResponse
         * @property {number|Long|null} [totalLimboBalance] PendingChannelsResponse totalLimboBalance
         * @property {Array.<lnrpc.PendingChannelsResponse.IPendingOpenChannel>|null} [pendingOpenChannels] PendingChannelsResponse pendingOpenChannels
         * @property {Array.<lnrpc.PendingChannelsResponse.IClosedChannel>|null} [pendingClosingChannels] PendingChannelsResponse pendingClosingChannels
         * @property {Array.<lnrpc.PendingChannelsResponse.IForceClosedChannel>|null} [pendingForceClosingChannels] PendingChannelsResponse pendingForceClosingChannels
         * @property {Array.<lnrpc.PendingChannelsResponse.IWaitingCloseChannel>|null} [waitingCloseChannels] PendingChannelsResponse waitingCloseChannels
         */

        /**
         * Constructs a new PendingChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a PendingChannelsResponse.
         * @implements IPendingChannelsResponse
         * @constructor
         * @param {lnrpc.IPendingChannelsResponse=} [properties] Properties to set
         */
        function PendingChannelsResponse(properties) {
            this.pendingOpenChannels = [];
            this.pendingClosingChannels = [];
            this.pendingForceClosingChannels = [];
            this.waitingCloseChannels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingChannelsResponse totalLimboBalance.
         * @member {number|Long} totalLimboBalance
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.totalLimboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PendingChannelsResponse pendingOpenChannels.
         * @member {Array.<lnrpc.PendingChannelsResponse.IPendingOpenChannel>} pendingOpenChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingOpenChannels = $util.emptyArray;

        /**
         * PendingChannelsResponse pendingClosingChannels.
         * @member {Array.<lnrpc.PendingChannelsResponse.IClosedChannel>} pendingClosingChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingClosingChannels = $util.emptyArray;

        /**
         * PendingChannelsResponse pendingForceClosingChannels.
         * @member {Array.<lnrpc.PendingChannelsResponse.IForceClosedChannel>} pendingForceClosingChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingForceClosingChannels = $util.emptyArray;

        /**
         * PendingChannelsResponse waitingCloseChannels.
         * @member {Array.<lnrpc.PendingChannelsResponse.IWaitingCloseChannel>} waitingCloseChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.waitingCloseChannels = $util.emptyArray;

        /**
         * Creates a new PendingChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse instance
         */
        PendingChannelsResponse.create = function create(properties) {
            return new PendingChannelsResponse(properties);
        };

        /**
         * Encodes the specified PendingChannelsResponse message. Does not implicitly {@link lnrpc.PendingChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse} message PendingChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalLimboBalance != null && Object.hasOwnProperty.call(message, "totalLimboBalance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalLimboBalance);
            if (message.pendingOpenChannels != null && message.pendingOpenChannels.length)
                for (let i = 0; i < message.pendingOpenChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.encode(message.pendingOpenChannels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.pendingClosingChannels != null && message.pendingClosingChannels.length)
                for (let i = 0; i < message.pendingClosingChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.ClosedChannel.encode(message.pendingClosingChannels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pendingForceClosingChannels != null && message.pendingForceClosingChannels.length)
                for (let i = 0; i < message.pendingForceClosingChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.encode(message.pendingForceClosingChannels[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.waitingCloseChannels != null && message.waitingCloseChannels.length)
                for (let i = 0; i < message.waitingCloseChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.encode(message.waitingCloseChannels[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PendingChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse} message PendingChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalLimboBalance = reader.int64();
                    break;
                case 2:
                    if (!(message.pendingOpenChannels && message.pendingOpenChannels.length))
                        message.pendingOpenChannels = [];
                    message.pendingOpenChannels.push($root.lnrpc.PendingChannelsResponse.PendingOpenChannel.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.pendingClosingChannels && message.pendingClosingChannels.length))
                        message.pendingClosingChannels = [];
                    message.pendingClosingChannels.push($root.lnrpc.PendingChannelsResponse.ClosedChannel.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.pendingForceClosingChannels && message.pendingForceClosingChannels.length))
                        message.pendingForceClosingChannels = [];
                    message.pendingForceClosingChannels.push($root.lnrpc.PendingChannelsResponse.ForceClosedChannel.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.waitingCloseChannels && message.waitingCloseChannels.length))
                        message.waitingCloseChannels = [];
                    message.waitingCloseChannels.push($root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingChannelsResponse message.
         * @function verify
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                if (!$util.isInteger(message.totalLimboBalance) && !(message.totalLimboBalance && $util.isInteger(message.totalLimboBalance.low) && $util.isInteger(message.totalLimboBalance.high)))
                    return "totalLimboBalance: integer|Long expected";
            if (message.pendingOpenChannels != null && message.hasOwnProperty("pendingOpenChannels")) {
                if (!Array.isArray(message.pendingOpenChannels))
                    return "pendingOpenChannels: array expected";
                for (let i = 0; i < message.pendingOpenChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.verify(message.pendingOpenChannels[i]);
                    if (error)
                        return "pendingOpenChannels." + error;
                }
            }
            if (message.pendingClosingChannels != null && message.hasOwnProperty("pendingClosingChannels")) {
                if (!Array.isArray(message.pendingClosingChannels))
                    return "pendingClosingChannels: array expected";
                for (let i = 0; i < message.pendingClosingChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.ClosedChannel.verify(message.pendingClosingChannels[i]);
                    if (error)
                        return "pendingClosingChannels." + error;
                }
            }
            if (message.pendingForceClosingChannels != null && message.hasOwnProperty("pendingForceClosingChannels")) {
                if (!Array.isArray(message.pendingForceClosingChannels))
                    return "pendingForceClosingChannels: array expected";
                for (let i = 0; i < message.pendingForceClosingChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.verify(message.pendingForceClosingChannels[i]);
                    if (error)
                        return "pendingForceClosingChannels." + error;
                }
            }
            if (message.waitingCloseChannels != null && message.hasOwnProperty("waitingCloseChannels")) {
                if (!Array.isArray(message.waitingCloseChannels))
                    return "waitingCloseChannels: array expected";
                for (let i = 0; i < message.waitingCloseChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify(message.waitingCloseChannels[i]);
                    if (error)
                        return "waitingCloseChannels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PendingChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         */
        PendingChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingChannelsResponse)
                return object;
            let message = new $root.lnrpc.PendingChannelsResponse();
            if (object.totalLimboBalance != null)
                if ($util.Long)
                    (message.totalLimboBalance = $util.Long.fromValue(object.totalLimboBalance)).unsigned = false;
                else if (typeof object.totalLimboBalance === "string")
                    message.totalLimboBalance = parseInt(object.totalLimboBalance, 10);
                else if (typeof object.totalLimboBalance === "number")
                    message.totalLimboBalance = object.totalLimboBalance;
                else if (typeof object.totalLimboBalance === "object")
                    message.totalLimboBalance = new $util.LongBits(object.totalLimboBalance.low >>> 0, object.totalLimboBalance.high >>> 0).toNumber();
            if (object.pendingOpenChannels) {
                if (!Array.isArray(object.pendingOpenChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingOpenChannels: array expected");
                message.pendingOpenChannels = [];
                for (let i = 0; i < object.pendingOpenChannels.length; ++i) {
                    if (typeof object.pendingOpenChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingOpenChannels: object expected");
                    message.pendingOpenChannels[i] = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.fromObject(object.pendingOpenChannels[i]);
                }
            }
            if (object.pendingClosingChannels) {
                if (!Array.isArray(object.pendingClosingChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingClosingChannels: array expected");
                message.pendingClosingChannels = [];
                for (let i = 0; i < object.pendingClosingChannels.length; ++i) {
                    if (typeof object.pendingClosingChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingClosingChannels: object expected");
                    message.pendingClosingChannels[i] = $root.lnrpc.PendingChannelsResponse.ClosedChannel.fromObject(object.pendingClosingChannels[i]);
                }
            }
            if (object.pendingForceClosingChannels) {
                if (!Array.isArray(object.pendingForceClosingChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingForceClosingChannels: array expected");
                message.pendingForceClosingChannels = [];
                for (let i = 0; i < object.pendingForceClosingChannels.length; ++i) {
                    if (typeof object.pendingForceClosingChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingForceClosingChannels: object expected");
                    message.pendingForceClosingChannels[i] = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.fromObject(object.pendingForceClosingChannels[i]);
                }
            }
            if (object.waitingCloseChannels) {
                if (!Array.isArray(object.waitingCloseChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.waitingCloseChannels: array expected");
                message.waitingCloseChannels = [];
                for (let i = 0; i < object.waitingCloseChannels.length; ++i) {
                    if (typeof object.waitingCloseChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.waitingCloseChannels: object expected");
                    message.waitingCloseChannels[i] = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.fromObject(object.waitingCloseChannels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PendingChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.PendingChannelsResponse} message PendingChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.pendingOpenChannels = [];
                object.pendingClosingChannels = [];
                object.pendingForceClosingChannels = [];
                object.waitingCloseChannels = [];
            }
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalLimboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalLimboBalance = options.longs === String ? "0" : 0;
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                if (typeof message.totalLimboBalance === "number")
                    object.totalLimboBalance = options.longs === String ? String(message.totalLimboBalance) : message.totalLimboBalance;
                else
                    object.totalLimboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.totalLimboBalance) : options.longs === Number ? new $util.LongBits(message.totalLimboBalance.low >>> 0, message.totalLimboBalance.high >>> 0).toNumber() : message.totalLimboBalance;
            if (message.pendingOpenChannels && message.pendingOpenChannels.length) {
                object.pendingOpenChannels = [];
                for (let j = 0; j < message.pendingOpenChannels.length; ++j)
                    object.pendingOpenChannels[j] = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.toObject(message.pendingOpenChannels[j], options);
            }
            if (message.pendingClosingChannels && message.pendingClosingChannels.length) {
                object.pendingClosingChannels = [];
                for (let j = 0; j < message.pendingClosingChannels.length; ++j)
                    object.pendingClosingChannels[j] = $root.lnrpc.PendingChannelsResponse.ClosedChannel.toObject(message.pendingClosingChannels[j], options);
            }
            if (message.pendingForceClosingChannels && message.pendingForceClosingChannels.length) {
                object.pendingForceClosingChannels = [];
                for (let j = 0; j < message.pendingForceClosingChannels.length; ++j)
                    object.pendingForceClosingChannels[j] = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.toObject(message.pendingForceClosingChannels[j], options);
            }
            if (message.waitingCloseChannels && message.waitingCloseChannels.length) {
                object.waitingCloseChannels = [];
                for (let j = 0; j < message.waitingCloseChannels.length; ++j)
                    object.waitingCloseChannels[j] = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.toObject(message.waitingCloseChannels[j], options);
            }
            return object;
        };

        /**
         * Converts this PendingChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PendingChannelsResponse.PendingChannel = (function() {

            /**
             * Properties of a PendingChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IPendingChannel
             * @property {string|null} [remoteNodePub] PendingChannel remoteNodePub
             * @property {string|null} [channelPoint] PendingChannel channelPoint
             * @property {number|Long|null} [capacity] PendingChannel capacity
             * @property {number|Long|null} [localBalance] PendingChannel localBalance
             * @property {number|Long|null} [remoteBalance] PendingChannel remoteBalance
             * @property {number|Long|null} [localChanReserveSat] PendingChannel localChanReserveSat
             * @property {number|Long|null} [remoteChanReserveSat] PendingChannel remoteChanReserveSat
             * @property {lnrpc.Initiator|null} [initiator] PendingChannel initiator
             * @property {lnrpc.CommitmentType|null} [commitmentType] PendingChannel commitmentType
             */

            /**
             * Constructs a new PendingChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a PendingChannel.
             * @implements IPendingChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel=} [properties] Properties to set
             */
            function PendingChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PendingChannel remoteNodePub.
             * @member {string} remoteNodePub
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteNodePub = "";

            /**
             * PendingChannel channelPoint.
             * @member {string} channelPoint
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.channelPoint = "";

            /**
             * PendingChannel capacity.
             * @member {number|Long} capacity
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel localBalance.
             * @member {number|Long} localBalance
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.localBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel remoteBalance.
             * @member {number|Long} remoteBalance
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel localChanReserveSat.
             * @member {number|Long} localChanReserveSat
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.localChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel remoteChanReserveSat.
             * @member {number|Long} remoteChanReserveSat
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel initiator.
             * @member {lnrpc.Initiator} initiator
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.initiator = 0;

            /**
             * PendingChannel commitmentType.
             * @member {lnrpc.CommitmentType} commitmentType
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.commitmentType = 0;

            /**
             * Creates a new PendingChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel instance
             */
            PendingChannel.create = function create(properties) {
                return new PendingChannel(properties);
            };

            /**
             * Encodes the specified PendingChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel} message PendingChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.remoteNodePub != null && Object.hasOwnProperty.call(message, "remoteNodePub"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.remoteNodePub);
                if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelPoint);
                if (message.capacity != null && Object.hasOwnProperty.call(message, "capacity"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.capacity);
                if (message.localBalance != null && Object.hasOwnProperty.call(message, "localBalance"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.localBalance);
                if (message.remoteBalance != null && Object.hasOwnProperty.call(message, "remoteBalance"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.remoteBalance);
                if (message.localChanReserveSat != null && Object.hasOwnProperty.call(message, "localChanReserveSat"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.localChanReserveSat);
                if (message.remoteChanReserveSat != null && Object.hasOwnProperty.call(message, "remoteChanReserveSat"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.remoteChanReserveSat);
                if (message.initiator != null && Object.hasOwnProperty.call(message, "initiator"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.initiator);
                if (message.commitmentType != null && Object.hasOwnProperty.call(message, "commitmentType"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.commitmentType);
                return writer;
            };

            /**
             * Encodes the specified PendingChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel} message PendingChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.PendingChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.remoteNodePub = reader.string();
                        break;
                    case 2:
                        message.channelPoint = reader.string();
                        break;
                    case 3:
                        message.capacity = reader.int64();
                        break;
                    case 4:
                        message.localBalance = reader.int64();
                        break;
                    case 5:
                        message.remoteBalance = reader.int64();
                        break;
                    case 6:
                        message.localChanReserveSat = reader.int64();
                        break;
                    case 7:
                        message.remoteChanReserveSat = reader.int64();
                        break;
                    case 8:
                        message.initiator = reader.int32();
                        break;
                    case 9:
                        message.commitmentType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    if (!$util.isString(message.remoteNodePub))
                        return "remoteNodePub: string expected";
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    if (!$util.isString(message.channelPoint))
                        return "channelPoint: string expected";
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                        return "capacity: integer|Long expected";
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    if (!$util.isInteger(message.localBalance) && !(message.localBalance && $util.isInteger(message.localBalance.low) && $util.isInteger(message.localBalance.high)))
                        return "localBalance: integer|Long expected";
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    if (!$util.isInteger(message.remoteBalance) && !(message.remoteBalance && $util.isInteger(message.remoteBalance.low) && $util.isInteger(message.remoteBalance.high)))
                        return "remoteBalance: integer|Long expected";
                if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                    if (!$util.isInteger(message.localChanReserveSat) && !(message.localChanReserveSat && $util.isInteger(message.localChanReserveSat.low) && $util.isInteger(message.localChanReserveSat.high)))
                        return "localChanReserveSat: integer|Long expected";
                if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                    if (!$util.isInteger(message.remoteChanReserveSat) && !(message.remoteChanReserveSat && $util.isInteger(message.remoteChanReserveSat.low) && $util.isInteger(message.remoteChanReserveSat.high)))
                        return "remoteChanReserveSat: integer|Long expected";
                if (message.initiator != null && message.hasOwnProperty("initiator"))
                    switch (message.initiator) {
                    default:
                        return "initiator: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.commitmentType != null && message.hasOwnProperty("commitmentType"))
                    switch (message.commitmentType) {
                    default:
                        return "commitmentType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 999:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PendingChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             */
            PendingChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.PendingChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.PendingChannel();
                if (object.remoteNodePub != null)
                    message.remoteNodePub = String(object.remoteNodePub);
                if (object.channelPoint != null)
                    message.channelPoint = String(object.channelPoint);
                if (object.capacity != null)
                    if ($util.Long)
                        (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                    else if (typeof object.capacity === "string")
                        message.capacity = parseInt(object.capacity, 10);
                    else if (typeof object.capacity === "number")
                        message.capacity = object.capacity;
                    else if (typeof object.capacity === "object")
                        message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
                if (object.localBalance != null)
                    if ($util.Long)
                        (message.localBalance = $util.Long.fromValue(object.localBalance)).unsigned = false;
                    else if (typeof object.localBalance === "string")
                        message.localBalance = parseInt(object.localBalance, 10);
                    else if (typeof object.localBalance === "number")
                        message.localBalance = object.localBalance;
                    else if (typeof object.localBalance === "object")
                        message.localBalance = new $util.LongBits(object.localBalance.low >>> 0, object.localBalance.high >>> 0).toNumber();
                if (object.remoteBalance != null)
                    if ($util.Long)
                        (message.remoteBalance = $util.Long.fromValue(object.remoteBalance)).unsigned = false;
                    else if (typeof object.remoteBalance === "string")
                        message.remoteBalance = parseInt(object.remoteBalance, 10);
                    else if (typeof object.remoteBalance === "number")
                        message.remoteBalance = object.remoteBalance;
                    else if (typeof object.remoteBalance === "object")
                        message.remoteBalance = new $util.LongBits(object.remoteBalance.low >>> 0, object.remoteBalance.high >>> 0).toNumber();
                if (object.localChanReserveSat != null)
                    if ($util.Long)
                        (message.localChanReserveSat = $util.Long.fromValue(object.localChanReserveSat)).unsigned = false;
                    else if (typeof object.localChanReserveSat === "string")
                        message.localChanReserveSat = parseInt(object.localChanReserveSat, 10);
                    else if (typeof object.localChanReserveSat === "number")
                        message.localChanReserveSat = object.localChanReserveSat;
                    else if (typeof object.localChanReserveSat === "object")
                        message.localChanReserveSat = new $util.LongBits(object.localChanReserveSat.low >>> 0, object.localChanReserveSat.high >>> 0).toNumber();
                if (object.remoteChanReserveSat != null)
                    if ($util.Long)
                        (message.remoteChanReserveSat = $util.Long.fromValue(object.remoteChanReserveSat)).unsigned = false;
                    else if (typeof object.remoteChanReserveSat === "string")
                        message.remoteChanReserveSat = parseInt(object.remoteChanReserveSat, 10);
                    else if (typeof object.remoteChanReserveSat === "number")
                        message.remoteChanReserveSat = object.remoteChanReserveSat;
                    else if (typeof object.remoteChanReserveSat === "object")
                        message.remoteChanReserveSat = new $util.LongBits(object.remoteChanReserveSat.low >>> 0, object.remoteChanReserveSat.high >>> 0).toNumber();
                switch (object.initiator) {
                case "INITIATOR_UNKNOWN":
                case 0:
                    message.initiator = 0;
                    break;
                case "INITIATOR_LOCAL":
                case 1:
                    message.initiator = 1;
                    break;
                case "INITIATOR_REMOTE":
                case 2:
                    message.initiator = 2;
                    break;
                case "INITIATOR_BOTH":
                case 3:
                    message.initiator = 3;
                    break;
                }
                switch (object.commitmentType) {
                case "LEGACY":
                case 0:
                    message.commitmentType = 0;
                    break;
                case "STATIC_REMOTE_KEY":
                case 1:
                    message.commitmentType = 1;
                    break;
                case "ANCHORS":
                case 2:
                    message.commitmentType = 2;
                    break;
                case "UNKNOWN_COMMITMENT_TYPE":
                case 999:
                    message.commitmentType = 999;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PendingChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.PendingChannel} message PendingChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.remoteNodePub = "";
                    object.channelPoint = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.capacity = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.localBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.localBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.remoteBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remoteBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.localChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.localChanReserveSat = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.remoteChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remoteChanReserveSat = options.longs === String ? "0" : 0;
                    object.initiator = options.enums === String ? "INITIATOR_UNKNOWN" : 0;
                    object.commitmentType = options.enums === String ? "LEGACY" : 0;
                }
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    object.remoteNodePub = message.remoteNodePub;
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    object.channelPoint = message.channelPoint;
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (typeof message.capacity === "number")
                        object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                    else
                        object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    if (typeof message.localBalance === "number")
                        object.localBalance = options.longs === String ? String(message.localBalance) : message.localBalance;
                    else
                        object.localBalance = options.longs === String ? $util.Long.prototype.toString.call(message.localBalance) : options.longs === Number ? new $util.LongBits(message.localBalance.low >>> 0, message.localBalance.high >>> 0).toNumber() : message.localBalance;
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    if (typeof message.remoteBalance === "number")
                        object.remoteBalance = options.longs === String ? String(message.remoteBalance) : message.remoteBalance;
                    else
                        object.remoteBalance = options.longs === String ? $util.Long.prototype.toString.call(message.remoteBalance) : options.longs === Number ? new $util.LongBits(message.remoteBalance.low >>> 0, message.remoteBalance.high >>> 0).toNumber() : message.remoteBalance;
                if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                    if (typeof message.localChanReserveSat === "number")
                        object.localChanReserveSat = options.longs === String ? String(message.localChanReserveSat) : message.localChanReserveSat;
                    else
                        object.localChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.localChanReserveSat) : options.longs === Number ? new $util.LongBits(message.localChanReserveSat.low >>> 0, message.localChanReserveSat.high >>> 0).toNumber() : message.localChanReserveSat;
                if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                    if (typeof message.remoteChanReserveSat === "number")
                        object.remoteChanReserveSat = options.longs === String ? String(message.remoteChanReserveSat) : message.remoteChanReserveSat;
                    else
                        object.remoteChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.remoteChanReserveSat) : options.longs === Number ? new $util.LongBits(message.remoteChanReserveSat.low >>> 0, message.remoteChanReserveSat.high >>> 0).toNumber() : message.remoteChanReserveSat;
                if (message.initiator != null && message.hasOwnProperty("initiator"))
                    object.initiator = options.enums === String ? $root.lnrpc.Initiator[message.initiator] : message.initiator;
                if (message.commitmentType != null && message.hasOwnProperty("commitmentType"))
                    object.commitmentType = options.enums === String ? $root.lnrpc.CommitmentType[message.commitmentType] : message.commitmentType;
                return object;
            };

            /**
             * Converts this PendingChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingChannel;
        })();

        PendingChannelsResponse.PendingOpenChannel = (function() {

            /**
             * Properties of a PendingOpenChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IPendingOpenChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] PendingOpenChannel channel
             * @property {number|null} [confirmationHeight] PendingOpenChannel confirmationHeight
             * @property {number|Long|null} [commitFee] PendingOpenChannel commitFee
             * @property {number|Long|null} [commitWeight] PendingOpenChannel commitWeight
             * @property {number|Long|null} [feePerKw] PendingOpenChannel feePerKw
             */

            /**
             * Constructs a new PendingOpenChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a PendingOpenChannel.
             * @implements IPendingOpenChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel=} [properties] Properties to set
             */
            function PendingOpenChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PendingOpenChannel channel.
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.channel = null;

            /**
             * PendingOpenChannel confirmationHeight.
             * @member {number} confirmationHeight
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.confirmationHeight = 0;

            /**
             * PendingOpenChannel commitFee.
             * @member {number|Long} commitFee
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.commitFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingOpenChannel commitWeight.
             * @member {number|Long} commitWeight
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.commitWeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingOpenChannel feePerKw.
             * @member {number|Long} feePerKw
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PendingOpenChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel instance
             */
            PendingOpenChannel.create = function create(properties) {
                return new PendingOpenChannel(properties);
            };

            /**
             * Encodes the specified PendingOpenChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingOpenChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel} message PendingOpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingOpenChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.confirmationHeight != null && Object.hasOwnProperty.call(message, "confirmationHeight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.confirmationHeight);
                if (message.commitFee != null && Object.hasOwnProperty.call(message, "commitFee"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.commitFee);
                if (message.commitWeight != null && Object.hasOwnProperty.call(message, "commitWeight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.commitWeight);
                if (message.feePerKw != null && Object.hasOwnProperty.call(message, "feePerKw"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.feePerKw);
                return writer;
            };

            /**
             * Encodes the specified PendingOpenChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingOpenChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel} message PendingOpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingOpenChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingOpenChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingOpenChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.PendingOpenChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.confirmationHeight = reader.uint32();
                        break;
                    case 4:
                        message.commitFee = reader.int64();
                        break;
                    case 5:
                        message.commitWeight = reader.int64();
                        break;
                    case 6:
                        message.feePerKw = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingOpenChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingOpenChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingOpenChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingOpenChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    if (!$util.isInteger(message.confirmationHeight))
                        return "confirmationHeight: integer expected";
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    if (!$util.isInteger(message.commitFee) && !(message.commitFee && $util.isInteger(message.commitFee.low) && $util.isInteger(message.commitFee.high)))
                        return "commitFee: integer|Long expected";
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    if (!$util.isInteger(message.commitWeight) && !(message.commitWeight && $util.isInteger(message.commitWeight.low) && $util.isInteger(message.commitWeight.high)))
                        return "commitWeight: integer|Long expected";
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                        return "feePerKw: integer|Long expected";
                return null;
            };

            /**
             * Creates a PendingOpenChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             */
            PendingOpenChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.PendingOpenChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.PendingOpenChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.PendingOpenChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.confirmationHeight != null)
                    message.confirmationHeight = object.confirmationHeight >>> 0;
                if (object.commitFee != null)
                    if ($util.Long)
                        (message.commitFee = $util.Long.fromValue(object.commitFee)).unsigned = false;
                    else if (typeof object.commitFee === "string")
                        message.commitFee = parseInt(object.commitFee, 10);
                    else if (typeof object.commitFee === "number")
                        message.commitFee = object.commitFee;
                    else if (typeof object.commitFee === "object")
                        message.commitFee = new $util.LongBits(object.commitFee.low >>> 0, object.commitFee.high >>> 0).toNumber();
                if (object.commitWeight != null)
                    if ($util.Long)
                        (message.commitWeight = $util.Long.fromValue(object.commitWeight)).unsigned = false;
                    else if (typeof object.commitWeight === "string")
                        message.commitWeight = parseInt(object.commitWeight, 10);
                    else if (typeof object.commitWeight === "number")
                        message.commitWeight = object.commitWeight;
                    else if (typeof object.commitWeight === "object")
                        message.commitWeight = new $util.LongBits(object.commitWeight.low >>> 0, object.commitWeight.high >>> 0).toNumber();
                if (object.feePerKw != null)
                    if ($util.Long)
                        (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = false;
                    else if (typeof object.feePerKw === "string")
                        message.feePerKw = parseInt(object.feePerKw, 10);
                    else if (typeof object.feePerKw === "number")
                        message.feePerKw = object.feePerKw;
                    else if (typeof object.feePerKw === "object")
                        message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PendingOpenChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.PendingOpenChannel} message PendingOpenChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingOpenChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = null;
                    object.confirmationHeight = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.commitFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.commitFee = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.commitWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.commitWeight = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.feePerKw = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    object.confirmationHeight = message.confirmationHeight;
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    if (typeof message.commitFee === "number")
                        object.commitFee = options.longs === String ? String(message.commitFee) : message.commitFee;
                    else
                        object.commitFee = options.longs === String ? $util.Long.prototype.toString.call(message.commitFee) : options.longs === Number ? new $util.LongBits(message.commitFee.low >>> 0, message.commitFee.high >>> 0).toNumber() : message.commitFee;
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    if (typeof message.commitWeight === "number")
                        object.commitWeight = options.longs === String ? String(message.commitWeight) : message.commitWeight;
                    else
                        object.commitWeight = options.longs === String ? $util.Long.prototype.toString.call(message.commitWeight) : options.longs === Number ? new $util.LongBits(message.commitWeight.low >>> 0, message.commitWeight.high >>> 0).toNumber() : message.commitWeight;
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    if (typeof message.feePerKw === "number")
                        object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                    else
                        object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber() : message.feePerKw;
                return object;
            };

            /**
             * Converts this PendingOpenChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingOpenChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingOpenChannel;
        })();

        PendingChannelsResponse.WaitingCloseChannel = (function() {

            /**
             * Properties of a WaitingCloseChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IWaitingCloseChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] WaitingCloseChannel channel
             * @property {number|Long|null} [limboBalance] WaitingCloseChannel limboBalance
             * @property {lnrpc.PendingChannelsResponse.ICommitments|null} [commitments] WaitingCloseChannel commitments
             */

            /**
             * Constructs a new WaitingCloseChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a WaitingCloseChannel.
             * @implements IWaitingCloseChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel=} [properties] Properties to set
             */
            function WaitingCloseChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WaitingCloseChannel channel.
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.channel = null;

            /**
             * WaitingCloseChannel limboBalance.
             * @member {number|Long} limboBalance
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.limboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * WaitingCloseChannel commitments.
             * @member {lnrpc.PendingChannelsResponse.ICommitments|null|undefined} commitments
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.commitments = null;

            /**
             * Creates a new WaitingCloseChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel instance
             */
            WaitingCloseChannel.create = function create(properties) {
                return new WaitingCloseChannel(properties);
            };

            /**
             * Encodes the specified WaitingCloseChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel} message WaitingCloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitingCloseChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limboBalance != null && Object.hasOwnProperty.call(message, "limboBalance"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.limboBalance);
                if (message.commitments != null && Object.hasOwnProperty.call(message, "commitments"))
                    $root.lnrpc.PendingChannelsResponse.Commitments.encode(message.commitments, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WaitingCloseChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel} message WaitingCloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitingCloseChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WaitingCloseChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitingCloseChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limboBalance = reader.int64();
                        break;
                    case 3:
                        message.commitments = $root.lnrpc.PendingChannelsResponse.Commitments.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WaitingCloseChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitingCloseChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WaitingCloseChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WaitingCloseChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (!$util.isInteger(message.limboBalance) && !(message.limboBalance && $util.isInteger(message.limboBalance.low) && $util.isInteger(message.limboBalance.high)))
                        return "limboBalance: integer|Long expected";
                if (message.commitments != null && message.hasOwnProperty("commitments")) {
                    let error = $root.lnrpc.PendingChannelsResponse.Commitments.verify(message.commitments);
                    if (error)
                        return "commitments." + error;
                }
                return null;
            };

            /**
             * Creates a WaitingCloseChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             */
            WaitingCloseChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.WaitingCloseChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.limboBalance != null)
                    if ($util.Long)
                        (message.limboBalance = $util.Long.fromValue(object.limboBalance)).unsigned = false;
                    else if (typeof object.limboBalance === "string")
                        message.limboBalance = parseInt(object.limboBalance, 10);
                    else if (typeof object.limboBalance === "number")
                        message.limboBalance = object.limboBalance;
                    else if (typeof object.limboBalance === "object")
                        message.limboBalance = new $util.LongBits(object.limboBalance.low >>> 0, object.limboBalance.high >>> 0).toNumber();
                if (object.commitments != null) {
                    if (typeof object.commitments !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.WaitingCloseChannel.commitments: object expected");
                    message.commitments = $root.lnrpc.PendingChannelsResponse.Commitments.fromObject(object.commitments);
                }
                return message;
            };

            /**
             * Creates a plain object from a WaitingCloseChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.WaitingCloseChannel} message WaitingCloseChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WaitingCloseChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.limboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limboBalance = options.longs === String ? "0" : 0;
                    object.commitments = null;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (typeof message.limboBalance === "number")
                        object.limboBalance = options.longs === String ? String(message.limboBalance) : message.limboBalance;
                    else
                        object.limboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.limboBalance) : options.longs === Number ? new $util.LongBits(message.limboBalance.low >>> 0, message.limboBalance.high >>> 0).toNumber() : message.limboBalance;
                if (message.commitments != null && message.hasOwnProperty("commitments"))
                    object.commitments = $root.lnrpc.PendingChannelsResponse.Commitments.toObject(message.commitments, options);
                return object;
            };

            /**
             * Converts this WaitingCloseChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WaitingCloseChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WaitingCloseChannel;
        })();

        PendingChannelsResponse.Commitments = (function() {

            /**
             * Properties of a Commitments.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface ICommitments
             * @property {string|null} [localTxid] Commitments localTxid
             * @property {string|null} [remoteTxid] Commitments remoteTxid
             * @property {string|null} [remotePendingTxid] Commitments remotePendingTxid
             * @property {number|Long|null} [localCommitFeeSat] Commitments localCommitFeeSat
             * @property {number|Long|null} [remoteCommitFeeSat] Commitments remoteCommitFeeSat
             * @property {number|Long|null} [remotePendingCommitFeeSat] Commitments remotePendingCommitFeeSat
             */

            /**
             * Constructs a new Commitments.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a Commitments.
             * @implements ICommitments
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.ICommitments=} [properties] Properties to set
             */
            function Commitments(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Commitments localTxid.
             * @member {string} localTxid
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             */
            Commitments.prototype.localTxid = "";

            /**
             * Commitments remoteTxid.
             * @member {string} remoteTxid
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             */
            Commitments.prototype.remoteTxid = "";

            /**
             * Commitments remotePendingTxid.
             * @member {string} remotePendingTxid
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             */
            Commitments.prototype.remotePendingTxid = "";

            /**
             * Commitments localCommitFeeSat.
             * @member {number|Long} localCommitFeeSat
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             */
            Commitments.prototype.localCommitFeeSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Commitments remoteCommitFeeSat.
             * @member {number|Long} remoteCommitFeeSat
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             */
            Commitments.prototype.remoteCommitFeeSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Commitments remotePendingCommitFeeSat.
             * @member {number|Long} remotePendingCommitFeeSat
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             */
            Commitments.prototype.remotePendingCommitFeeSat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Commitments instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {lnrpc.PendingChannelsResponse.ICommitments=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.Commitments} Commitments instance
             */
            Commitments.create = function create(properties) {
                return new Commitments(properties);
            };

            /**
             * Encodes the specified Commitments message. Does not implicitly {@link lnrpc.PendingChannelsResponse.Commitments.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {lnrpc.PendingChannelsResponse.ICommitments} message Commitments message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Commitments.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.localTxid != null && Object.hasOwnProperty.call(message, "localTxid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.localTxid);
                if (message.remoteTxid != null && Object.hasOwnProperty.call(message, "remoteTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteTxid);
                if (message.remotePendingTxid != null && Object.hasOwnProperty.call(message, "remotePendingTxid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.remotePendingTxid);
                if (message.localCommitFeeSat != null && Object.hasOwnProperty.call(message, "localCommitFeeSat"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.localCommitFeeSat);
                if (message.remoteCommitFeeSat != null && Object.hasOwnProperty.call(message, "remoteCommitFeeSat"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.remoteCommitFeeSat);
                if (message.remotePendingCommitFeeSat != null && Object.hasOwnProperty.call(message, "remotePendingCommitFeeSat"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.remotePendingCommitFeeSat);
                return writer;
            };

            /**
             * Encodes the specified Commitments message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.Commitments.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {lnrpc.PendingChannelsResponse.ICommitments} message Commitments message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Commitments.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Commitments message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.Commitments} Commitments
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Commitments.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.Commitments();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.localTxid = reader.string();
                        break;
                    case 2:
                        message.remoteTxid = reader.string();
                        break;
                    case 3:
                        message.remotePendingTxid = reader.string();
                        break;
                    case 4:
                        message.localCommitFeeSat = reader.uint64();
                        break;
                    case 5:
                        message.remoteCommitFeeSat = reader.uint64();
                        break;
                    case 6:
                        message.remotePendingCommitFeeSat = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Commitments message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.Commitments} Commitments
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Commitments.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Commitments message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Commitments.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.localTxid != null && message.hasOwnProperty("localTxid"))
                    if (!$util.isString(message.localTxid))
                        return "localTxid: string expected";
                if (message.remoteTxid != null && message.hasOwnProperty("remoteTxid"))
                    if (!$util.isString(message.remoteTxid))
                        return "remoteTxid: string expected";
                if (message.remotePendingTxid != null && message.hasOwnProperty("remotePendingTxid"))
                    if (!$util.isString(message.remotePendingTxid))
                        return "remotePendingTxid: string expected";
                if (message.localCommitFeeSat != null && message.hasOwnProperty("localCommitFeeSat"))
                    if (!$util.isInteger(message.localCommitFeeSat) && !(message.localCommitFeeSat && $util.isInteger(message.localCommitFeeSat.low) && $util.isInteger(message.localCommitFeeSat.high)))
                        return "localCommitFeeSat: integer|Long expected";
                if (message.remoteCommitFeeSat != null && message.hasOwnProperty("remoteCommitFeeSat"))
                    if (!$util.isInteger(message.remoteCommitFeeSat) && !(message.remoteCommitFeeSat && $util.isInteger(message.remoteCommitFeeSat.low) && $util.isInteger(message.remoteCommitFeeSat.high)))
                        return "remoteCommitFeeSat: integer|Long expected";
                if (message.remotePendingCommitFeeSat != null && message.hasOwnProperty("remotePendingCommitFeeSat"))
                    if (!$util.isInteger(message.remotePendingCommitFeeSat) && !(message.remotePendingCommitFeeSat && $util.isInteger(message.remotePendingCommitFeeSat.low) && $util.isInteger(message.remotePendingCommitFeeSat.high)))
                        return "remotePendingCommitFeeSat: integer|Long expected";
                return null;
            };

            /**
             * Creates a Commitments message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.Commitments} Commitments
             */
            Commitments.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.Commitments)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.Commitments();
                if (object.localTxid != null)
                    message.localTxid = String(object.localTxid);
                if (object.remoteTxid != null)
                    message.remoteTxid = String(object.remoteTxid);
                if (object.remotePendingTxid != null)
                    message.remotePendingTxid = String(object.remotePendingTxid);
                if (object.localCommitFeeSat != null)
                    if ($util.Long)
                        (message.localCommitFeeSat = $util.Long.fromValue(object.localCommitFeeSat)).unsigned = true;
                    else if (typeof object.localCommitFeeSat === "string")
                        message.localCommitFeeSat = parseInt(object.localCommitFeeSat, 10);
                    else if (typeof object.localCommitFeeSat === "number")
                        message.localCommitFeeSat = object.localCommitFeeSat;
                    else if (typeof object.localCommitFeeSat === "object")
                        message.localCommitFeeSat = new $util.LongBits(object.localCommitFeeSat.low >>> 0, object.localCommitFeeSat.high >>> 0).toNumber(true);
                if (object.remoteCommitFeeSat != null)
                    if ($util.Long)
                        (message.remoteCommitFeeSat = $util.Long.fromValue(object.remoteCommitFeeSat)).unsigned = true;
                    else if (typeof object.remoteCommitFeeSat === "string")
                        message.remoteCommitFeeSat = parseInt(object.remoteCommitFeeSat, 10);
                    else if (typeof object.remoteCommitFeeSat === "number")
                        message.remoteCommitFeeSat = object.remoteCommitFeeSat;
                    else if (typeof object.remoteCommitFeeSat === "object")
                        message.remoteCommitFeeSat = new $util.LongBits(object.remoteCommitFeeSat.low >>> 0, object.remoteCommitFeeSat.high >>> 0).toNumber(true);
                if (object.remotePendingCommitFeeSat != null)
                    if ($util.Long)
                        (message.remotePendingCommitFeeSat = $util.Long.fromValue(object.remotePendingCommitFeeSat)).unsigned = true;
                    else if (typeof object.remotePendingCommitFeeSat === "string")
                        message.remotePendingCommitFeeSat = parseInt(object.remotePendingCommitFeeSat, 10);
                    else if (typeof object.remotePendingCommitFeeSat === "number")
                        message.remotePendingCommitFeeSat = object.remotePendingCommitFeeSat;
                    else if (typeof object.remotePendingCommitFeeSat === "object")
                        message.remotePendingCommitFeeSat = new $util.LongBits(object.remotePendingCommitFeeSat.low >>> 0, object.remotePendingCommitFeeSat.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Commitments message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @static
             * @param {lnrpc.PendingChannelsResponse.Commitments} message Commitments
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Commitments.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.localTxid = "";
                    object.remoteTxid = "";
                    object.remotePendingTxid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.localCommitFeeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.localCommitFeeSat = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.remoteCommitFeeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remoteCommitFeeSat = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.remotePendingCommitFeeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remotePendingCommitFeeSat = options.longs === String ? "0" : 0;
                }
                if (message.localTxid != null && message.hasOwnProperty("localTxid"))
                    object.localTxid = message.localTxid;
                if (message.remoteTxid != null && message.hasOwnProperty("remoteTxid"))
                    object.remoteTxid = message.remoteTxid;
                if (message.remotePendingTxid != null && message.hasOwnProperty("remotePendingTxid"))
                    object.remotePendingTxid = message.remotePendingTxid;
                if (message.localCommitFeeSat != null && message.hasOwnProperty("localCommitFeeSat"))
                    if (typeof message.localCommitFeeSat === "number")
                        object.localCommitFeeSat = options.longs === String ? String(message.localCommitFeeSat) : message.localCommitFeeSat;
                    else
                        object.localCommitFeeSat = options.longs === String ? $util.Long.prototype.toString.call(message.localCommitFeeSat) : options.longs === Number ? new $util.LongBits(message.localCommitFeeSat.low >>> 0, message.localCommitFeeSat.high >>> 0).toNumber(true) : message.localCommitFeeSat;
                if (message.remoteCommitFeeSat != null && message.hasOwnProperty("remoteCommitFeeSat"))
                    if (typeof message.remoteCommitFeeSat === "number")
                        object.remoteCommitFeeSat = options.longs === String ? String(message.remoteCommitFeeSat) : message.remoteCommitFeeSat;
                    else
                        object.remoteCommitFeeSat = options.longs === String ? $util.Long.prototype.toString.call(message.remoteCommitFeeSat) : options.longs === Number ? new $util.LongBits(message.remoteCommitFeeSat.low >>> 0, message.remoteCommitFeeSat.high >>> 0).toNumber(true) : message.remoteCommitFeeSat;
                if (message.remotePendingCommitFeeSat != null && message.hasOwnProperty("remotePendingCommitFeeSat"))
                    if (typeof message.remotePendingCommitFeeSat === "number")
                        object.remotePendingCommitFeeSat = options.longs === String ? String(message.remotePendingCommitFeeSat) : message.remotePendingCommitFeeSat;
                    else
                        object.remotePendingCommitFeeSat = options.longs === String ? $util.Long.prototype.toString.call(message.remotePendingCommitFeeSat) : options.longs === Number ? new $util.LongBits(message.remotePendingCommitFeeSat.low >>> 0, message.remotePendingCommitFeeSat.high >>> 0).toNumber(true) : message.remotePendingCommitFeeSat;
                return object;
            };

            /**
             * Converts this Commitments to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.Commitments
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Commitments.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Commitments;
        })();

        PendingChannelsResponse.ClosedChannel = (function() {

            /**
             * Properties of a ClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IClosedChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] ClosedChannel channel
             * @property {string|null} [closingTxid] ClosedChannel closingTxid
             */

            /**
             * Constructs a new ClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a ClosedChannel.
             * @implements IClosedChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel=} [properties] Properties to set
             */
            function ClosedChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClosedChannel channel.
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             */
            ClosedChannel.prototype.channel = null;

            /**
             * ClosedChannel closingTxid.
             * @member {string} closingTxid
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             */
            ClosedChannel.prototype.closingTxid = "";

            /**
             * Creates a new ClosedChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel instance
             */
            ClosedChannel.create = function create(properties) {
                return new ClosedChannel(properties);
            };

            /**
             * Encodes the specified ClosedChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.ClosedChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel} message ClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClosedChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closingTxid != null && Object.hasOwnProperty.call(message, "closingTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.closingTxid);
                return writer;
            };

            /**
             * Encodes the specified ClosedChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.ClosedChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel} message ClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClosedChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClosedChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClosedChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.ClosedChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closingTxid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClosedChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClosedChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClosedChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClosedChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    if (!$util.isString(message.closingTxid))
                        return "closingTxid: string expected";
                return null;
            };

            /**
             * Creates a ClosedChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             */
            ClosedChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.ClosedChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.ClosedChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.ClosedChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.closingTxid != null)
                    message.closingTxid = String(object.closingTxid);
                return message;
            };

            /**
             * Creates a plain object from a ClosedChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.ClosedChannel} message ClosedChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClosedChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = null;
                    object.closingTxid = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    object.closingTxid = message.closingTxid;
                return object;
            };

            /**
             * Converts this ClosedChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClosedChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClosedChannel;
        })();

        PendingChannelsResponse.ForceClosedChannel = (function() {

            /**
             * Properties of a ForceClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IForceClosedChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] ForceClosedChannel channel
             * @property {string|null} [closingTxid] ForceClosedChannel closingTxid
             * @property {number|Long|null} [limboBalance] ForceClosedChannel limboBalance
             * @property {number|null} [maturityHeight] ForceClosedChannel maturityHeight
             * @property {number|null} [blocksTilMaturity] ForceClosedChannel blocksTilMaturity
             * @property {number|Long|null} [recoveredBalance] ForceClosedChannel recoveredBalance
             * @property {Array.<lnrpc.IPendingHTLC>|null} [pendingHtlcs] ForceClosedChannel pendingHtlcs
             * @property {lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState|null} [anchor] ForceClosedChannel anchor
             */

            /**
             * Constructs a new ForceClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a ForceClosedChannel.
             * @implements IForceClosedChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel=} [properties] Properties to set
             */
            function ForceClosedChannel(properties) {
                this.pendingHtlcs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForceClosedChannel channel.
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.channel = null;

            /**
             * ForceClosedChannel closingTxid.
             * @member {string} closingTxid
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.closingTxid = "";

            /**
             * ForceClosedChannel limboBalance.
             * @member {number|Long} limboBalance
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.limboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ForceClosedChannel maturityHeight.
             * @member {number} maturityHeight
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.maturityHeight = 0;

            /**
             * ForceClosedChannel blocksTilMaturity.
             * @member {number} blocksTilMaturity
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.blocksTilMaturity = 0;

            /**
             * ForceClosedChannel recoveredBalance.
             * @member {number|Long} recoveredBalance
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.recoveredBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ForceClosedChannel pendingHtlcs.
             * @member {Array.<lnrpc.IPendingHTLC>} pendingHtlcs
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.pendingHtlcs = $util.emptyArray;

            /**
             * ForceClosedChannel anchor.
             * @member {lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState} anchor
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.anchor = 0;

            /**
             * Creates a new ForceClosedChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel instance
             */
            ForceClosedChannel.create = function create(properties) {
                return new ForceClosedChannel(properties);
            };

            /**
             * Encodes the specified ForceClosedChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.ForceClosedChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel} message ForceClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceClosedChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closingTxid != null && Object.hasOwnProperty.call(message, "closingTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.closingTxid);
                if (message.limboBalance != null && Object.hasOwnProperty.call(message, "limboBalance"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.limboBalance);
                if (message.maturityHeight != null && Object.hasOwnProperty.call(message, "maturityHeight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maturityHeight);
                if (message.blocksTilMaturity != null && Object.hasOwnProperty.call(message, "blocksTilMaturity"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blocksTilMaturity);
                if (message.recoveredBalance != null && Object.hasOwnProperty.call(message, "recoveredBalance"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.recoveredBalance);
                if (message.pendingHtlcs != null && message.pendingHtlcs.length)
                    for (let i = 0; i < message.pendingHtlcs.length; ++i)
                        $root.lnrpc.PendingHTLC.encode(message.pendingHtlcs[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.anchor != null && Object.hasOwnProperty.call(message, "anchor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.anchor);
                return writer;
            };

            /**
             * Encodes the specified ForceClosedChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.ForceClosedChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel} message ForceClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceClosedChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForceClosedChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceClosedChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.ForceClosedChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closingTxid = reader.string();
                        break;
                    case 3:
                        message.limboBalance = reader.int64();
                        break;
                    case 4:
                        message.maturityHeight = reader.uint32();
                        break;
                    case 5:
                        message.blocksTilMaturity = reader.int32();
                        break;
                    case 6:
                        message.recoveredBalance = reader.int64();
                        break;
                    case 8:
                        if (!(message.pendingHtlcs && message.pendingHtlcs.length))
                            message.pendingHtlcs = [];
                        message.pendingHtlcs.push($root.lnrpc.PendingHTLC.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.anchor = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForceClosedChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceClosedChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForceClosedChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForceClosedChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    if (!$util.isString(message.closingTxid))
                        return "closingTxid: string expected";
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (!$util.isInteger(message.limboBalance) && !(message.limboBalance && $util.isInteger(message.limboBalance.low) && $util.isInteger(message.limboBalance.high)))
                        return "limboBalance: integer|Long expected";
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    if (!$util.isInteger(message.maturityHeight))
                        return "maturityHeight: integer expected";
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    if (!$util.isInteger(message.blocksTilMaturity))
                        return "blocksTilMaturity: integer expected";
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    if (!$util.isInteger(message.recoveredBalance) && !(message.recoveredBalance && $util.isInteger(message.recoveredBalance.low) && $util.isInteger(message.recoveredBalance.high)))
                        return "recoveredBalance: integer|Long expected";
                if (message.pendingHtlcs != null && message.hasOwnProperty("pendingHtlcs")) {
                    if (!Array.isArray(message.pendingHtlcs))
                        return "pendingHtlcs: array expected";
                    for (let i = 0; i < message.pendingHtlcs.length; ++i) {
                        let error = $root.lnrpc.PendingHTLC.verify(message.pendingHtlcs[i]);
                        if (error)
                            return "pendingHtlcs." + error;
                    }
                }
                if (message.anchor != null && message.hasOwnProperty("anchor"))
                    switch (message.anchor) {
                    default:
                        return "anchor: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ForceClosedChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             */
            ForceClosedChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.ForceClosedChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.ForceClosedChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.closingTxid != null)
                    message.closingTxid = String(object.closingTxid);
                if (object.limboBalance != null)
                    if ($util.Long)
                        (message.limboBalance = $util.Long.fromValue(object.limboBalance)).unsigned = false;
                    else if (typeof object.limboBalance === "string")
                        message.limboBalance = parseInt(object.limboBalance, 10);
                    else if (typeof object.limboBalance === "number")
                        message.limboBalance = object.limboBalance;
                    else if (typeof object.limboBalance === "object")
                        message.limboBalance = new $util.LongBits(object.limboBalance.low >>> 0, object.limboBalance.high >>> 0).toNumber();
                if (object.maturityHeight != null)
                    message.maturityHeight = object.maturityHeight >>> 0;
                if (object.blocksTilMaturity != null)
                    message.blocksTilMaturity = object.blocksTilMaturity | 0;
                if (object.recoveredBalance != null)
                    if ($util.Long)
                        (message.recoveredBalance = $util.Long.fromValue(object.recoveredBalance)).unsigned = false;
                    else if (typeof object.recoveredBalance === "string")
                        message.recoveredBalance = parseInt(object.recoveredBalance, 10);
                    else if (typeof object.recoveredBalance === "number")
                        message.recoveredBalance = object.recoveredBalance;
                    else if (typeof object.recoveredBalance === "object")
                        message.recoveredBalance = new $util.LongBits(object.recoveredBalance.low >>> 0, object.recoveredBalance.high >>> 0).toNumber();
                if (object.pendingHtlcs) {
                    if (!Array.isArray(object.pendingHtlcs))
                        throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.pendingHtlcs: array expected");
                    message.pendingHtlcs = [];
                    for (let i = 0; i < object.pendingHtlcs.length; ++i) {
                        if (typeof object.pendingHtlcs[i] !== "object")
                            throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.pendingHtlcs: object expected");
                        message.pendingHtlcs[i] = $root.lnrpc.PendingHTLC.fromObject(object.pendingHtlcs[i]);
                    }
                }
                switch (object.anchor) {
                case "LIMBO":
                case 0:
                    message.anchor = 0;
                    break;
                case "RECOVERED":
                case 1:
                    message.anchor = 1;
                    break;
                case "LOST":
                case 2:
                    message.anchor = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ForceClosedChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.ForceClosedChannel} message ForceClosedChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForceClosedChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.pendingHtlcs = [];
                if (options.defaults) {
                    object.channel = null;
                    object.closingTxid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.limboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limboBalance = options.longs === String ? "0" : 0;
                    object.maturityHeight = 0;
                    object.blocksTilMaturity = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.recoveredBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.recoveredBalance = options.longs === String ? "0" : 0;
                    object.anchor = options.enums === String ? "LIMBO" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    object.closingTxid = message.closingTxid;
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (typeof message.limboBalance === "number")
                        object.limboBalance = options.longs === String ? String(message.limboBalance) : message.limboBalance;
                    else
                        object.limboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.limboBalance) : options.longs === Number ? new $util.LongBits(message.limboBalance.low >>> 0, message.limboBalance.high >>> 0).toNumber() : message.limboBalance;
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    object.maturityHeight = message.maturityHeight;
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    object.blocksTilMaturity = message.blocksTilMaturity;
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    if (typeof message.recoveredBalance === "number")
                        object.recoveredBalance = options.longs === String ? String(message.recoveredBalance) : message.recoveredBalance;
                    else
                        object.recoveredBalance = options.longs === String ? $util.Long.prototype.toString.call(message.recoveredBalance) : options.longs === Number ? new $util.LongBits(message.recoveredBalance.low >>> 0, message.recoveredBalance.high >>> 0).toNumber() : message.recoveredBalance;
                if (message.pendingHtlcs && message.pendingHtlcs.length) {
                    object.pendingHtlcs = [];
                    for (let j = 0; j < message.pendingHtlcs.length; ++j)
                        object.pendingHtlcs[j] = $root.lnrpc.PendingHTLC.toObject(message.pendingHtlcs[j], options);
                }
                if (message.anchor != null && message.hasOwnProperty("anchor"))
                    object.anchor = options.enums === String ? $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState[message.anchor] : message.anchor;
                return object;
            };

            /**
             * Converts this ForceClosedChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForceClosedChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * AnchorState enum.
             * @name lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState
             * @enum {number}
             * @property {number} LIMBO=0 LIMBO value
             * @property {number} RECOVERED=1 RECOVERED value
             * @property {number} LOST=2 LOST value
             */
            ForceClosedChannel.AnchorState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LIMBO"] = 0;
                values[valuesById[1] = "RECOVERED"] = 1;
                values[valuesById[2] = "LOST"] = 2;
                return values;
            })();

            return ForceClosedChannel;
        })();

        return PendingChannelsResponse;
    })();

    lnrpc.ChannelEventSubscription = (function() {

        /**
         * Properties of a ChannelEventSubscription.
         * @memberof lnrpc
         * @interface IChannelEventSubscription
         */

        /**
         * Constructs a new ChannelEventSubscription.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEventSubscription.
         * @implements IChannelEventSubscription
         * @constructor
         * @param {lnrpc.IChannelEventSubscription=} [properties] Properties to set
         */
        function ChannelEventSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelEventSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.IChannelEventSubscription=} [properties] Properties to set
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription instance
         */
        ChannelEventSubscription.create = function create(properties) {
            return new ChannelEventSubscription(properties);
        };

        /**
         * Encodes the specified ChannelEventSubscription message. Does not implicitly {@link lnrpc.ChannelEventSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.IChannelEventSubscription} message ChannelEventSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelEventSubscription message, length delimited. Does not implicitly {@link lnrpc.ChannelEventSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.IChannelEventSubscription} message ChannelEventSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEventSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEventSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEventSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEventSubscription message.
         * @function verify
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEventSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelEventSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription
         */
        ChannelEventSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEventSubscription)
                return object;
            return new $root.lnrpc.ChannelEventSubscription();
        };

        /**
         * Creates a plain object from a ChannelEventSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.ChannelEventSubscription} message ChannelEventSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEventSubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelEventSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEventSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEventSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEventSubscription;
    })();

    lnrpc.ChannelEventUpdate = (function() {

        /**
         * Properties of a ChannelEventUpdate.
         * @memberof lnrpc
         * @interface IChannelEventUpdate
         * @property {lnrpc.IChannel|null} [openChannel] ChannelEventUpdate openChannel
         * @property {lnrpc.IChannelCloseSummary|null} [closedChannel] ChannelEventUpdate closedChannel
         * @property {lnrpc.IChannelPoint|null} [activeChannel] ChannelEventUpdate activeChannel
         * @property {lnrpc.IChannelPoint|null} [inactiveChannel] ChannelEventUpdate inactiveChannel
         * @property {lnrpc.IPendingUpdate|null} [pendingOpenChannel] ChannelEventUpdate pendingOpenChannel
         * @property {lnrpc.ChannelEventUpdate.UpdateType|null} [type] ChannelEventUpdate type
         */

        /**
         * Constructs a new ChannelEventUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEventUpdate.
         * @implements IChannelEventUpdate
         * @constructor
         * @param {lnrpc.IChannelEventUpdate=} [properties] Properties to set
         */
        function ChannelEventUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelEventUpdate openChannel.
         * @member {lnrpc.IChannel|null|undefined} openChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.openChannel = null;

        /**
         * ChannelEventUpdate closedChannel.
         * @member {lnrpc.IChannelCloseSummary|null|undefined} closedChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.closedChannel = null;

        /**
         * ChannelEventUpdate activeChannel.
         * @member {lnrpc.IChannelPoint|null|undefined} activeChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.activeChannel = null;

        /**
         * ChannelEventUpdate inactiveChannel.
         * @member {lnrpc.IChannelPoint|null|undefined} inactiveChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.inactiveChannel = null;

        /**
         * ChannelEventUpdate pendingOpenChannel.
         * @member {lnrpc.IPendingUpdate|null|undefined} pendingOpenChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.pendingOpenChannel = null;

        /**
         * ChannelEventUpdate type.
         * @member {lnrpc.ChannelEventUpdate.UpdateType} type
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.type = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ChannelEventUpdate channel.
         * @member {"openChannel"|"closedChannel"|"activeChannel"|"inactiveChannel"|"pendingOpenChannel"|undefined} channel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        Object.defineProperty(ChannelEventUpdate.prototype, "channel", {
            get: $util.oneOfGetter($oneOfFields = ["openChannel", "closedChannel", "activeChannel", "inactiveChannel", "pendingOpenChannel"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ChannelEventUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.IChannelEventUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate instance
         */
        ChannelEventUpdate.create = function create(properties) {
            return new ChannelEventUpdate(properties);
        };

        /**
         * Encodes the specified ChannelEventUpdate message. Does not implicitly {@link lnrpc.ChannelEventUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.IChannelEventUpdate} message ChannelEventUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.openChannel != null && Object.hasOwnProperty.call(message, "openChannel"))
                $root.lnrpc.Channel.encode(message.openChannel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.closedChannel != null && Object.hasOwnProperty.call(message, "closedChannel"))
                $root.lnrpc.ChannelCloseSummary.encode(message.closedChannel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.activeChannel != null && Object.hasOwnProperty.call(message, "activeChannel"))
                $root.lnrpc.ChannelPoint.encode(message.activeChannel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.inactiveChannel != null && Object.hasOwnProperty.call(message, "inactiveChannel"))
                $root.lnrpc.ChannelPoint.encode(message.inactiveChannel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            if (message.pendingOpenChannel != null && Object.hasOwnProperty.call(message, "pendingOpenChannel"))
                $root.lnrpc.PendingUpdate.encode(message.pendingOpenChannel, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelEventUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelEventUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.IChannelEventUpdate} message ChannelEventUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEventUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEventUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.openChannel = $root.lnrpc.Channel.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.closedChannel = $root.lnrpc.ChannelCloseSummary.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.activeChannel = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.inactiveChannel = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.pendingOpenChannel = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEventUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEventUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEventUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.openChannel != null && message.hasOwnProperty("openChannel")) {
                properties.channel = 1;
                {
                    let error = $root.lnrpc.Channel.verify(message.openChannel);
                    if (error)
                        return "openChannel." + error;
                }
            }
            if (message.closedChannel != null && message.hasOwnProperty("closedChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.ChannelCloseSummary.verify(message.closedChannel);
                    if (error)
                        return "closedChannel." + error;
                }
            }
            if (message.activeChannel != null && message.hasOwnProperty("activeChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.ChannelPoint.verify(message.activeChannel);
                    if (error)
                        return "activeChannel." + error;
                }
            }
            if (message.inactiveChannel != null && message.hasOwnProperty("inactiveChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.ChannelPoint.verify(message.inactiveChannel);
                    if (error)
                        return "inactiveChannel." + error;
                }
            }
            if (message.pendingOpenChannel != null && message.hasOwnProperty("pendingOpenChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.PendingUpdate.verify(message.pendingOpenChannel);
                    if (error)
                        return "pendingOpenChannel." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelEventUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate
         */
        ChannelEventUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEventUpdate)
                return object;
            let message = new $root.lnrpc.ChannelEventUpdate();
            if (object.openChannel != null) {
                if (typeof object.openChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.openChannel: object expected");
                message.openChannel = $root.lnrpc.Channel.fromObject(object.openChannel);
            }
            if (object.closedChannel != null) {
                if (typeof object.closedChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.closedChannel: object expected");
                message.closedChannel = $root.lnrpc.ChannelCloseSummary.fromObject(object.closedChannel);
            }
            if (object.activeChannel != null) {
                if (typeof object.activeChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.activeChannel: object expected");
                message.activeChannel = $root.lnrpc.ChannelPoint.fromObject(object.activeChannel);
            }
            if (object.inactiveChannel != null) {
                if (typeof object.inactiveChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.inactiveChannel: object expected");
                message.inactiveChannel = $root.lnrpc.ChannelPoint.fromObject(object.inactiveChannel);
            }
            if (object.pendingOpenChannel != null) {
                if (typeof object.pendingOpenChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.pendingOpenChannel: object expected");
                message.pendingOpenChannel = $root.lnrpc.PendingUpdate.fromObject(object.pendingOpenChannel);
            }
            switch (object.type) {
            case "OPEN_CHANNEL":
            case 0:
                message.type = 0;
                break;
            case "CLOSED_CHANNEL":
            case 1:
                message.type = 1;
                break;
            case "ACTIVE_CHANNEL":
            case 2:
                message.type = 2;
                break;
            case "INACTIVE_CHANNEL":
            case 3:
                message.type = 3;
                break;
            case "PENDING_OPEN_CHANNEL":
            case 4:
                message.type = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelEventUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.ChannelEventUpdate} message ChannelEventUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEventUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = options.enums === String ? "OPEN_CHANNEL" : 0;
            if (message.openChannel != null && message.hasOwnProperty("openChannel")) {
                object.openChannel = $root.lnrpc.Channel.toObject(message.openChannel, options);
                if (options.oneofs)
                    object.channel = "openChannel";
            }
            if (message.closedChannel != null && message.hasOwnProperty("closedChannel")) {
                object.closedChannel = $root.lnrpc.ChannelCloseSummary.toObject(message.closedChannel, options);
                if (options.oneofs)
                    object.channel = "closedChannel";
            }
            if (message.activeChannel != null && message.hasOwnProperty("activeChannel")) {
                object.activeChannel = $root.lnrpc.ChannelPoint.toObject(message.activeChannel, options);
                if (options.oneofs)
                    object.channel = "activeChannel";
            }
            if (message.inactiveChannel != null && message.hasOwnProperty("inactiveChannel")) {
                object.inactiveChannel = $root.lnrpc.ChannelPoint.toObject(message.inactiveChannel, options);
                if (options.oneofs)
                    object.channel = "inactiveChannel";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.ChannelEventUpdate.UpdateType[message.type] : message.type;
            if (message.pendingOpenChannel != null && message.hasOwnProperty("pendingOpenChannel")) {
                object.pendingOpenChannel = $root.lnrpc.PendingUpdate.toObject(message.pendingOpenChannel, options);
                if (options.oneofs)
                    object.channel = "pendingOpenChannel";
            }
            return object;
        };

        /**
         * Converts this ChannelEventUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEventUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * UpdateType enum.
         * @name lnrpc.ChannelEventUpdate.UpdateType
         * @enum {number}
         * @property {number} OPEN_CHANNEL=0 OPEN_CHANNEL value
         * @property {number} CLOSED_CHANNEL=1 CLOSED_CHANNEL value
         * @property {number} ACTIVE_CHANNEL=2 ACTIVE_CHANNEL value
         * @property {number} INACTIVE_CHANNEL=3 INACTIVE_CHANNEL value
         * @property {number} PENDING_OPEN_CHANNEL=4 PENDING_OPEN_CHANNEL value
         */
        ChannelEventUpdate.UpdateType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OPEN_CHANNEL"] = 0;
            values[valuesById[1] = "CLOSED_CHANNEL"] = 1;
            values[valuesById[2] = "ACTIVE_CHANNEL"] = 2;
            values[valuesById[3] = "INACTIVE_CHANNEL"] = 3;
            values[valuesById[4] = "PENDING_OPEN_CHANNEL"] = 4;
            return values;
        })();

        return ChannelEventUpdate;
    })();

    lnrpc.WalletBalanceRequest = (function() {

        /**
         * Properties of a WalletBalanceRequest.
         * @memberof lnrpc
         * @interface IWalletBalanceRequest
         */

        /**
         * Constructs a new WalletBalanceRequest.
         * @memberof lnrpc
         * @classdesc Represents a WalletBalanceRequest.
         * @implements IWalletBalanceRequest
         * @constructor
         * @param {lnrpc.IWalletBalanceRequest=} [properties] Properties to set
         */
        function WalletBalanceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WalletBalanceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest=} [properties] Properties to set
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest instance
         */
        WalletBalanceRequest.create = function create(properties) {
            return new WalletBalanceRequest(properties);
        };

        /**
         * Encodes the specified WalletBalanceRequest message. Does not implicitly {@link lnrpc.WalletBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest} message WalletBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WalletBalanceRequest message, length delimited. Does not implicitly {@link lnrpc.WalletBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest} message WalletBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WalletBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.WalletBalanceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WalletBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WalletBalanceRequest message.
         * @function verify
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WalletBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WalletBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         */
        WalletBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.WalletBalanceRequest)
                return object;
            return new $root.lnrpc.WalletBalanceRequest();
        };

        /**
         * Creates a plain object from a WalletBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.WalletBalanceRequest} message WalletBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WalletBalanceRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WalletBalanceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.WalletBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WalletBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WalletBalanceRequest;
    })();

    lnrpc.WalletBalanceResponse = (function() {

        /**
         * Properties of a WalletBalanceResponse.
         * @memberof lnrpc
         * @interface IWalletBalanceResponse
         * @property {number|Long|null} [totalBalance] WalletBalanceResponse totalBalance
         * @property {number|Long|null} [confirmedBalance] WalletBalanceResponse confirmedBalance
         * @property {number|Long|null} [unconfirmedBalance] WalletBalanceResponse unconfirmedBalance
         */

        /**
         * Constructs a new WalletBalanceResponse.
         * @memberof lnrpc
         * @classdesc Represents a WalletBalanceResponse.
         * @implements IWalletBalanceResponse
         * @constructor
         * @param {lnrpc.IWalletBalanceResponse=} [properties] Properties to set
         */
        function WalletBalanceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WalletBalanceResponse totalBalance.
         * @member {number|Long} totalBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.totalBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WalletBalanceResponse confirmedBalance.
         * @member {number|Long} confirmedBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.confirmedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WalletBalanceResponse unconfirmedBalance.
         * @member {number|Long} unconfirmedBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.unconfirmedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new WalletBalanceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse=} [properties] Properties to set
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse instance
         */
        WalletBalanceResponse.create = function create(properties) {
            return new WalletBalanceResponse(properties);
        };

        /**
         * Encodes the specified WalletBalanceResponse message. Does not implicitly {@link lnrpc.WalletBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse} message WalletBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalBalance != null && Object.hasOwnProperty.call(message, "totalBalance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalBalance);
            if (message.confirmedBalance != null && Object.hasOwnProperty.call(message, "confirmedBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.confirmedBalance);
            if (message.unconfirmedBalance != null && Object.hasOwnProperty.call(message, "unconfirmedBalance"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.unconfirmedBalance);
            return writer;
        };

        /**
         * Encodes the specified WalletBalanceResponse message, length delimited. Does not implicitly {@link lnrpc.WalletBalanceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse} message WalletBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WalletBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.WalletBalanceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalBalance = reader.int64();
                    break;
                case 2:
                    message.confirmedBalance = reader.int64();
                    break;
                case 3:
                    message.unconfirmedBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WalletBalanceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WalletBalanceResponse message.
         * @function verify
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WalletBalanceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                if (!$util.isInteger(message.totalBalance) && !(message.totalBalance && $util.isInteger(message.totalBalance.low) && $util.isInteger(message.totalBalance.high)))
                    return "totalBalance: integer|Long expected";
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                if (!$util.isInteger(message.confirmedBalance) && !(message.confirmedBalance && $util.isInteger(message.confirmedBalance.low) && $util.isInteger(message.confirmedBalance.high)))
                    return "confirmedBalance: integer|Long expected";
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                if (!$util.isInteger(message.unconfirmedBalance) && !(message.unconfirmedBalance && $util.isInteger(message.unconfirmedBalance.low) && $util.isInteger(message.unconfirmedBalance.high)))
                    return "unconfirmedBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates a WalletBalanceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         */
        WalletBalanceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.WalletBalanceResponse)
                return object;
            let message = new $root.lnrpc.WalletBalanceResponse();
            if (object.totalBalance != null)
                if ($util.Long)
                    (message.totalBalance = $util.Long.fromValue(object.totalBalance)).unsigned = false;
                else if (typeof object.totalBalance === "string")
                    message.totalBalance = parseInt(object.totalBalance, 10);
                else if (typeof object.totalBalance === "number")
                    message.totalBalance = object.totalBalance;
                else if (typeof object.totalBalance === "object")
                    message.totalBalance = new $util.LongBits(object.totalBalance.low >>> 0, object.totalBalance.high >>> 0).toNumber();
            if (object.confirmedBalance != null)
                if ($util.Long)
                    (message.confirmedBalance = $util.Long.fromValue(object.confirmedBalance)).unsigned = false;
                else if (typeof object.confirmedBalance === "string")
                    message.confirmedBalance = parseInt(object.confirmedBalance, 10);
                else if (typeof object.confirmedBalance === "number")
                    message.confirmedBalance = object.confirmedBalance;
                else if (typeof object.confirmedBalance === "object")
                    message.confirmedBalance = new $util.LongBits(object.confirmedBalance.low >>> 0, object.confirmedBalance.high >>> 0).toNumber();
            if (object.unconfirmedBalance != null)
                if ($util.Long)
                    (message.unconfirmedBalance = $util.Long.fromValue(object.unconfirmedBalance)).unsigned = false;
                else if (typeof object.unconfirmedBalance === "string")
                    message.unconfirmedBalance = parseInt(object.unconfirmedBalance, 10);
                else if (typeof object.unconfirmedBalance === "number")
                    message.unconfirmedBalance = object.unconfirmedBalance;
                else if (typeof object.unconfirmedBalance === "object")
                    message.unconfirmedBalance = new $util.LongBits(object.unconfirmedBalance.low >>> 0, object.unconfirmedBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a WalletBalanceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.WalletBalanceResponse} message WalletBalanceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WalletBalanceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.confirmedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.confirmedBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unconfirmedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unconfirmedBalance = options.longs === String ? "0" : 0;
            }
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                if (typeof message.totalBalance === "number")
                    object.totalBalance = options.longs === String ? String(message.totalBalance) : message.totalBalance;
                else
                    object.totalBalance = options.longs === String ? $util.Long.prototype.toString.call(message.totalBalance) : options.longs === Number ? new $util.LongBits(message.totalBalance.low >>> 0, message.totalBalance.high >>> 0).toNumber() : message.totalBalance;
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                if (typeof message.confirmedBalance === "number")
                    object.confirmedBalance = options.longs === String ? String(message.confirmedBalance) : message.confirmedBalance;
                else
                    object.confirmedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.confirmedBalance) : options.longs === Number ? new $util.LongBits(message.confirmedBalance.low >>> 0, message.confirmedBalance.high >>> 0).toNumber() : message.confirmedBalance;
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                if (typeof message.unconfirmedBalance === "number")
                    object.unconfirmedBalance = options.longs === String ? String(message.unconfirmedBalance) : message.unconfirmedBalance;
                else
                    object.unconfirmedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.unconfirmedBalance) : options.longs === Number ? new $util.LongBits(message.unconfirmedBalance.low >>> 0, message.unconfirmedBalance.high >>> 0).toNumber() : message.unconfirmedBalance;
            return object;
        };

        /**
         * Converts this WalletBalanceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WalletBalanceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WalletBalanceResponse;
    })();

    lnrpc.Amount = (function() {

        /**
         * Properties of an Amount.
         * @memberof lnrpc
         * @interface IAmount
         * @property {number|Long|null} [sat] Amount sat
         * @property {number|Long|null} [msat] Amount msat
         */

        /**
         * Constructs a new Amount.
         * @memberof lnrpc
         * @classdesc Represents an Amount.
         * @implements IAmount
         * @constructor
         * @param {lnrpc.IAmount=} [properties] Properties to set
         */
        function Amount(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Amount sat.
         * @member {number|Long} sat
         * @memberof lnrpc.Amount
         * @instance
         */
        Amount.prototype.sat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Amount msat.
         * @member {number|Long} msat
         * @memberof lnrpc.Amount
         * @instance
         */
        Amount.prototype.msat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Amount instance using the specified properties.
         * @function create
         * @memberof lnrpc.Amount
         * @static
         * @param {lnrpc.IAmount=} [properties] Properties to set
         * @returns {lnrpc.Amount} Amount instance
         */
        Amount.create = function create(properties) {
            return new Amount(properties);
        };

        /**
         * Encodes the specified Amount message. Does not implicitly {@link lnrpc.Amount.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Amount
         * @static
         * @param {lnrpc.IAmount} message Amount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Amount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sat != null && Object.hasOwnProperty.call(message, "sat"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sat);
            if (message.msat != null && Object.hasOwnProperty.call(message, "msat"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.msat);
            return writer;
        };

        /**
         * Encodes the specified Amount message, length delimited. Does not implicitly {@link lnrpc.Amount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Amount
         * @static
         * @param {lnrpc.IAmount} message Amount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Amount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Amount message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Amount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Amount} Amount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Amount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Amount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sat = reader.uint64();
                    break;
                case 2:
                    message.msat = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Amount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Amount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Amount} Amount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Amount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Amount message.
         * @function verify
         * @memberof lnrpc.Amount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Amount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sat != null && message.hasOwnProperty("sat"))
                if (!$util.isInteger(message.sat) && !(message.sat && $util.isInteger(message.sat.low) && $util.isInteger(message.sat.high)))
                    return "sat: integer|Long expected";
            if (message.msat != null && message.hasOwnProperty("msat"))
                if (!$util.isInteger(message.msat) && !(message.msat && $util.isInteger(message.msat.low) && $util.isInteger(message.msat.high)))
                    return "msat: integer|Long expected";
            return null;
        };

        /**
         * Creates an Amount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Amount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Amount} Amount
         */
        Amount.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Amount)
                return object;
            let message = new $root.lnrpc.Amount();
            if (object.sat != null)
                if ($util.Long)
                    (message.sat = $util.Long.fromValue(object.sat)).unsigned = true;
                else if (typeof object.sat === "string")
                    message.sat = parseInt(object.sat, 10);
                else if (typeof object.sat === "number")
                    message.sat = object.sat;
                else if (typeof object.sat === "object")
                    message.sat = new $util.LongBits(object.sat.low >>> 0, object.sat.high >>> 0).toNumber(true);
            if (object.msat != null)
                if ($util.Long)
                    (message.msat = $util.Long.fromValue(object.msat)).unsigned = true;
                else if (typeof object.msat === "string")
                    message.msat = parseInt(object.msat, 10);
                else if (typeof object.msat === "number")
                    message.msat = object.msat;
                else if (typeof object.msat === "object")
                    message.msat = new $util.LongBits(object.msat.low >>> 0, object.msat.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Amount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Amount
         * @static
         * @param {lnrpc.Amount} message Amount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Amount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.sat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.msat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.msat = options.longs === String ? "0" : 0;
            }
            if (message.sat != null && message.hasOwnProperty("sat"))
                if (typeof message.sat === "number")
                    object.sat = options.longs === String ? String(message.sat) : message.sat;
                else
                    object.sat = options.longs === String ? $util.Long.prototype.toString.call(message.sat) : options.longs === Number ? new $util.LongBits(message.sat.low >>> 0, message.sat.high >>> 0).toNumber(true) : message.sat;
            if (message.msat != null && message.hasOwnProperty("msat"))
                if (typeof message.msat === "number")
                    object.msat = options.longs === String ? String(message.msat) : message.msat;
                else
                    object.msat = options.longs === String ? $util.Long.prototype.toString.call(message.msat) : options.longs === Number ? new $util.LongBits(message.msat.low >>> 0, message.msat.high >>> 0).toNumber(true) : message.msat;
            return object;
        };

        /**
         * Converts this Amount to JSON.
         * @function toJSON
         * @memberof lnrpc.Amount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Amount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Amount;
    })();

    lnrpc.ChannelBalanceRequest = (function() {

        /**
         * Properties of a ChannelBalanceRequest.
         * @memberof lnrpc
         * @interface IChannelBalanceRequest
         */

        /**
         * Constructs a new ChannelBalanceRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBalanceRequest.
         * @implements IChannelBalanceRequest
         * @constructor
         * @param {lnrpc.IChannelBalanceRequest=} [properties] Properties to set
         */
        function ChannelBalanceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelBalanceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest instance
         */
        ChannelBalanceRequest.create = function create(properties) {
            return new ChannelBalanceRequest(properties);
        };

        /**
         * Encodes the specified ChannelBalanceRequest message. Does not implicitly {@link lnrpc.ChannelBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest} message ChannelBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelBalanceRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest} message ChannelBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBalanceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBalanceRequest message.
         * @function verify
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         */
        ChannelBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBalanceRequest)
                return object;
            return new $root.lnrpc.ChannelBalanceRequest();
        };

        /**
         * Creates a plain object from a ChannelBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.ChannelBalanceRequest} message ChannelBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBalanceRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelBalanceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBalanceRequest;
    })();

    lnrpc.ChannelBalanceResponse = (function() {

        /**
         * Properties of a ChannelBalanceResponse.
         * @memberof lnrpc
         * @interface IChannelBalanceResponse
         * @property {number|Long|null} [balance] ChannelBalanceResponse balance
         * @property {number|Long|null} [pendingOpenBalance] ChannelBalanceResponse pendingOpenBalance
         * @property {lnrpc.IAmount|null} [localBalance] ChannelBalanceResponse localBalance
         * @property {lnrpc.IAmount|null} [remoteBalance] ChannelBalanceResponse remoteBalance
         * @property {lnrpc.IAmount|null} [unsettledLocalBalance] ChannelBalanceResponse unsettledLocalBalance
         * @property {lnrpc.IAmount|null} [unsettledRemoteBalance] ChannelBalanceResponse unsettledRemoteBalance
         * @property {lnrpc.IAmount|null} [pendingOpenLocalBalance] ChannelBalanceResponse pendingOpenLocalBalance
         * @property {lnrpc.IAmount|null} [pendingOpenRemoteBalance] ChannelBalanceResponse pendingOpenRemoteBalance
         */

        /**
         * Constructs a new ChannelBalanceResponse.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBalanceResponse.
         * @implements IChannelBalanceResponse
         * @constructor
         * @param {lnrpc.IChannelBalanceResponse=} [properties] Properties to set
         */
        function ChannelBalanceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelBalanceResponse balance.
         * @member {number|Long} balance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelBalanceResponse pendingOpenBalance.
         * @member {number|Long} pendingOpenBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.pendingOpenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelBalanceResponse localBalance.
         * @member {lnrpc.IAmount|null|undefined} localBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.localBalance = null;

        /**
         * ChannelBalanceResponse remoteBalance.
         * @member {lnrpc.IAmount|null|undefined} remoteBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.remoteBalance = null;

        /**
         * ChannelBalanceResponse unsettledLocalBalance.
         * @member {lnrpc.IAmount|null|undefined} unsettledLocalBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.unsettledLocalBalance = null;

        /**
         * ChannelBalanceResponse unsettledRemoteBalance.
         * @member {lnrpc.IAmount|null|undefined} unsettledRemoteBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.unsettledRemoteBalance = null;

        /**
         * ChannelBalanceResponse pendingOpenLocalBalance.
         * @member {lnrpc.IAmount|null|undefined} pendingOpenLocalBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.pendingOpenLocalBalance = null;

        /**
         * ChannelBalanceResponse pendingOpenRemoteBalance.
         * @member {lnrpc.IAmount|null|undefined} pendingOpenRemoteBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.pendingOpenRemoteBalance = null;

        /**
         * Creates a new ChannelBalanceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse=} [properties] Properties to set
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse instance
         */
        ChannelBalanceResponse.create = function create(properties) {
            return new ChannelBalanceResponse(properties);
        };

        /**
         * Encodes the specified ChannelBalanceResponse message. Does not implicitly {@link lnrpc.ChannelBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse} message ChannelBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.balance);
            if (message.pendingOpenBalance != null && Object.hasOwnProperty.call(message, "pendingOpenBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.pendingOpenBalance);
            if (message.localBalance != null && Object.hasOwnProperty.call(message, "localBalance"))
                $root.lnrpc.Amount.encode(message.localBalance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.remoteBalance != null && Object.hasOwnProperty.call(message, "remoteBalance"))
                $root.lnrpc.Amount.encode(message.remoteBalance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.unsettledLocalBalance != null && Object.hasOwnProperty.call(message, "unsettledLocalBalance"))
                $root.lnrpc.Amount.encode(message.unsettledLocalBalance, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.unsettledRemoteBalance != null && Object.hasOwnProperty.call(message, "unsettledRemoteBalance"))
                $root.lnrpc.Amount.encode(message.unsettledRemoteBalance, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pendingOpenLocalBalance != null && Object.hasOwnProperty.call(message, "pendingOpenLocalBalance"))
                $root.lnrpc.Amount.encode(message.pendingOpenLocalBalance, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.pendingOpenRemoteBalance != null && Object.hasOwnProperty.call(message, "pendingOpenRemoteBalance"))
                $root.lnrpc.Amount.encode(message.pendingOpenRemoteBalance, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelBalanceResponse message, length delimited. Does not implicitly {@link lnrpc.ChannelBalanceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse} message ChannelBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBalanceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.balance = reader.int64();
                    break;
                case 2:
                    message.pendingOpenBalance = reader.int64();
                    break;
                case 3:
                    message.localBalance = $root.lnrpc.Amount.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.remoteBalance = $root.lnrpc.Amount.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.unsettledLocalBalance = $root.lnrpc.Amount.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.unsettledRemoteBalance = $root.lnrpc.Amount.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.pendingOpenLocalBalance = $root.lnrpc.Amount.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.pendingOpenRemoteBalance = $root.lnrpc.Amount.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBalanceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBalanceResponse message.
         * @function verify
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBalanceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                if (!$util.isInteger(message.pendingOpenBalance) && !(message.pendingOpenBalance && $util.isInteger(message.pendingOpenBalance.low) && $util.isInteger(message.pendingOpenBalance.high)))
                    return "pendingOpenBalance: integer|Long expected";
            if (message.localBalance != null && message.hasOwnProperty("localBalance")) {
                let error = $root.lnrpc.Amount.verify(message.localBalance);
                if (error)
                    return "localBalance." + error;
            }
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance")) {
                let error = $root.lnrpc.Amount.verify(message.remoteBalance);
                if (error)
                    return "remoteBalance." + error;
            }
            if (message.unsettledLocalBalance != null && message.hasOwnProperty("unsettledLocalBalance")) {
                let error = $root.lnrpc.Amount.verify(message.unsettledLocalBalance);
                if (error)
                    return "unsettledLocalBalance." + error;
            }
            if (message.unsettledRemoteBalance != null && message.hasOwnProperty("unsettledRemoteBalance")) {
                let error = $root.lnrpc.Amount.verify(message.unsettledRemoteBalance);
                if (error)
                    return "unsettledRemoteBalance." + error;
            }
            if (message.pendingOpenLocalBalance != null && message.hasOwnProperty("pendingOpenLocalBalance")) {
                let error = $root.lnrpc.Amount.verify(message.pendingOpenLocalBalance);
                if (error)
                    return "pendingOpenLocalBalance." + error;
            }
            if (message.pendingOpenRemoteBalance != null && message.hasOwnProperty("pendingOpenRemoteBalance")) {
                let error = $root.lnrpc.Amount.verify(message.pendingOpenRemoteBalance);
                if (error)
                    return "pendingOpenRemoteBalance." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelBalanceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         */
        ChannelBalanceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBalanceResponse)
                return object;
            let message = new $root.lnrpc.ChannelBalanceResponse();
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
            if (object.pendingOpenBalance != null)
                if ($util.Long)
                    (message.pendingOpenBalance = $util.Long.fromValue(object.pendingOpenBalance)).unsigned = false;
                else if (typeof object.pendingOpenBalance === "string")
                    message.pendingOpenBalance = parseInt(object.pendingOpenBalance, 10);
                else if (typeof object.pendingOpenBalance === "number")
                    message.pendingOpenBalance = object.pendingOpenBalance;
                else if (typeof object.pendingOpenBalance === "object")
                    message.pendingOpenBalance = new $util.LongBits(object.pendingOpenBalance.low >>> 0, object.pendingOpenBalance.high >>> 0).toNumber();
            if (object.localBalance != null) {
                if (typeof object.localBalance !== "object")
                    throw TypeError(".lnrpc.ChannelBalanceResponse.localBalance: object expected");
                message.localBalance = $root.lnrpc.Amount.fromObject(object.localBalance);
            }
            if (object.remoteBalance != null) {
                if (typeof object.remoteBalance !== "object")
                    throw TypeError(".lnrpc.ChannelBalanceResponse.remoteBalance: object expected");
                message.remoteBalance = $root.lnrpc.Amount.fromObject(object.remoteBalance);
            }
            if (object.unsettledLocalBalance != null) {
                if (typeof object.unsettledLocalBalance !== "object")
                    throw TypeError(".lnrpc.ChannelBalanceResponse.unsettledLocalBalance: object expected");
                message.unsettledLocalBalance = $root.lnrpc.Amount.fromObject(object.unsettledLocalBalance);
            }
            if (object.unsettledRemoteBalance != null) {
                if (typeof object.unsettledRemoteBalance !== "object")
                    throw TypeError(".lnrpc.ChannelBalanceResponse.unsettledRemoteBalance: object expected");
                message.unsettledRemoteBalance = $root.lnrpc.Amount.fromObject(object.unsettledRemoteBalance);
            }
            if (object.pendingOpenLocalBalance != null) {
                if (typeof object.pendingOpenLocalBalance !== "object")
                    throw TypeError(".lnrpc.ChannelBalanceResponse.pendingOpenLocalBalance: object expected");
                message.pendingOpenLocalBalance = $root.lnrpc.Amount.fromObject(object.pendingOpenLocalBalance);
            }
            if (object.pendingOpenRemoteBalance != null) {
                if (typeof object.pendingOpenRemoteBalance !== "object")
                    throw TypeError(".lnrpc.ChannelBalanceResponse.pendingOpenRemoteBalance: object expected");
                message.pendingOpenRemoteBalance = $root.lnrpc.Amount.fromObject(object.pendingOpenRemoteBalance);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelBalanceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.ChannelBalanceResponse} message ChannelBalanceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBalanceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pendingOpenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pendingOpenBalance = options.longs === String ? "0" : 0;
                object.localBalance = null;
                object.remoteBalance = null;
                object.unsettledLocalBalance = null;
                object.unsettledRemoteBalance = null;
                object.pendingOpenLocalBalance = null;
                object.pendingOpenRemoteBalance = null;
            }
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                if (typeof message.pendingOpenBalance === "number")
                    object.pendingOpenBalance = options.longs === String ? String(message.pendingOpenBalance) : message.pendingOpenBalance;
                else
                    object.pendingOpenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.pendingOpenBalance) : options.longs === Number ? new $util.LongBits(message.pendingOpenBalance.low >>> 0, message.pendingOpenBalance.high >>> 0).toNumber() : message.pendingOpenBalance;
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                object.localBalance = $root.lnrpc.Amount.toObject(message.localBalance, options);
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                object.remoteBalance = $root.lnrpc.Amount.toObject(message.remoteBalance, options);
            if (message.unsettledLocalBalance != null && message.hasOwnProperty("unsettledLocalBalance"))
                object.unsettledLocalBalance = $root.lnrpc.Amount.toObject(message.unsettledLocalBalance, options);
            if (message.unsettledRemoteBalance != null && message.hasOwnProperty("unsettledRemoteBalance"))
                object.unsettledRemoteBalance = $root.lnrpc.Amount.toObject(message.unsettledRemoteBalance, options);
            if (message.pendingOpenLocalBalance != null && message.hasOwnProperty("pendingOpenLocalBalance"))
                object.pendingOpenLocalBalance = $root.lnrpc.Amount.toObject(message.pendingOpenLocalBalance, options);
            if (message.pendingOpenRemoteBalance != null && message.hasOwnProperty("pendingOpenRemoteBalance"))
                object.pendingOpenRemoteBalance = $root.lnrpc.Amount.toObject(message.pendingOpenRemoteBalance, options);
            return object;
        };

        /**
         * Converts this ChannelBalanceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBalanceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBalanceResponse;
    })();

    lnrpc.QueryRoutesRequest = (function() {

        /**
         * Properties of a QueryRoutesRequest.
         * @memberof lnrpc
         * @interface IQueryRoutesRequest
         * @property {string|null} [pubKey] QueryRoutesRequest pubKey
         * @property {number|Long|null} [amt] QueryRoutesRequest amt
         * @property {number|Long|null} [amtMsat] QueryRoutesRequest amtMsat
         * @property {number|null} [finalCltvDelta] QueryRoutesRequest finalCltvDelta
         * @property {lnrpc.IFeeLimit|null} [feeLimit] QueryRoutesRequest feeLimit
         * @property {Array.<Uint8Array>|null} [ignoredNodes] QueryRoutesRequest ignoredNodes
         * @property {Array.<lnrpc.IEdgeLocator>|null} [ignoredEdges] QueryRoutesRequest ignoredEdges
         * @property {string|null} [sourcePubKey] QueryRoutesRequest sourcePubKey
         * @property {boolean|null} [useMissionControl] QueryRoutesRequest useMissionControl
         * @property {Array.<lnrpc.INodePair>|null} [ignoredPairs] QueryRoutesRequest ignoredPairs
         * @property {number|null} [cltvLimit] QueryRoutesRequest cltvLimit
         * @property {Object.<string,Uint8Array>|null} [destCustomRecords] QueryRoutesRequest destCustomRecords
         * @property {number|Long|null} [outgoingChanId] QueryRoutesRequest outgoingChanId
         * @property {Uint8Array|null} [lastHopPubkey] QueryRoutesRequest lastHopPubkey
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] QueryRoutesRequest routeHints
         * @property {Array.<lnrpc.FeatureBit>|null} [destFeatures] QueryRoutesRequest destFeatures
         */

        /**
         * Constructs a new QueryRoutesRequest.
         * @memberof lnrpc
         * @classdesc Represents a QueryRoutesRequest.
         * @implements IQueryRoutesRequest
         * @constructor
         * @param {lnrpc.IQueryRoutesRequest=} [properties] Properties to set
         */
        function QueryRoutesRequest(properties) {
            this.ignoredNodes = [];
            this.ignoredEdges = [];
            this.ignoredPairs = [];
            this.destCustomRecords = {};
            this.routeHints = [];
            this.destFeatures = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRoutesRequest pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.pubKey = "";

        /**
         * QueryRoutesRequest amt.
         * @member {number|Long} amt
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QueryRoutesRequest amtMsat.
         * @member {number|Long} amtMsat
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.amtMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QueryRoutesRequest finalCltvDelta.
         * @member {number} finalCltvDelta
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.finalCltvDelta = 0;

        /**
         * QueryRoutesRequest feeLimit.
         * @member {lnrpc.IFeeLimit|null|undefined} feeLimit
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.feeLimit = null;

        /**
         * QueryRoutesRequest ignoredNodes.
         * @member {Array.<Uint8Array>} ignoredNodes
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.ignoredNodes = $util.emptyArray;

        /**
         * QueryRoutesRequest ignoredEdges.
         * @member {Array.<lnrpc.IEdgeLocator>} ignoredEdges
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.ignoredEdges = $util.emptyArray;

        /**
         * QueryRoutesRequest sourcePubKey.
         * @member {string} sourcePubKey
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.sourcePubKey = "";

        /**
         * QueryRoutesRequest useMissionControl.
         * @member {boolean} useMissionControl
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.useMissionControl = false;

        /**
         * QueryRoutesRequest ignoredPairs.
         * @member {Array.<lnrpc.INodePair>} ignoredPairs
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.ignoredPairs = $util.emptyArray;

        /**
         * QueryRoutesRequest cltvLimit.
         * @member {number} cltvLimit
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.cltvLimit = 0;

        /**
         * QueryRoutesRequest destCustomRecords.
         * @member {Object.<string,Uint8Array>} destCustomRecords
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.destCustomRecords = $util.emptyObject;

        /**
         * QueryRoutesRequest outgoingChanId.
         * @member {number|Long} outgoingChanId
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.outgoingChanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QueryRoutesRequest lastHopPubkey.
         * @member {Uint8Array} lastHopPubkey
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.lastHopPubkey = $util.newBuffer([]);

        /**
         * QueryRoutesRequest routeHints.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.routeHints = $util.emptyArray;

        /**
         * QueryRoutesRequest destFeatures.
         * @member {Array.<lnrpc.FeatureBit>} destFeatures
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.destFeatures = $util.emptyArray;

        /**
         * Creates a new QueryRoutesRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest=} [properties] Properties to set
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest instance
         */
        QueryRoutesRequest.create = function create(properties) {
            return new QueryRoutesRequest(properties);
        };

        /**
         * Encodes the specified QueryRoutesRequest message. Does not implicitly {@link lnrpc.QueryRoutesRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest} message QueryRoutesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.amt != null && Object.hasOwnProperty.call(message, "amt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amt);
            if (message.finalCltvDelta != null && Object.hasOwnProperty.call(message, "finalCltvDelta"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.finalCltvDelta);
            if (message.feeLimit != null && Object.hasOwnProperty.call(message, "feeLimit"))
                $root.lnrpc.FeeLimit.encode(message.feeLimit, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ignoredNodes != null && message.ignoredNodes.length)
                for (let i = 0; i < message.ignoredNodes.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.ignoredNodes[i]);
            if (message.ignoredEdges != null && message.ignoredEdges.length)
                for (let i = 0; i < message.ignoredEdges.length; ++i)
                    $root.lnrpc.EdgeLocator.encode(message.ignoredEdges[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sourcePubKey != null && Object.hasOwnProperty.call(message, "sourcePubKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sourcePubKey);
            if (message.useMissionControl != null && Object.hasOwnProperty.call(message, "useMissionControl"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.useMissionControl);
            if (message.ignoredPairs != null && message.ignoredPairs.length)
                for (let i = 0; i < message.ignoredPairs.length; ++i)
                    $root.lnrpc.NodePair.encode(message.ignoredPairs[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.cltvLimit != null && Object.hasOwnProperty.call(message, "cltvLimit"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.cltvLimit);
            if (message.amtMsat != null && Object.hasOwnProperty.call(message, "amtMsat"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.amtMsat);
            if (message.destCustomRecords != null && Object.hasOwnProperty.call(message, "destCustomRecords"))
                for (let keys = Object.keys(message.destCustomRecords), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.destCustomRecords[keys[i]]).ldelim();
            if (message.outgoingChanId != null && Object.hasOwnProperty.call(message, "outgoingChanId"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.outgoingChanId);
            if (message.lastHopPubkey != null && Object.hasOwnProperty.call(message, "lastHopPubkey"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.lastHopPubkey);
            if (message.routeHints != null && message.routeHints.length)
                for (let i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.destFeatures != null && message.destFeatures.length) {
                writer.uint32(/* id 17, wireType 2 =*/138).fork();
                for (let i = 0; i < message.destFeatures.length; ++i)
                    writer.int32(message.destFeatures[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified QueryRoutesRequest message, length delimited. Does not implicitly {@link lnrpc.QueryRoutesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest} message QueryRoutesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoutesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryRoutesRequest(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.amt = reader.int64();
                    break;
                case 12:
                    message.amtMsat = reader.int64();
                    break;
                case 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case 5:
                    message.feeLimit = $root.lnrpc.FeeLimit.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.ignoredNodes && message.ignoredNodes.length))
                        message.ignoredNodes = [];
                    message.ignoredNodes.push(reader.bytes());
                    break;
                case 7:
                    if (!(message.ignoredEdges && message.ignoredEdges.length))
                        message.ignoredEdges = [];
                    message.ignoredEdges.push($root.lnrpc.EdgeLocator.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.sourcePubKey = reader.string();
                    break;
                case 9:
                    message.useMissionControl = reader.bool();
                    break;
                case 10:
                    if (!(message.ignoredPairs && message.ignoredPairs.length))
                        message.ignoredPairs = [];
                    message.ignoredPairs.push($root.lnrpc.NodePair.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.cltvLimit = reader.uint32();
                    break;
                case 13:
                    if (message.destCustomRecords === $util.emptyObject)
                        message.destCustomRecords = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = [];
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint64();
                            break;
                        case 2:
                            value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.destCustomRecords[typeof key === "object" ? $util.longToHash(key) : key] = value;
                    break;
                case 14:
                    message.outgoingChanId = reader.uint64();
                    break;
                case 15:
                    message.lastHopPubkey = reader.bytes();
                    break;
                case 16:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                case 17:
                    if (!(message.destFeatures && message.destFeatures.length))
                        message.destFeatures = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.destFeatures.push(reader.int32());
                    } else
                        message.destFeatures.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoutesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoutesRequest message.
         * @function verify
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoutesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.amtMsat != null && message.hasOwnProperty("amtMsat"))
                if (!$util.isInteger(message.amtMsat) && !(message.amtMsat && $util.isInteger(message.amtMsat.low) && $util.isInteger(message.amtMsat.high)))
                    return "amtMsat: integer|Long expected";
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                if (!$util.isInteger(message.finalCltvDelta))
                    return "finalCltvDelta: integer expected";
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit")) {
                let error = $root.lnrpc.FeeLimit.verify(message.feeLimit);
                if (error)
                    return "feeLimit." + error;
            }
            if (message.ignoredNodes != null && message.hasOwnProperty("ignoredNodes")) {
                if (!Array.isArray(message.ignoredNodes))
                    return "ignoredNodes: array expected";
                for (let i = 0; i < message.ignoredNodes.length; ++i)
                    if (!(message.ignoredNodes[i] && typeof message.ignoredNodes[i].length === "number" || $util.isString(message.ignoredNodes[i])))
                        return "ignoredNodes: buffer[] expected";
            }
            if (message.ignoredEdges != null && message.hasOwnProperty("ignoredEdges")) {
                if (!Array.isArray(message.ignoredEdges))
                    return "ignoredEdges: array expected";
                for (let i = 0; i < message.ignoredEdges.length; ++i) {
                    let error = $root.lnrpc.EdgeLocator.verify(message.ignoredEdges[i]);
                    if (error)
                        return "ignoredEdges." + error;
                }
            }
            if (message.sourcePubKey != null && message.hasOwnProperty("sourcePubKey"))
                if (!$util.isString(message.sourcePubKey))
                    return "sourcePubKey: string expected";
            if (message.useMissionControl != null && message.hasOwnProperty("useMissionControl"))
                if (typeof message.useMissionControl !== "boolean")
                    return "useMissionControl: boolean expected";
            if (message.ignoredPairs != null && message.hasOwnProperty("ignoredPairs")) {
                if (!Array.isArray(message.ignoredPairs))
                    return "ignoredPairs: array expected";
                for (let i = 0; i < message.ignoredPairs.length; ++i) {
                    let error = $root.lnrpc.NodePair.verify(message.ignoredPairs[i]);
                    if (error)
                        return "ignoredPairs." + error;
                }
            }
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                if (!$util.isInteger(message.cltvLimit))
                    return "cltvLimit: integer expected";
            if (message.destCustomRecords != null && message.hasOwnProperty("destCustomRecords")) {
                if (!$util.isObject(message.destCustomRecords))
                    return "destCustomRecords: object expected";
                let key = Object.keys(message.destCustomRecords);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "destCustomRecords: integer|Long key{k:uint64} expected";
                    if (!(message.destCustomRecords[key[i]] && typeof message.destCustomRecords[key[i]].length === "number" || $util.isString(message.destCustomRecords[key[i]])))
                        return "destCustomRecords: buffer{k:uint64} expected";
                }
            }
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                if (!$util.isInteger(message.outgoingChanId) && !(message.outgoingChanId && $util.isInteger(message.outgoingChanId.low) && $util.isInteger(message.outgoingChanId.high)))
                    return "outgoingChanId: integer|Long expected";
            if (message.lastHopPubkey != null && message.hasOwnProperty("lastHopPubkey"))
                if (!(message.lastHopPubkey && typeof message.lastHopPubkey.length === "number" || $util.isString(message.lastHopPubkey)))
                    return "lastHopPubkey: buffer expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (let i = 0; i < message.routeHints.length; ++i) {
                    let error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            if (message.destFeatures != null && message.hasOwnProperty("destFeatures")) {
                if (!Array.isArray(message.destFeatures))
                    return "destFeatures: array expected";
                for (let i = 0; i < message.destFeatures.length; ++i)
                    switch (message.destFeatures[i]) {
                    default:
                        return "destFeatures: enum value[] expected";
                    case 0:
                    case 1:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a QueryRoutesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         */
        QueryRoutesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryRoutesRequest)
                return object;
            let message = new $root.lnrpc.QueryRoutesRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.amtMsat != null)
                if ($util.Long)
                    (message.amtMsat = $util.Long.fromValue(object.amtMsat)).unsigned = false;
                else if (typeof object.amtMsat === "string")
                    message.amtMsat = parseInt(object.amtMsat, 10);
                else if (typeof object.amtMsat === "number")
                    message.amtMsat = object.amtMsat;
                else if (typeof object.amtMsat === "object")
                    message.amtMsat = new $util.LongBits(object.amtMsat.low >>> 0, object.amtMsat.high >>> 0).toNumber();
            if (object.finalCltvDelta != null)
                message.finalCltvDelta = object.finalCltvDelta | 0;
            if (object.feeLimit != null) {
                if (typeof object.feeLimit !== "object")
                    throw TypeError(".lnrpc.QueryRoutesRequest.feeLimit: object expected");
                message.feeLimit = $root.lnrpc.FeeLimit.fromObject(object.feeLimit);
            }
            if (object.ignoredNodes) {
                if (!Array.isArray(object.ignoredNodes))
                    throw TypeError(".lnrpc.QueryRoutesRequest.ignoredNodes: array expected");
                message.ignoredNodes = [];
                for (let i = 0; i < object.ignoredNodes.length; ++i)
                    if (typeof object.ignoredNodes[i] === "string")
                        $util.base64.decode(object.ignoredNodes[i], message.ignoredNodes[i] = $util.newBuffer($util.base64.length(object.ignoredNodes[i])), 0);
                    else if (object.ignoredNodes[i].length)
                        message.ignoredNodes[i] = object.ignoredNodes[i];
            }
            if (object.ignoredEdges) {
                if (!Array.isArray(object.ignoredEdges))
                    throw TypeError(".lnrpc.QueryRoutesRequest.ignoredEdges: array expected");
                message.ignoredEdges = [];
                for (let i = 0; i < object.ignoredEdges.length; ++i) {
                    if (typeof object.ignoredEdges[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesRequest.ignoredEdges: object expected");
                    message.ignoredEdges[i] = $root.lnrpc.EdgeLocator.fromObject(object.ignoredEdges[i]);
                }
            }
            if (object.sourcePubKey != null)
                message.sourcePubKey = String(object.sourcePubKey);
            if (object.useMissionControl != null)
                message.useMissionControl = Boolean(object.useMissionControl);
            if (object.ignoredPairs) {
                if (!Array.isArray(object.ignoredPairs))
                    throw TypeError(".lnrpc.QueryRoutesRequest.ignoredPairs: array expected");
                message.ignoredPairs = [];
                for (let i = 0; i < object.ignoredPairs.length; ++i) {
                    if (typeof object.ignoredPairs[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesRequest.ignoredPairs: object expected");
                    message.ignoredPairs[i] = $root.lnrpc.NodePair.fromObject(object.ignoredPairs[i]);
                }
            }
            if (object.cltvLimit != null)
                message.cltvLimit = object.cltvLimit >>> 0;
            if (object.destCustomRecords) {
                if (typeof object.destCustomRecords !== "object")
                    throw TypeError(".lnrpc.QueryRoutesRequest.destCustomRecords: object expected");
                message.destCustomRecords = {};
                for (let keys = Object.keys(object.destCustomRecords), i = 0; i < keys.length; ++i)
                    if (typeof object.destCustomRecords[keys[i]] === "string")
                        $util.base64.decode(object.destCustomRecords[keys[i]], message.destCustomRecords[keys[i]] = $util.newBuffer($util.base64.length(object.destCustomRecords[keys[i]])), 0);
                    else if (object.destCustomRecords[keys[i]].length)
                        message.destCustomRecords[keys[i]] = object.destCustomRecords[keys[i]];
            }
            if (object.outgoingChanId != null)
                if ($util.Long)
                    (message.outgoingChanId = $util.Long.fromValue(object.outgoingChanId)).unsigned = true;
                else if (typeof object.outgoingChanId === "string")
                    message.outgoingChanId = parseInt(object.outgoingChanId, 10);
                else if (typeof object.outgoingChanId === "number")
                    message.outgoingChanId = object.outgoingChanId;
                else if (typeof object.outgoingChanId === "object")
                    message.outgoingChanId = new $util.LongBits(object.outgoingChanId.low >>> 0, object.outgoingChanId.high >>> 0).toNumber(true);
            if (object.lastHopPubkey != null)
                if (typeof object.lastHopPubkey === "string")
                    $util.base64.decode(object.lastHopPubkey, message.lastHopPubkey = $util.newBuffer($util.base64.length(object.lastHopPubkey)), 0);
                else if (object.lastHopPubkey.length)
                    message.lastHopPubkey = object.lastHopPubkey;
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.QueryRoutesRequest.routeHints: array expected");
                message.routeHints = [];
                for (let i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesRequest.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            if (object.destFeatures) {
                if (!Array.isArray(object.destFeatures))
                    throw TypeError(".lnrpc.QueryRoutesRequest.destFeatures: array expected");
                message.destFeatures = [];
                for (let i = 0; i < object.destFeatures.length; ++i)
                    switch (object.destFeatures[i]) {
                    default:
                    case "DATALOSS_PROTECT_REQ":
                    case 0:
                        message.destFeatures[i] = 0;
                        break;
                    case "DATALOSS_PROTECT_OPT":
                    case 1:
                        message.destFeatures[i] = 1;
                        break;
                    case "INITIAL_ROUING_SYNC":
                    case 3:
                        message.destFeatures[i] = 3;
                        break;
                    case "UPFRONT_SHUTDOWN_SCRIPT_REQ":
                    case 4:
                        message.destFeatures[i] = 4;
                        break;
                    case "UPFRONT_SHUTDOWN_SCRIPT_OPT":
                    case 5:
                        message.destFeatures[i] = 5;
                        break;
                    case "GOSSIP_QUERIES_REQ":
                    case 6:
                        message.destFeatures[i] = 6;
                        break;
                    case "GOSSIP_QUERIES_OPT":
                    case 7:
                        message.destFeatures[i] = 7;
                        break;
                    case "TLV_ONION_REQ":
                    case 8:
                        message.destFeatures[i] = 8;
                        break;
                    case "TLV_ONION_OPT":
                    case 9:
                        message.destFeatures[i] = 9;
                        break;
                    case "EXT_GOSSIP_QUERIES_REQ":
                    case 10:
                        message.destFeatures[i] = 10;
                        break;
                    case "EXT_GOSSIP_QUERIES_OPT":
                    case 11:
                        message.destFeatures[i] = 11;
                        break;
                    case "STATIC_REMOTE_KEY_REQ":
                    case 12:
                        message.destFeatures[i] = 12;
                        break;
                    case "STATIC_REMOTE_KEY_OPT":
                    case 13:
                        message.destFeatures[i] = 13;
                        break;
                    case "PAYMENT_ADDR_REQ":
                    case 14:
                        message.destFeatures[i] = 14;
                        break;
                    case "PAYMENT_ADDR_OPT":
                    case 15:
                        message.destFeatures[i] = 15;
                        break;
                    case "MPP_REQ":
                    case 16:
                        message.destFeatures[i] = 16;
                        break;
                    case "MPP_OPT":
                    case 17:
                        message.destFeatures[i] = 17;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryRoutesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.QueryRoutesRequest} message QueryRoutesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRoutesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.ignoredNodes = [];
                object.ignoredEdges = [];
                object.ignoredPairs = [];
                object.routeHints = [];
                object.destFeatures = [];
            }
            if (options.objects || options.defaults)
                object.destCustomRecords = {};
            if (options.defaults) {
                object.pubKey = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                object.finalCltvDelta = 0;
                object.feeLimit = null;
                object.sourcePubKey = "";
                object.useMissionControl = false;
                object.cltvLimit = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.outgoingChanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outgoingChanId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.lastHopPubkey = "";
                else {
                    object.lastHopPubkey = [];
                    if (options.bytes !== Array)
                        object.lastHopPubkey = $util.newBuffer(object.lastHopPubkey);
                }
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                object.finalCltvDelta = message.finalCltvDelta;
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                object.feeLimit = $root.lnrpc.FeeLimit.toObject(message.feeLimit, options);
            if (message.ignoredNodes && message.ignoredNodes.length) {
                object.ignoredNodes = [];
                for (let j = 0; j < message.ignoredNodes.length; ++j)
                    object.ignoredNodes[j] = options.bytes === String ? $util.base64.encode(message.ignoredNodes[j], 0, message.ignoredNodes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ignoredNodes[j]) : message.ignoredNodes[j];
            }
            if (message.ignoredEdges && message.ignoredEdges.length) {
                object.ignoredEdges = [];
                for (let j = 0; j < message.ignoredEdges.length; ++j)
                    object.ignoredEdges[j] = $root.lnrpc.EdgeLocator.toObject(message.ignoredEdges[j], options);
            }
            if (message.sourcePubKey != null && message.hasOwnProperty("sourcePubKey"))
                object.sourcePubKey = message.sourcePubKey;
            if (message.useMissionControl != null && message.hasOwnProperty("useMissionControl"))
                object.useMissionControl = message.useMissionControl;
            if (message.ignoredPairs && message.ignoredPairs.length) {
                object.ignoredPairs = [];
                for (let j = 0; j < message.ignoredPairs.length; ++j)
                    object.ignoredPairs[j] = $root.lnrpc.NodePair.toObject(message.ignoredPairs[j], options);
            }
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                object.cltvLimit = message.cltvLimit;
            if (message.amtMsat != null && message.hasOwnProperty("amtMsat"))
                if (typeof message.amtMsat === "number")
                    object.amtMsat = options.longs === String ? String(message.amtMsat) : message.amtMsat;
                else
                    object.amtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtMsat) : options.longs === Number ? new $util.LongBits(message.amtMsat.low >>> 0, message.amtMsat.high >>> 0).toNumber() : message.amtMsat;
            let keys2;
            if (message.destCustomRecords && (keys2 = Object.keys(message.destCustomRecords)).length) {
                object.destCustomRecords = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.destCustomRecords[keys2[j]] = options.bytes === String ? $util.base64.encode(message.destCustomRecords[keys2[j]], 0, message.destCustomRecords[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.destCustomRecords[keys2[j]]) : message.destCustomRecords[keys2[j]];
            }
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                if (typeof message.outgoingChanId === "number")
                    object.outgoingChanId = options.longs === String ? String(message.outgoingChanId) : message.outgoingChanId;
                else
                    object.outgoingChanId = options.longs === String ? $util.Long.prototype.toString.call(message.outgoingChanId) : options.longs === Number ? new $util.LongBits(message.outgoingChanId.low >>> 0, message.outgoingChanId.high >>> 0).toNumber(true) : message.outgoingChanId;
            if (message.lastHopPubkey != null && message.hasOwnProperty("lastHopPubkey"))
                object.lastHopPubkey = options.bytes === String ? $util.base64.encode(message.lastHopPubkey, 0, message.lastHopPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastHopPubkey) : message.lastHopPubkey;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (let j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            if (message.destFeatures && message.destFeatures.length) {
                object.destFeatures = [];
                for (let j = 0; j < message.destFeatures.length; ++j)
                    object.destFeatures[j] = options.enums === String ? $root.lnrpc.FeatureBit[message.destFeatures[j]] : message.destFeatures[j];
            }
            return object;
        };

        /**
         * Converts this QueryRoutesRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRoutesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRoutesRequest;
    })();

    lnrpc.NodePair = (function() {

        /**
         * Properties of a NodePair.
         * @memberof lnrpc
         * @interface INodePair
         * @property {Uint8Array|null} [from] NodePair from
         * @property {Uint8Array|null} [to] NodePair to
         */

        /**
         * Constructs a new NodePair.
         * @memberof lnrpc
         * @classdesc Represents a NodePair.
         * @implements INodePair
         * @constructor
         * @param {lnrpc.INodePair=} [properties] Properties to set
         */
        function NodePair(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodePair from.
         * @member {Uint8Array} from
         * @memberof lnrpc.NodePair
         * @instance
         */
        NodePair.prototype.from = $util.newBuffer([]);

        /**
         * NodePair to.
         * @member {Uint8Array} to
         * @memberof lnrpc.NodePair
         * @instance
         */
        NodePair.prototype.to = $util.newBuffer([]);

        /**
         * Creates a new NodePair instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodePair
         * @static
         * @param {lnrpc.INodePair=} [properties] Properties to set
         * @returns {lnrpc.NodePair} NodePair instance
         */
        NodePair.create = function create(properties) {
            return new NodePair(properties);
        };

        /**
         * Encodes the specified NodePair message. Does not implicitly {@link lnrpc.NodePair.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodePair
         * @static
         * @param {lnrpc.INodePair} message NodePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodePair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
            return writer;
        };

        /**
         * Encodes the specified NodePair message, length delimited. Does not implicitly {@link lnrpc.NodePair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodePair
         * @static
         * @param {lnrpc.INodePair} message NodePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodePair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodePair message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodePair} NodePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodePair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodePair();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = reader.bytes();
                    break;
                case 2:
                    message.to = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodePair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodePair} NodePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodePair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodePair message.
         * @function verify
         * @memberof lnrpc.NodePair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodePair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                    return "from: buffer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                    return "to: buffer expected";
            return null;
        };

        /**
         * Creates a NodePair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodePair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodePair} NodePair
         */
        NodePair.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodePair)
                return object;
            let message = new $root.lnrpc.NodePair();
            if (object.from != null)
                if (typeof object.from === "string")
                    $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                else if (object.from.length)
                    message.from = object.from;
            if (object.to != null)
                if (typeof object.to === "string")
                    $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                else if (object.to.length)
                    message.to = object.to;
            return message;
        };

        /**
         * Creates a plain object from a NodePair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodePair
         * @static
         * @param {lnrpc.NodePair} message NodePair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodePair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.from = "";
                else {
                    object.from = [];
                    if (options.bytes !== Array)
                        object.from = $util.newBuffer(object.from);
                }
                if (options.bytes === String)
                    object.to = "";
                else {
                    object.to = [];
                    if (options.bytes !== Array)
                        object.to = $util.newBuffer(object.to);
                }
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
            return object;
        };

        /**
         * Converts this NodePair to JSON.
         * @function toJSON
         * @memberof lnrpc.NodePair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodePair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodePair;
    })();

    lnrpc.EdgeLocator = (function() {

        /**
         * Properties of an EdgeLocator.
         * @memberof lnrpc
         * @interface IEdgeLocator
         * @property {number|Long|null} [channelId] EdgeLocator channelId
         * @property {boolean|null} [directionReverse] EdgeLocator directionReverse
         */

        /**
         * Constructs a new EdgeLocator.
         * @memberof lnrpc
         * @classdesc Represents an EdgeLocator.
         * @implements IEdgeLocator
         * @constructor
         * @param {lnrpc.IEdgeLocator=} [properties] Properties to set
         */
        function EdgeLocator(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EdgeLocator channelId.
         * @member {number|Long} channelId
         * @memberof lnrpc.EdgeLocator
         * @instance
         */
        EdgeLocator.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EdgeLocator directionReverse.
         * @member {boolean} directionReverse
         * @memberof lnrpc.EdgeLocator
         * @instance
         */
        EdgeLocator.prototype.directionReverse = false;

        /**
         * Creates a new EdgeLocator instance using the specified properties.
         * @function create
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.IEdgeLocator=} [properties] Properties to set
         * @returns {lnrpc.EdgeLocator} EdgeLocator instance
         */
        EdgeLocator.create = function create(properties) {
            return new EdgeLocator(properties);
        };

        /**
         * Encodes the specified EdgeLocator message. Does not implicitly {@link lnrpc.EdgeLocator.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.IEdgeLocator} message EdgeLocator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EdgeLocator.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.directionReverse != null && Object.hasOwnProperty.call(message, "directionReverse"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.directionReverse);
            return writer;
        };

        /**
         * Encodes the specified EdgeLocator message, length delimited. Does not implicitly {@link lnrpc.EdgeLocator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.IEdgeLocator} message EdgeLocator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EdgeLocator.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EdgeLocator message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.EdgeLocator} EdgeLocator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EdgeLocator.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.EdgeLocator();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.directionReverse = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EdgeLocator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.EdgeLocator} EdgeLocator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EdgeLocator.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EdgeLocator message.
         * @function verify
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EdgeLocator.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.directionReverse != null && message.hasOwnProperty("directionReverse"))
                if (typeof message.directionReverse !== "boolean")
                    return "directionReverse: boolean expected";
            return null;
        };

        /**
         * Creates an EdgeLocator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.EdgeLocator} EdgeLocator
         */
        EdgeLocator.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.EdgeLocator)
                return object;
            let message = new $root.lnrpc.EdgeLocator();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.directionReverse != null)
                message.directionReverse = Boolean(object.directionReverse);
            return message;
        };

        /**
         * Creates a plain object from an EdgeLocator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.EdgeLocator} message EdgeLocator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EdgeLocator.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.directionReverse = false;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.directionReverse != null && message.hasOwnProperty("directionReverse"))
                object.directionReverse = message.directionReverse;
            return object;
        };

        /**
         * Converts this EdgeLocator to JSON.
         * @function toJSON
         * @memberof lnrpc.EdgeLocator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EdgeLocator.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EdgeLocator;
    })();

    lnrpc.QueryRoutesResponse = (function() {

        /**
         * Properties of a QueryRoutesResponse.
         * @memberof lnrpc
         * @interface IQueryRoutesResponse
         * @property {Array.<lnrpc.IRoute>|null} [routes] QueryRoutesResponse routes
         * @property {number|null} [successProb] QueryRoutesResponse successProb
         */

        /**
         * Constructs a new QueryRoutesResponse.
         * @memberof lnrpc
         * @classdesc Represents a QueryRoutesResponse.
         * @implements IQueryRoutesResponse
         * @constructor
         * @param {lnrpc.IQueryRoutesResponse=} [properties] Properties to set
         */
        function QueryRoutesResponse(properties) {
            this.routes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRoutesResponse routes.
         * @member {Array.<lnrpc.IRoute>} routes
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         */
        QueryRoutesResponse.prototype.routes = $util.emptyArray;

        /**
         * QueryRoutesResponse successProb.
         * @member {number} successProb
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         */
        QueryRoutesResponse.prototype.successProb = 0;

        /**
         * Creates a new QueryRoutesResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse=} [properties] Properties to set
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse instance
         */
        QueryRoutesResponse.create = function create(properties) {
            return new QueryRoutesResponse(properties);
        };

        /**
         * Encodes the specified QueryRoutesResponse message. Does not implicitly {@link lnrpc.QueryRoutesResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse} message QueryRoutesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.routes != null && message.routes.length)
                for (let i = 0; i < message.routes.length; ++i)
                    $root.lnrpc.Route.encode(message.routes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.successProb != null && Object.hasOwnProperty.call(message, "successProb"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.successProb);
            return writer;
        };

        /**
         * Encodes the specified QueryRoutesResponse message, length delimited. Does not implicitly {@link lnrpc.QueryRoutesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse} message QueryRoutesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoutesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryRoutesResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.routes && message.routes.length))
                        message.routes = [];
                    message.routes.push($root.lnrpc.Route.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.successProb = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoutesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoutesResponse message.
         * @function verify
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoutesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.routes != null && message.hasOwnProperty("routes")) {
                if (!Array.isArray(message.routes))
                    return "routes: array expected";
                for (let i = 0; i < message.routes.length; ++i) {
                    let error = $root.lnrpc.Route.verify(message.routes[i]);
                    if (error)
                        return "routes." + error;
                }
            }
            if (message.successProb != null && message.hasOwnProperty("successProb"))
                if (typeof message.successProb !== "number")
                    return "successProb: number expected";
            return null;
        };

        /**
         * Creates a QueryRoutesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         */
        QueryRoutesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryRoutesResponse)
                return object;
            let message = new $root.lnrpc.QueryRoutesResponse();
            if (object.routes) {
                if (!Array.isArray(object.routes))
                    throw TypeError(".lnrpc.QueryRoutesResponse.routes: array expected");
                message.routes = [];
                for (let i = 0; i < object.routes.length; ++i) {
                    if (typeof object.routes[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesResponse.routes: object expected");
                    message.routes[i] = $root.lnrpc.Route.fromObject(object.routes[i]);
                }
            }
            if (object.successProb != null)
                message.successProb = Number(object.successProb);
            return message;
        };

        /**
         * Creates a plain object from a QueryRoutesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.QueryRoutesResponse} message QueryRoutesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRoutesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.routes = [];
            if (options.defaults)
                object.successProb = 0;
            if (message.routes && message.routes.length) {
                object.routes = [];
                for (let j = 0; j < message.routes.length; ++j)
                    object.routes[j] = $root.lnrpc.Route.toObject(message.routes[j], options);
            }
            if (message.successProb != null && message.hasOwnProperty("successProb"))
                object.successProb = options.json && !isFinite(message.successProb) ? String(message.successProb) : message.successProb;
            return object;
        };

        /**
         * Converts this QueryRoutesResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRoutesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRoutesResponse;
    })();

    lnrpc.Hop = (function() {

        /**
         * Properties of a Hop.
         * @memberof lnrpc
         * @interface IHop
         * @property {number|Long|null} [chanId] Hop chanId
         * @property {number|Long|null} [chanCapacity] Hop chanCapacity
         * @property {number|Long|null} [amtToForward] Hop amtToForward
         * @property {number|Long|null} [fee] Hop fee
         * @property {number|null} [expiry] Hop expiry
         * @property {number|Long|null} [amtToForwardMsat] Hop amtToForwardMsat
         * @property {number|Long|null} [feeMsat] Hop feeMsat
         * @property {string|null} [pubKey] Hop pubKey
         * @property {boolean|null} [tlvPayload] Hop tlvPayload
         * @property {lnrpc.IMPPRecord|null} [mppRecord] Hop mppRecord
         * @property {Object.<string,Uint8Array>|null} [customRecords] Hop customRecords
         */

        /**
         * Constructs a new Hop.
         * @memberof lnrpc
         * @classdesc Represents a Hop.
         * @implements IHop
         * @constructor
         * @param {lnrpc.IHop=} [properties] Properties to set
         */
        function Hop(properties) {
            this.customRecords = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hop chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Hop chanCapacity.
         * @member {number|Long} chanCapacity
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.chanCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop amtToForward.
         * @member {number|Long} amtToForward
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.amtToForward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop fee.
         * @member {number|Long} fee
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop expiry.
         * @member {number} expiry
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.expiry = 0;

        /**
         * Hop amtToForwardMsat.
         * @member {number|Long} amtToForwardMsat
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.amtToForwardMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop feeMsat.
         * @member {number|Long} feeMsat
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.pubKey = "";

        /**
         * Hop tlvPayload.
         * @member {boolean} tlvPayload
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.tlvPayload = false;

        /**
         * Hop mppRecord.
         * @member {lnrpc.IMPPRecord|null|undefined} mppRecord
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.mppRecord = null;

        /**
         * Hop customRecords.
         * @member {Object.<string,Uint8Array>} customRecords
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.customRecords = $util.emptyObject;

        /**
         * Creates a new Hop instance using the specified properties.
         * @function create
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop=} [properties] Properties to set
         * @returns {lnrpc.Hop} Hop instance
         */
        Hop.create = function create(properties) {
            return new Hop(properties);
        };

        /**
         * Encodes the specified Hop message. Does not implicitly {@link lnrpc.Hop.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop} message Hop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.chanCapacity != null && Object.hasOwnProperty.call(message, "chanCapacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.chanCapacity);
            if (message.amtToForward != null && Object.hasOwnProperty.call(message, "amtToForward"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amtToForward);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.expiry);
            if (message.amtToForwardMsat != null && Object.hasOwnProperty.call(message, "amtToForwardMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.amtToForwardMsat);
            if (message.feeMsat != null && Object.hasOwnProperty.call(message, "feeMsat"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.feeMsat);
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.pubKey);
            if (message.tlvPayload != null && Object.hasOwnProperty.call(message, "tlvPayload"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.tlvPayload);
            if (message.mppRecord != null && Object.hasOwnProperty.call(message, "mppRecord"))
                $root.lnrpc.MPPRecord.encode(message.mppRecord, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.customRecords != null && Object.hasOwnProperty.call(message, "customRecords"))
                for (let keys = Object.keys(message.customRecords), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.customRecords[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Hop message, length delimited. Does not implicitly {@link lnrpc.Hop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop} message Hop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hop message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Hop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Hop} Hop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Hop(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.chanCapacity = reader.int64();
                    break;
                case 3:
                    message.amtToForward = reader.int64();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.expiry = reader.uint32();
                    break;
                case 6:
                    message.amtToForwardMsat = reader.int64();
                    break;
                case 7:
                    message.feeMsat = reader.int64();
                    break;
                case 8:
                    message.pubKey = reader.string();
                    break;
                case 9:
                    message.tlvPayload = reader.bool();
                    break;
                case 10:
                    message.mppRecord = $root.lnrpc.MPPRecord.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (message.customRecords === $util.emptyObject)
                        message.customRecords = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = [];
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint64();
                            break;
                        case 2:
                            value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.customRecords[typeof key === "object" ? $util.longToHash(key) : key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Hop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Hop} Hop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hop message.
         * @function verify
         * @memberof lnrpc.Hop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                if (!$util.isInteger(message.chanCapacity) && !(message.chanCapacity && $util.isInteger(message.chanCapacity.low) && $util.isInteger(message.chanCapacity.high)))
                    return "chanCapacity: integer|Long expected";
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                if (!$util.isInteger(message.amtToForward) && !(message.amtToForward && $util.isInteger(message.amtToForward.low) && $util.isInteger(message.amtToForward.high)))
                    return "amtToForward: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry))
                    return "expiry: integer expected";
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                if (!$util.isInteger(message.amtToForwardMsat) && !(message.amtToForwardMsat && $util.isInteger(message.amtToForwardMsat.low) && $util.isInteger(message.amtToForwardMsat.high)))
                    return "amtToForwardMsat: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.tlvPayload != null && message.hasOwnProperty("tlvPayload"))
                if (typeof message.tlvPayload !== "boolean")
                    return "tlvPayload: boolean expected";
            if (message.mppRecord != null && message.hasOwnProperty("mppRecord")) {
                let error = $root.lnrpc.MPPRecord.verify(message.mppRecord);
                if (error)
                    return "mppRecord." + error;
            }
            if (message.customRecords != null && message.hasOwnProperty("customRecords")) {
                if (!$util.isObject(message.customRecords))
                    return "customRecords: object expected";
                let key = Object.keys(message.customRecords);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "customRecords: integer|Long key{k:uint64} expected";
                    if (!(message.customRecords[key[i]] && typeof message.customRecords[key[i]].length === "number" || $util.isString(message.customRecords[key[i]])))
                        return "customRecords: buffer{k:uint64} expected";
                }
            }
            return null;
        };

        /**
         * Creates a Hop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Hop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Hop} Hop
         */
        Hop.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Hop)
                return object;
            let message = new $root.lnrpc.Hop();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chanCapacity != null)
                if ($util.Long)
                    (message.chanCapacity = $util.Long.fromValue(object.chanCapacity)).unsigned = false;
                else if (typeof object.chanCapacity === "string")
                    message.chanCapacity = parseInt(object.chanCapacity, 10);
                else if (typeof object.chanCapacity === "number")
                    message.chanCapacity = object.chanCapacity;
                else if (typeof object.chanCapacity === "object")
                    message.chanCapacity = new $util.LongBits(object.chanCapacity.low >>> 0, object.chanCapacity.high >>> 0).toNumber();
            if (object.amtToForward != null)
                if ($util.Long)
                    (message.amtToForward = $util.Long.fromValue(object.amtToForward)).unsigned = false;
                else if (typeof object.amtToForward === "string")
                    message.amtToForward = parseInt(object.amtToForward, 10);
                else if (typeof object.amtToForward === "number")
                    message.amtToForward = object.amtToForward;
                else if (typeof object.amtToForward === "object")
                    message.amtToForward = new $util.LongBits(object.amtToForward.low >>> 0, object.amtToForward.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.expiry != null)
                message.expiry = object.expiry >>> 0;
            if (object.amtToForwardMsat != null)
                if ($util.Long)
                    (message.amtToForwardMsat = $util.Long.fromValue(object.amtToForwardMsat)).unsigned = false;
                else if (typeof object.amtToForwardMsat === "string")
                    message.amtToForwardMsat = parseInt(object.amtToForwardMsat, 10);
                else if (typeof object.amtToForwardMsat === "number")
                    message.amtToForwardMsat = object.amtToForwardMsat;
                else if (typeof object.amtToForwardMsat === "object")
                    message.amtToForwardMsat = new $util.LongBits(object.amtToForwardMsat.low >>> 0, object.amtToForwardMsat.high >>> 0).toNumber();
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = false;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.tlvPayload != null)
                message.tlvPayload = Boolean(object.tlvPayload);
            if (object.mppRecord != null) {
                if (typeof object.mppRecord !== "object")
                    throw TypeError(".lnrpc.Hop.mppRecord: object expected");
                message.mppRecord = $root.lnrpc.MPPRecord.fromObject(object.mppRecord);
            }
            if (object.customRecords) {
                if (typeof object.customRecords !== "object")
                    throw TypeError(".lnrpc.Hop.customRecords: object expected");
                message.customRecords = {};
                for (let keys = Object.keys(object.customRecords), i = 0; i < keys.length; ++i)
                    if (typeof object.customRecords[keys[i]] === "string")
                        $util.base64.decode(object.customRecords[keys[i]], message.customRecords[keys[i]] = $util.newBuffer($util.base64.length(object.customRecords[keys[i]])), 0);
                    else if (object.customRecords[keys[i]].length)
                        message.customRecords[keys[i]] = object.customRecords[keys[i]];
            }
            return message;
        };

        /**
         * Creates a plain object from a Hop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.Hop} message Hop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.customRecords = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.chanCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanCapacity = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtToForward = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtToForward = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.expiry = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtToForwardMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtToForwardMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
                object.pubKey = "";
                object.tlvPayload = false;
                object.mppRecord = null;
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                if (typeof message.chanCapacity === "number")
                    object.chanCapacity = options.longs === String ? String(message.chanCapacity) : message.chanCapacity;
                else
                    object.chanCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.chanCapacity) : options.longs === Number ? new $util.LongBits(message.chanCapacity.low >>> 0, message.chanCapacity.high >>> 0).toNumber() : message.chanCapacity;
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                if (typeof message.amtToForward === "number")
                    object.amtToForward = options.longs === String ? String(message.amtToForward) : message.amtToForward;
                else
                    object.amtToForward = options.longs === String ? $util.Long.prototype.toString.call(message.amtToForward) : options.longs === Number ? new $util.LongBits(message.amtToForward.low >>> 0, message.amtToForward.high >>> 0).toNumber() : message.amtToForward;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                object.expiry = message.expiry;
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                if (typeof message.amtToForwardMsat === "number")
                    object.amtToForwardMsat = options.longs === String ? String(message.amtToForwardMsat) : message.amtToForwardMsat;
                else
                    object.amtToForwardMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtToForwardMsat) : options.longs === Number ? new $util.LongBits(message.amtToForwardMsat.low >>> 0, message.amtToForwardMsat.high >>> 0).toNumber() : message.amtToForwardMsat;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber() : message.feeMsat;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.tlvPayload != null && message.hasOwnProperty("tlvPayload"))
                object.tlvPayload = message.tlvPayload;
            if (message.mppRecord != null && message.hasOwnProperty("mppRecord"))
                object.mppRecord = $root.lnrpc.MPPRecord.toObject(message.mppRecord, options);
            let keys2;
            if (message.customRecords && (keys2 = Object.keys(message.customRecords)).length) {
                object.customRecords = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.customRecords[keys2[j]] = options.bytes === String ? $util.base64.encode(message.customRecords[keys2[j]], 0, message.customRecords[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.customRecords[keys2[j]]) : message.customRecords[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this Hop to JSON.
         * @function toJSON
         * @memberof lnrpc.Hop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Hop;
    })();

    lnrpc.MPPRecord = (function() {

        /**
         * Properties of a MPPRecord.
         * @memberof lnrpc
         * @interface IMPPRecord
         * @property {Uint8Array|null} [paymentAddr] MPPRecord paymentAddr
         * @property {number|Long|null} [totalAmtMsat] MPPRecord totalAmtMsat
         */

        /**
         * Constructs a new MPPRecord.
         * @memberof lnrpc
         * @classdesc Represents a MPPRecord.
         * @implements IMPPRecord
         * @constructor
         * @param {lnrpc.IMPPRecord=} [properties] Properties to set
         */
        function MPPRecord(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MPPRecord paymentAddr.
         * @member {Uint8Array} paymentAddr
         * @memberof lnrpc.MPPRecord
         * @instance
         */
        MPPRecord.prototype.paymentAddr = $util.newBuffer([]);

        /**
         * MPPRecord totalAmtMsat.
         * @member {number|Long} totalAmtMsat
         * @memberof lnrpc.MPPRecord
         * @instance
         */
        MPPRecord.prototype.totalAmtMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MPPRecord instance using the specified properties.
         * @function create
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {lnrpc.IMPPRecord=} [properties] Properties to set
         * @returns {lnrpc.MPPRecord} MPPRecord instance
         */
        MPPRecord.create = function create(properties) {
            return new MPPRecord(properties);
        };

        /**
         * Encodes the specified MPPRecord message. Does not implicitly {@link lnrpc.MPPRecord.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {lnrpc.IMPPRecord} message MPPRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MPPRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalAmtMsat != null && Object.hasOwnProperty.call(message, "totalAmtMsat"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.totalAmtMsat);
            if (message.paymentAddr != null && Object.hasOwnProperty.call(message, "paymentAddr"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.paymentAddr);
            return writer;
        };

        /**
         * Encodes the specified MPPRecord message, length delimited. Does not implicitly {@link lnrpc.MPPRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {lnrpc.IMPPRecord} message MPPRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MPPRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MPPRecord message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.MPPRecord} MPPRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MPPRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.MPPRecord();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 11:
                    message.paymentAddr = reader.bytes();
                    break;
                case 10:
                    message.totalAmtMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MPPRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.MPPRecord} MPPRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MPPRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MPPRecord message.
         * @function verify
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MPPRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentAddr != null && message.hasOwnProperty("paymentAddr"))
                if (!(message.paymentAddr && typeof message.paymentAddr.length === "number" || $util.isString(message.paymentAddr)))
                    return "paymentAddr: buffer expected";
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (!$util.isInteger(message.totalAmtMsat) && !(message.totalAmtMsat && $util.isInteger(message.totalAmtMsat.low) && $util.isInteger(message.totalAmtMsat.high)))
                    return "totalAmtMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a MPPRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.MPPRecord} MPPRecord
         */
        MPPRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.MPPRecord)
                return object;
            let message = new $root.lnrpc.MPPRecord();
            if (object.paymentAddr != null)
                if (typeof object.paymentAddr === "string")
                    $util.base64.decode(object.paymentAddr, message.paymentAddr = $util.newBuffer($util.base64.length(object.paymentAddr)), 0);
                else if (object.paymentAddr.length)
                    message.paymentAddr = object.paymentAddr;
            if (object.totalAmtMsat != null)
                if ($util.Long)
                    (message.totalAmtMsat = $util.Long.fromValue(object.totalAmtMsat)).unsigned = false;
                else if (typeof object.totalAmtMsat === "string")
                    message.totalAmtMsat = parseInt(object.totalAmtMsat, 10);
                else if (typeof object.totalAmtMsat === "number")
                    message.totalAmtMsat = object.totalAmtMsat;
                else if (typeof object.totalAmtMsat === "object")
                    message.totalAmtMsat = new $util.LongBits(object.totalAmtMsat.low >>> 0, object.totalAmtMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a MPPRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.MPPRecord
         * @static
         * @param {lnrpc.MPPRecord} message MPPRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MPPRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalAmtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmtMsat = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.paymentAddr = "";
                else {
                    object.paymentAddr = [];
                    if (options.bytes !== Array)
                        object.paymentAddr = $util.newBuffer(object.paymentAddr);
                }
            }
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (typeof message.totalAmtMsat === "number")
                    object.totalAmtMsat = options.longs === String ? String(message.totalAmtMsat) : message.totalAmtMsat;
                else
                    object.totalAmtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmtMsat) : options.longs === Number ? new $util.LongBits(message.totalAmtMsat.low >>> 0, message.totalAmtMsat.high >>> 0).toNumber() : message.totalAmtMsat;
            if (message.paymentAddr != null && message.hasOwnProperty("paymentAddr"))
                object.paymentAddr = options.bytes === String ? $util.base64.encode(message.paymentAddr, 0, message.paymentAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentAddr) : message.paymentAddr;
            return object;
        };

        /**
         * Converts this MPPRecord to JSON.
         * @function toJSON
         * @memberof lnrpc.MPPRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MPPRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MPPRecord;
    })();

    lnrpc.Route = (function() {

        /**
         * Properties of a Route.
         * @memberof lnrpc
         * @interface IRoute
         * @property {number|null} [totalTimeLock] Route totalTimeLock
         * @property {number|Long|null} [totalFees] Route totalFees
         * @property {number|Long|null} [totalAmt] Route totalAmt
         * @property {Array.<lnrpc.IHop>|null} [hops] Route hops
         * @property {number|Long|null} [totalFeesMsat] Route totalFeesMsat
         * @property {number|Long|null} [totalAmtMsat] Route totalAmtMsat
         */

        /**
         * Constructs a new Route.
         * @memberof lnrpc
         * @classdesc Represents a Route.
         * @implements IRoute
         * @constructor
         * @param {lnrpc.IRoute=} [properties] Properties to set
         */
        function Route(properties) {
            this.hops = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Route totalTimeLock.
         * @member {number} totalTimeLock
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalTimeLock = 0;

        /**
         * Route totalFees.
         * @member {number|Long} totalFees
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalFees = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Route totalAmt.
         * @member {number|Long} totalAmt
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalAmt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Route hops.
         * @member {Array.<lnrpc.IHop>} hops
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.hops = $util.emptyArray;

        /**
         * Route totalFeesMsat.
         * @member {number|Long} totalFeesMsat
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalFeesMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Route totalAmtMsat.
         * @member {number|Long} totalAmtMsat
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalAmtMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Route instance using the specified properties.
         * @function create
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute=} [properties] Properties to set
         * @returns {lnrpc.Route} Route instance
         */
        Route.create = function create(properties) {
            return new Route(properties);
        };

        /**
         * Encodes the specified Route message. Does not implicitly {@link lnrpc.Route.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute} message Route message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Route.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalTimeLock != null && Object.hasOwnProperty.call(message, "totalTimeLock"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.totalTimeLock);
            if (message.totalFees != null && Object.hasOwnProperty.call(message, "totalFees"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalFees);
            if (message.totalAmt != null && Object.hasOwnProperty.call(message, "totalAmt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalAmt);
            if (message.hops != null && message.hops.length)
                for (let i = 0; i < message.hops.length; ++i)
                    $root.lnrpc.Hop.encode(message.hops[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.totalFeesMsat != null && Object.hasOwnProperty.call(message, "totalFeesMsat"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.totalFeesMsat);
            if (message.totalAmtMsat != null && Object.hasOwnProperty.call(message, "totalAmtMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalAmtMsat);
            return writer;
        };

        /**
         * Encodes the specified Route message, length delimited. Does not implicitly {@link lnrpc.Route.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute} message Route message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Route.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Route message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Route
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Route} Route
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Route.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Route();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalTimeLock = reader.uint32();
                    break;
                case 2:
                    message.totalFees = reader.int64();
                    break;
                case 3:
                    message.totalAmt = reader.int64();
                    break;
                case 4:
                    if (!(message.hops && message.hops.length))
                        message.hops = [];
                    message.hops.push($root.lnrpc.Hop.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.totalFeesMsat = reader.int64();
                    break;
                case 6:
                    message.totalAmtMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Route message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Route
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Route} Route
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Route.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Route message.
         * @function verify
         * @memberof lnrpc.Route
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Route.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                if (!$util.isInteger(message.totalTimeLock))
                    return "totalTimeLock: integer expected";
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (!$util.isInteger(message.totalFees) && !(message.totalFees && $util.isInteger(message.totalFees.low) && $util.isInteger(message.totalFees.high)))
                    return "totalFees: integer|Long expected";
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                if (!$util.isInteger(message.totalAmt) && !(message.totalAmt && $util.isInteger(message.totalAmt.low) && $util.isInteger(message.totalAmt.high)))
                    return "totalAmt: integer|Long expected";
            if (message.hops != null && message.hasOwnProperty("hops")) {
                if (!Array.isArray(message.hops))
                    return "hops: array expected";
                for (let i = 0; i < message.hops.length; ++i) {
                    let error = $root.lnrpc.Hop.verify(message.hops[i]);
                    if (error)
                        return "hops." + error;
                }
            }
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                if (!$util.isInteger(message.totalFeesMsat) && !(message.totalFeesMsat && $util.isInteger(message.totalFeesMsat.low) && $util.isInteger(message.totalFeesMsat.high)))
                    return "totalFeesMsat: integer|Long expected";
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (!$util.isInteger(message.totalAmtMsat) && !(message.totalAmtMsat && $util.isInteger(message.totalAmtMsat.low) && $util.isInteger(message.totalAmtMsat.high)))
                    return "totalAmtMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a Route message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Route
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Route} Route
         */
        Route.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Route)
                return object;
            let message = new $root.lnrpc.Route();
            if (object.totalTimeLock != null)
                message.totalTimeLock = object.totalTimeLock >>> 0;
            if (object.totalFees != null)
                if ($util.Long)
                    (message.totalFees = $util.Long.fromValue(object.totalFees)).unsigned = false;
                else if (typeof object.totalFees === "string")
                    message.totalFees = parseInt(object.totalFees, 10);
                else if (typeof object.totalFees === "number")
                    message.totalFees = object.totalFees;
                else if (typeof object.totalFees === "object")
                    message.totalFees = new $util.LongBits(object.totalFees.low >>> 0, object.totalFees.high >>> 0).toNumber();
            if (object.totalAmt != null)
                if ($util.Long)
                    (message.totalAmt = $util.Long.fromValue(object.totalAmt)).unsigned = false;
                else if (typeof object.totalAmt === "string")
                    message.totalAmt = parseInt(object.totalAmt, 10);
                else if (typeof object.totalAmt === "number")
                    message.totalAmt = object.totalAmt;
                else if (typeof object.totalAmt === "object")
                    message.totalAmt = new $util.LongBits(object.totalAmt.low >>> 0, object.totalAmt.high >>> 0).toNumber();
            if (object.hops) {
                if (!Array.isArray(object.hops))
                    throw TypeError(".lnrpc.Route.hops: array expected");
                message.hops = [];
                for (let i = 0; i < object.hops.length; ++i) {
                    if (typeof object.hops[i] !== "object")
                        throw TypeError(".lnrpc.Route.hops: object expected");
                    message.hops[i] = $root.lnrpc.Hop.fromObject(object.hops[i]);
                }
            }
            if (object.totalFeesMsat != null)
                if ($util.Long)
                    (message.totalFeesMsat = $util.Long.fromValue(object.totalFeesMsat)).unsigned = false;
                else if (typeof object.totalFeesMsat === "string")
                    message.totalFeesMsat = parseInt(object.totalFeesMsat, 10);
                else if (typeof object.totalFeesMsat === "number")
                    message.totalFeesMsat = object.totalFeesMsat;
                else if (typeof object.totalFeesMsat === "object")
                    message.totalFeesMsat = new $util.LongBits(object.totalFeesMsat.low >>> 0, object.totalFeesMsat.high >>> 0).toNumber();
            if (object.totalAmtMsat != null)
                if ($util.Long)
                    (message.totalAmtMsat = $util.Long.fromValue(object.totalAmtMsat)).unsigned = false;
                else if (typeof object.totalAmtMsat === "string")
                    message.totalAmtMsat = parseInt(object.totalAmtMsat, 10);
                else if (typeof object.totalAmtMsat === "number")
                    message.totalAmtMsat = object.totalAmtMsat;
                else if (typeof object.totalAmtMsat === "object")
                    message.totalAmtMsat = new $util.LongBits(object.totalAmtMsat.low >>> 0, object.totalAmtMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Route message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.Route} message Route
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Route.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.hops = [];
            if (options.defaults) {
                object.totalTimeLock = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalFees = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFees = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalAmt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalFeesMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFeesMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalAmtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmtMsat = options.longs === String ? "0" : 0;
            }
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                object.totalTimeLock = message.totalTimeLock;
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (typeof message.totalFees === "number")
                    object.totalFees = options.longs === String ? String(message.totalFees) : message.totalFees;
                else
                    object.totalFees = options.longs === String ? $util.Long.prototype.toString.call(message.totalFees) : options.longs === Number ? new $util.LongBits(message.totalFees.low >>> 0, message.totalFees.high >>> 0).toNumber() : message.totalFees;
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                if (typeof message.totalAmt === "number")
                    object.totalAmt = options.longs === String ? String(message.totalAmt) : message.totalAmt;
                else
                    object.totalAmt = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmt) : options.longs === Number ? new $util.LongBits(message.totalAmt.low >>> 0, message.totalAmt.high >>> 0).toNumber() : message.totalAmt;
            if (message.hops && message.hops.length) {
                object.hops = [];
                for (let j = 0; j < message.hops.length; ++j)
                    object.hops[j] = $root.lnrpc.Hop.toObject(message.hops[j], options);
            }
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                if (typeof message.totalFeesMsat === "number")
                    object.totalFeesMsat = options.longs === String ? String(message.totalFeesMsat) : message.totalFeesMsat;
                else
                    object.totalFeesMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalFeesMsat) : options.longs === Number ? new $util.LongBits(message.totalFeesMsat.low >>> 0, message.totalFeesMsat.high >>> 0).toNumber() : message.totalFeesMsat;
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (typeof message.totalAmtMsat === "number")
                    object.totalAmtMsat = options.longs === String ? String(message.totalAmtMsat) : message.totalAmtMsat;
                else
                    object.totalAmtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmtMsat) : options.longs === Number ? new $util.LongBits(message.totalAmtMsat.low >>> 0, message.totalAmtMsat.high >>> 0).toNumber() : message.totalAmtMsat;
            return object;
        };

        /**
         * Converts this Route to JSON.
         * @function toJSON
         * @memberof lnrpc.Route
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Route.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Route;
    })();

    lnrpc.NodeInfoRequest = (function() {

        /**
         * Properties of a NodeInfoRequest.
         * @memberof lnrpc
         * @interface INodeInfoRequest
         * @property {string|null} [pubKey] NodeInfoRequest pubKey
         * @property {boolean|null} [includeChannels] NodeInfoRequest includeChannels
         */

        /**
         * Constructs a new NodeInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a NodeInfoRequest.
         * @implements INodeInfoRequest
         * @constructor
         * @param {lnrpc.INodeInfoRequest=} [properties] Properties to set
         */
        function NodeInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeInfoRequest pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         */
        NodeInfoRequest.prototype.pubKey = "";

        /**
         * NodeInfoRequest includeChannels.
         * @member {boolean} includeChannels
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         */
        NodeInfoRequest.prototype.includeChannels = false;

        /**
         * Creates a new NodeInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest instance
         */
        NodeInfoRequest.create = function create(properties) {
            return new NodeInfoRequest(properties);
        };

        /**
         * Encodes the specified NodeInfoRequest message. Does not implicitly {@link lnrpc.NodeInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.includeChannels != null && Object.hasOwnProperty.call(message, "includeChannels"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeChannels);
            return writer;
        };

        /**
         * Encodes the specified NodeInfoRequest message, length delimited. Does not implicitly {@link lnrpc.NodeInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.includeChannels = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfoRequest message.
         * @function verify
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.includeChannels != null && message.hasOwnProperty("includeChannels"))
                if (typeof message.includeChannels !== "boolean")
                    return "includeChannels: boolean expected";
            return null;
        };

        /**
         * Creates a NodeInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         */
        NodeInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeInfoRequest)
                return object;
            let message = new $root.lnrpc.NodeInfoRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.includeChannels != null)
                message.includeChannels = Boolean(object.includeChannels);
            return message;
        };

        /**
         * Creates a plain object from a NodeInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.NodeInfoRequest} message NodeInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pubKey = "";
                object.includeChannels = false;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.includeChannels != null && message.hasOwnProperty("includeChannels"))
                object.includeChannels = message.includeChannels;
            return object;
        };

        /**
         * Converts this NodeInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeInfoRequest;
    })();

    lnrpc.NodeInfo = (function() {

        /**
         * Properties of a NodeInfo.
         * @memberof lnrpc
         * @interface INodeInfo
         * @property {lnrpc.ILightningNode|null} [node] NodeInfo node
         * @property {number|null} [numChannels] NodeInfo numChannels
         * @property {number|Long|null} [totalCapacity] NodeInfo totalCapacity
         * @property {Array.<lnrpc.IChannelEdge>|null} [channels] NodeInfo channels
         */

        /**
         * Constructs a new NodeInfo.
         * @memberof lnrpc
         * @classdesc Represents a NodeInfo.
         * @implements INodeInfo
         * @constructor
         * @param {lnrpc.INodeInfo=} [properties] Properties to set
         */
        function NodeInfo(properties) {
            this.channels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeInfo node.
         * @member {lnrpc.ILightningNode|null|undefined} node
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.node = null;

        /**
         * NodeInfo numChannels.
         * @member {number} numChannels
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.numChannels = 0;

        /**
         * NodeInfo totalCapacity.
         * @member {number|Long} totalCapacity
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.totalCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeInfo channels.
         * @member {Array.<lnrpc.IChannelEdge>} channels
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.channels = $util.emptyArray;

        /**
         * Creates a new NodeInfo instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo=} [properties] Properties to set
         * @returns {lnrpc.NodeInfo} NodeInfo instance
         */
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };

        /**
         * Encodes the specified NodeInfo message. Does not implicitly {@link lnrpc.NodeInfo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
                $root.lnrpc.LightningNode.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.numChannels != null && Object.hasOwnProperty.call(message, "numChannels"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numChannels);
            if (message.totalCapacity != null && Object.hasOwnProperty.call(message, "totalCapacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalCapacity);
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.ChannelEdge.encode(message.channels[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeInfo message, length delimited. Does not implicitly {@link lnrpc.NodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.node = $root.lnrpc.LightningNode.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.numChannels = reader.uint32();
                    break;
                case 3:
                    message.totalCapacity = reader.int64();
                    break;
                case 4:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.ChannelEdge.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfo message.
         * @function verify
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
                let error = $root.lnrpc.LightningNode.verify(message.node);
                if (error)
                    return "node." + error;
            }
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                if (!$util.isInteger(message.totalCapacity) && !(message.totalCapacity && $util.isInteger(message.totalCapacity.low) && $util.isInteger(message.totalCapacity.high)))
                    return "totalCapacity: integer|Long expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.lnrpc.ChannelEdge.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeInfo} NodeInfo
         */
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeInfo)
                return object;
            let message = new $root.lnrpc.NodeInfo();
            if (object.node != null) {
                if (typeof object.node !== "object")
                    throw TypeError(".lnrpc.NodeInfo.node: object expected");
                message.node = $root.lnrpc.LightningNode.fromObject(object.node);
            }
            if (object.numChannels != null)
                message.numChannels = object.numChannels >>> 0;
            if (object.totalCapacity != null)
                if ($util.Long)
                    (message.totalCapacity = $util.Long.fromValue(object.totalCapacity)).unsigned = false;
                else if (typeof object.totalCapacity === "string")
                    message.totalCapacity = parseInt(object.totalCapacity, 10);
                else if (typeof object.totalCapacity === "number")
                    message.totalCapacity = object.totalCapacity;
                else if (typeof object.totalCapacity === "object")
                    message.totalCapacity = new $util.LongBits(object.totalCapacity.low >>> 0, object.totalCapacity.high >>> 0).toNumber();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.NodeInfo.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.NodeInfo.channels: object expected");
                    message.channels[i] = $root.lnrpc.ChannelEdge.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.NodeInfo} message NodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (options.defaults) {
                object.node = null;
                object.numChannels = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalCapacity = options.longs === String ? "0" : 0;
            }
            if (message.node != null && message.hasOwnProperty("node"))
                object.node = $root.lnrpc.LightningNode.toObject(message.node, options);
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                if (typeof message.totalCapacity === "number")
                    object.totalCapacity = options.longs === String ? String(message.totalCapacity) : message.totalCapacity;
                else
                    object.totalCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.totalCapacity) : options.longs === Number ? new $util.LongBits(message.totalCapacity.low >>> 0, message.totalCapacity.high >>> 0).toNumber() : message.totalCapacity;
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.ChannelEdge.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this NodeInfo to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeInfo;
    })();

    lnrpc.LightningNode = (function() {

        /**
         * Properties of a LightningNode.
         * @memberof lnrpc
         * @interface ILightningNode
         * @property {number|null} [lastUpdate] LightningNode lastUpdate
         * @property {string|null} [pubKey] LightningNode pubKey
         * @property {string|null} [alias] LightningNode alias
         * @property {Array.<lnrpc.INodeAddress>|null} [addresses] LightningNode addresses
         * @property {string|null} [color] LightningNode color
         * @property {Object.<string,lnrpc.IFeature>|null} [features] LightningNode features
         */

        /**
         * Constructs a new LightningNode.
         * @memberof lnrpc
         * @classdesc Represents a LightningNode.
         * @implements ILightningNode
         * @constructor
         * @param {lnrpc.ILightningNode=} [properties] Properties to set
         */
        function LightningNode(properties) {
            this.addresses = [];
            this.features = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightningNode lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.lastUpdate = 0;

        /**
         * LightningNode pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.pubKey = "";

        /**
         * LightningNode alias.
         * @member {string} alias
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.alias = "";

        /**
         * LightningNode addresses.
         * @member {Array.<lnrpc.INodeAddress>} addresses
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.addresses = $util.emptyArray;

        /**
         * LightningNode color.
         * @member {string} color
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.color = "";

        /**
         * LightningNode features.
         * @member {Object.<string,lnrpc.IFeature>} features
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.features = $util.emptyObject;

        /**
         * Creates a new LightningNode instance using the specified properties.
         * @function create
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode=} [properties] Properties to set
         * @returns {lnrpc.LightningNode} LightningNode instance
         */
        LightningNode.create = function create(properties) {
            return new LightningNode(properties);
        };

        /**
         * Encodes the specified LightningNode message. Does not implicitly {@link lnrpc.LightningNode.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode} message LightningNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastUpdate != null && Object.hasOwnProperty.call(message, "lastUpdate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.lastUpdate);
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pubKey);
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            if (message.addresses != null && message.addresses.length)
                for (let i = 0; i < message.addresses.length; ++i)
                    $root.lnrpc.NodeAddress.encode(message.addresses[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.lnrpc.Feature.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified LightningNode message, length delimited. Does not implicitly {@link lnrpc.LightningNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode} message LightningNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightningNode message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.LightningNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.LightningNode} LightningNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.LightningNode(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastUpdate = reader.uint32();
                    break;
                case 2:
                    message.pubKey = reader.string();
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                case 4:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push($root.lnrpc.NodeAddress.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                case 6:
                    if (message.features === $util.emptyObject)
                        message.features = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint32();
                            break;
                        case 2:
                            value = $root.lnrpc.Feature.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.features[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightningNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.LightningNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.LightningNode} LightningNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightningNode message.
         * @function verify
         * @memberof lnrpc.LightningNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightningNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (let i = 0; i < message.addresses.length; ++i) {
                    let error = $root.lnrpc.NodeAddress.verify(message.addresses[i]);
                    if (error)
                        return "addresses." + error;
                }
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "features: integer key{k:uint32} expected";
                    {
                        let error = $root.lnrpc.Feature.verify(message.features[key[i]]);
                        if (error)
                            return "features." + error;
                    }
                }
            }
            return null;
        };

        /**
         * Creates a LightningNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.LightningNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.LightningNode} LightningNode
         */
        LightningNode.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.LightningNode)
                return object;
            let message = new $root.lnrpc.LightningNode();
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".lnrpc.LightningNode.addresses: array expected");
                message.addresses = [];
                for (let i = 0; i < object.addresses.length; ++i) {
                    if (typeof object.addresses[i] !== "object")
                        throw TypeError(".lnrpc.LightningNode.addresses: object expected");
                    message.addresses[i] = $root.lnrpc.NodeAddress.fromObject(object.addresses[i]);
                }
            }
            if (object.color != null)
                message.color = String(object.color);
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".lnrpc.LightningNode.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".lnrpc.LightningNode.features: object expected");
                    message.features[keys[i]] = $root.lnrpc.Feature.fromObject(object.features[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LightningNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.LightningNode} message LightningNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightningNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.objects || options.defaults)
                object.features = {};
            if (options.defaults) {
                object.lastUpdate = 0;
                object.pubKey = "";
                object.alias = "";
                object.color = "";
            }
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (let j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = $root.lnrpc.NodeAddress.toObject(message.addresses[j], options);
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.lnrpc.Feature.toObject(message.features[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this LightningNode to JSON.
         * @function toJSON
         * @memberof lnrpc.LightningNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightningNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightningNode;
    })();

    lnrpc.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof lnrpc
         * @interface INodeAddress
         * @property {string|null} [network] NodeAddress network
         * @property {string|null} [addr] NodeAddress addr
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof lnrpc
         * @classdesc Represents a NodeAddress.
         * @implements INodeAddress
         * @constructor
         * @param {lnrpc.INodeAddress=} [properties] Properties to set
         */
        function NodeAddress(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeAddress network.
         * @member {string} network
         * @memberof lnrpc.NodeAddress
         * @instance
         */
        NodeAddress.prototype.network = "";

        /**
         * NodeAddress addr.
         * @member {string} addr
         * @memberof lnrpc.NodeAddress
         * @instance
         */
        NodeAddress.prototype.addr = "";

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress=} [properties] Properties to set
         * @returns {lnrpc.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link lnrpc.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.network);
            if (message.addr != null && Object.hasOwnProperty.call(message, "addr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.addr);
            return writer;
        };

        /**
         * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link lnrpc.NodeAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeAddress();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.network = reader.string();
                    break;
                case 2:
                    message.addr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeAddress message.
         * @function verify
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.network != null && message.hasOwnProperty("network"))
                if (!$util.isString(message.network))
                    return "network: string expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            return null;
        };

        /**
         * Creates a NodeAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeAddress} NodeAddress
         */
        NodeAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeAddress)
                return object;
            let message = new $root.lnrpc.NodeAddress();
            if (object.network != null)
                message.network = String(object.network);
            if (object.addr != null)
                message.addr = String(object.addr);
            return message;
        };

        /**
         * Creates a plain object from a NodeAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.NodeAddress} message NodeAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.network = "";
                object.addr = "";
            }
            if (message.network != null && message.hasOwnProperty("network"))
                object.network = message.network;
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            return object;
        };

        /**
         * Converts this NodeAddress to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeAddress;
    })();

    lnrpc.RoutingPolicy = (function() {

        /**
         * Properties of a RoutingPolicy.
         * @memberof lnrpc
         * @interface IRoutingPolicy
         * @property {number|null} [timeLockDelta] RoutingPolicy timeLockDelta
         * @property {number|Long|null} [minHtlc] RoutingPolicy minHtlc
         * @property {number|Long|null} [feeBaseMsat] RoutingPolicy feeBaseMsat
         * @property {number|Long|null} [feeRateMilliMsat] RoutingPolicy feeRateMilliMsat
         * @property {boolean|null} [disabled] RoutingPolicy disabled
         * @property {number|Long|null} [maxHtlcMsat] RoutingPolicy maxHtlcMsat
         * @property {number|null} [lastUpdate] RoutingPolicy lastUpdate
         */

        /**
         * Constructs a new RoutingPolicy.
         * @memberof lnrpc
         * @classdesc Represents a RoutingPolicy.
         * @implements IRoutingPolicy
         * @constructor
         * @param {lnrpc.IRoutingPolicy=} [properties] Properties to set
         */
        function RoutingPolicy(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoutingPolicy timeLockDelta.
         * @member {number} timeLockDelta
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.timeLockDelta = 0;

        /**
         * RoutingPolicy minHtlc.
         * @member {number|Long} minHtlc
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.minHtlc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy feeBaseMsat.
         * @member {number|Long} feeBaseMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.feeBaseMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy feeRateMilliMsat.
         * @member {number|Long} feeRateMilliMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.feeRateMilliMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy disabled.
         * @member {boolean} disabled
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.disabled = false;

        /**
         * RoutingPolicy maxHtlcMsat.
         * @member {number|Long} maxHtlcMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.maxHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RoutingPolicy lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.lastUpdate = 0;

        /**
         * Creates a new RoutingPolicy instance using the specified properties.
         * @function create
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy=} [properties] Properties to set
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy instance
         */
        RoutingPolicy.create = function create(properties) {
            return new RoutingPolicy(properties);
        };

        /**
         * Encodes the specified RoutingPolicy message. Does not implicitly {@link lnrpc.RoutingPolicy.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy} message RoutingPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingPolicy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeLockDelta != null && Object.hasOwnProperty.call(message, "timeLockDelta"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeLockDelta);
            if (message.minHtlc != null && Object.hasOwnProperty.call(message, "minHtlc"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minHtlc);
            if (message.feeBaseMsat != null && Object.hasOwnProperty.call(message, "feeBaseMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.feeBaseMsat);
            if (message.feeRateMilliMsat != null && Object.hasOwnProperty.call(message, "feeRateMilliMsat"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.feeRateMilliMsat);
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.disabled);
            if (message.maxHtlcMsat != null && Object.hasOwnProperty.call(message, "maxHtlcMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxHtlcMsat);
            if (message.lastUpdate != null && Object.hasOwnProperty.call(message, "lastUpdate"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.lastUpdate);
            return writer;
        };

        /**
         * Encodes the specified RoutingPolicy message, length delimited. Does not implicitly {@link lnrpc.RoutingPolicy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy} message RoutingPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingPolicy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoutingPolicy message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingPolicy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RoutingPolicy();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timeLockDelta = reader.uint32();
                    break;
                case 2:
                    message.minHtlc = reader.int64();
                    break;
                case 3:
                    message.feeBaseMsat = reader.int64();
                    break;
                case 4:
                    message.feeRateMilliMsat = reader.int64();
                    break;
                case 5:
                    message.disabled = reader.bool();
                    break;
                case 6:
                    message.maxHtlcMsat = reader.uint64();
                    break;
                case 7:
                    message.lastUpdate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoutingPolicy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingPolicy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoutingPolicy message.
         * @function verify
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoutingPolicy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (!$util.isInteger(message.minHtlc) && !(message.minHtlc && $util.isInteger(message.minHtlc.low) && $util.isInteger(message.minHtlc.high)))
                    return "minHtlc: integer|Long expected";
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (!$util.isInteger(message.feeBaseMsat) && !(message.feeBaseMsat && $util.isInteger(message.feeBaseMsat.low) && $util.isInteger(message.feeBaseMsat.high)))
                    return "feeBaseMsat: integer|Long expected";
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                if (!$util.isInteger(message.feeRateMilliMsat) && !(message.feeRateMilliMsat && $util.isInteger(message.feeRateMilliMsat.low) && $util.isInteger(message.feeRateMilliMsat.high)))
                    return "feeRateMilliMsat: integer|Long expected";
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                if (!$util.isInteger(message.maxHtlcMsat) && !(message.maxHtlcMsat && $util.isInteger(message.maxHtlcMsat.low) && $util.isInteger(message.maxHtlcMsat.high)))
                    return "maxHtlcMsat: integer|Long expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            return null;
        };

        /**
         * Creates a RoutingPolicy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         */
        RoutingPolicy.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RoutingPolicy)
                return object;
            let message = new $root.lnrpc.RoutingPolicy();
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            if (object.minHtlc != null)
                if ($util.Long)
                    (message.minHtlc = $util.Long.fromValue(object.minHtlc)).unsigned = false;
                else if (typeof object.minHtlc === "string")
                    message.minHtlc = parseInt(object.minHtlc, 10);
                else if (typeof object.minHtlc === "number")
                    message.minHtlc = object.minHtlc;
                else if (typeof object.minHtlc === "object")
                    message.minHtlc = new $util.LongBits(object.minHtlc.low >>> 0, object.minHtlc.high >>> 0).toNumber();
            if (object.feeBaseMsat != null)
                if ($util.Long)
                    (message.feeBaseMsat = $util.Long.fromValue(object.feeBaseMsat)).unsigned = false;
                else if (typeof object.feeBaseMsat === "string")
                    message.feeBaseMsat = parseInt(object.feeBaseMsat, 10);
                else if (typeof object.feeBaseMsat === "number")
                    message.feeBaseMsat = object.feeBaseMsat;
                else if (typeof object.feeBaseMsat === "object")
                    message.feeBaseMsat = new $util.LongBits(object.feeBaseMsat.low >>> 0, object.feeBaseMsat.high >>> 0).toNumber();
            if (object.feeRateMilliMsat != null)
                if ($util.Long)
                    (message.feeRateMilliMsat = $util.Long.fromValue(object.feeRateMilliMsat)).unsigned = false;
                else if (typeof object.feeRateMilliMsat === "string")
                    message.feeRateMilliMsat = parseInt(object.feeRateMilliMsat, 10);
                else if (typeof object.feeRateMilliMsat === "number")
                    message.feeRateMilliMsat = object.feeRateMilliMsat;
                else if (typeof object.feeRateMilliMsat === "object")
                    message.feeRateMilliMsat = new $util.LongBits(object.feeRateMilliMsat.low >>> 0, object.feeRateMilliMsat.high >>> 0).toNumber();
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.maxHtlcMsat != null)
                if ($util.Long)
                    (message.maxHtlcMsat = $util.Long.fromValue(object.maxHtlcMsat)).unsigned = true;
                else if (typeof object.maxHtlcMsat === "string")
                    message.maxHtlcMsat = parseInt(object.maxHtlcMsat, 10);
                else if (typeof object.maxHtlcMsat === "number")
                    message.maxHtlcMsat = object.maxHtlcMsat;
                else if (typeof object.maxHtlcMsat === "object")
                    message.maxHtlcMsat = new $util.LongBits(object.maxHtlcMsat.low >>> 0, object.maxHtlcMsat.high >>> 0).toNumber(true);
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a RoutingPolicy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.RoutingPolicy} message RoutingPolicy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoutingPolicy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.timeLockDelta = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.minHtlc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeBaseMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeBaseMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeRateMilliMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeRateMilliMsat = options.longs === String ? "0" : 0;
                object.disabled = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxHtlcMsat = options.longs === String ? "0" : 0;
                object.lastUpdate = 0;
            }
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (typeof message.minHtlc === "number")
                    object.minHtlc = options.longs === String ? String(message.minHtlc) : message.minHtlc;
                else
                    object.minHtlc = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlc) : options.longs === Number ? new $util.LongBits(message.minHtlc.low >>> 0, message.minHtlc.high >>> 0).toNumber() : message.minHtlc;
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (typeof message.feeBaseMsat === "number")
                    object.feeBaseMsat = options.longs === String ? String(message.feeBaseMsat) : message.feeBaseMsat;
                else
                    object.feeBaseMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeBaseMsat) : options.longs === Number ? new $util.LongBits(message.feeBaseMsat.low >>> 0, message.feeBaseMsat.high >>> 0).toNumber() : message.feeBaseMsat;
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                if (typeof message.feeRateMilliMsat === "number")
                    object.feeRateMilliMsat = options.longs === String ? String(message.feeRateMilliMsat) : message.feeRateMilliMsat;
                else
                    object.feeRateMilliMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeRateMilliMsat) : options.longs === Number ? new $util.LongBits(message.feeRateMilliMsat.low >>> 0, message.feeRateMilliMsat.high >>> 0).toNumber() : message.feeRateMilliMsat;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                if (typeof message.maxHtlcMsat === "number")
                    object.maxHtlcMsat = options.longs === String ? String(message.maxHtlcMsat) : message.maxHtlcMsat;
                else
                    object.maxHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.maxHtlcMsat) : options.longs === Number ? new $util.LongBits(message.maxHtlcMsat.low >>> 0, message.maxHtlcMsat.high >>> 0).toNumber(true) : message.maxHtlcMsat;
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            return object;
        };

        /**
         * Converts this RoutingPolicy to JSON.
         * @function toJSON
         * @memberof lnrpc.RoutingPolicy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoutingPolicy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoutingPolicy;
    })();

    lnrpc.ChannelEdge = (function() {

        /**
         * Properties of a ChannelEdge.
         * @memberof lnrpc
         * @interface IChannelEdge
         * @property {number|Long|null} [channelId] ChannelEdge channelId
         * @property {string|null} [chanPoint] ChannelEdge chanPoint
         * @property {number|null} [lastUpdate] ChannelEdge lastUpdate
         * @property {string|null} [node1Pub] ChannelEdge node1Pub
         * @property {string|null} [node2Pub] ChannelEdge node2Pub
         * @property {number|Long|null} [capacity] ChannelEdge capacity
         * @property {lnrpc.IRoutingPolicy|null} [node1Policy] ChannelEdge node1Policy
         * @property {lnrpc.IRoutingPolicy|null} [node2Policy] ChannelEdge node2Policy
         */

        /**
         * Constructs a new ChannelEdge.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEdge.
         * @implements IChannelEdge
         * @constructor
         * @param {lnrpc.IChannelEdge=} [properties] Properties to set
         */
        function ChannelEdge(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelEdge channelId.
         * @member {number|Long} channelId
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelEdge chanPoint.
         * @member {string} chanPoint
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.chanPoint = "";

        /**
         * ChannelEdge lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.lastUpdate = 0;

        /**
         * ChannelEdge node1Pub.
         * @member {string} node1Pub
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node1Pub = "";

        /**
         * ChannelEdge node2Pub.
         * @member {string} node2Pub
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node2Pub = "";

        /**
         * ChannelEdge capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelEdge node1Policy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} node1Policy
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node1Policy = null;

        /**
         * ChannelEdge node2Policy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} node2Policy
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node2Policy = null;

        /**
         * Creates a new ChannelEdge instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge=} [properties] Properties to set
         * @returns {lnrpc.ChannelEdge} ChannelEdge instance
         */
        ChannelEdge.create = function create(properties) {
            return new ChannelEdge(properties);
        };

        /**
         * Encodes the specified ChannelEdge message. Does not implicitly {@link lnrpc.ChannelEdge.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge} message ChannelEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.chanPoint);
            if (message.lastUpdate != null && Object.hasOwnProperty.call(message, "lastUpdate"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.lastUpdate);
            if (message.node1Pub != null && Object.hasOwnProperty.call(message, "node1Pub"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.node1Pub);
            if (message.node2Pub != null && Object.hasOwnProperty.call(message, "node2Pub"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.node2Pub);
            if (message.capacity != null && Object.hasOwnProperty.call(message, "capacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.capacity);
            if (message.node1Policy != null && Object.hasOwnProperty.call(message, "node1Policy"))
                $root.lnrpc.RoutingPolicy.encode(message.node1Policy, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.node2Policy != null && Object.hasOwnProperty.call(message, "node2Policy"))
                $root.lnrpc.RoutingPolicy.encode(message.node2Policy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelEdge message, length delimited. Does not implicitly {@link lnrpc.ChannelEdge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge} message ChannelEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEdge message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEdge();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.chanPoint = reader.string();
                    break;
                case 3:
                    message.lastUpdate = reader.uint32();
                    break;
                case 4:
                    message.node1Pub = reader.string();
                    break;
                case 5:
                    message.node2Pub = reader.string();
                    break;
                case 6:
                    message.capacity = reader.int64();
                    break;
                case 7:
                    message.node1Policy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.node2Policy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEdge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEdge message.
         * @function verify
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEdge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                if (!$util.isString(message.chanPoint))
                    return "chanPoint: string expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                if (!$util.isString(message.node1Pub))
                    return "node1Pub: string expected";
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                if (!$util.isString(message.node2Pub))
                    return "node2Pub: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy")) {
                let error = $root.lnrpc.RoutingPolicy.verify(message.node1Policy);
                if (error)
                    return "node1Policy." + error;
            }
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy")) {
                let error = $root.lnrpc.RoutingPolicy.verify(message.node2Policy);
                if (error)
                    return "node2Policy." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelEdge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         */
        ChannelEdge.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEdge)
                return object;
            let message = new $root.lnrpc.ChannelEdge();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.chanPoint != null)
                message.chanPoint = String(object.chanPoint);
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            if (object.node1Pub != null)
                message.node1Pub = String(object.node1Pub);
            if (object.node2Pub != null)
                message.node2Pub = String(object.node2Pub);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.node1Policy != null) {
                if (typeof object.node1Policy !== "object")
                    throw TypeError(".lnrpc.ChannelEdge.node1Policy: object expected");
                message.node1Policy = $root.lnrpc.RoutingPolicy.fromObject(object.node1Policy);
            }
            if (object.node2Policy != null) {
                if (typeof object.node2Policy !== "object")
                    throw TypeError(".lnrpc.ChannelEdge.node2Policy: object expected");
                message.node2Policy = $root.lnrpc.RoutingPolicy.fromObject(object.node2Policy);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelEdge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.ChannelEdge} message ChannelEdge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEdge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.chanPoint = "";
                object.lastUpdate = 0;
                object.node1Pub = "";
                object.node2Pub = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.node1Policy = null;
                object.node2Policy = null;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = message.chanPoint;
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                object.node1Pub = message.node1Pub;
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                object.node2Pub = message.node2Pub;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy"))
                object.node1Policy = $root.lnrpc.RoutingPolicy.toObject(message.node1Policy, options);
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy"))
                object.node2Policy = $root.lnrpc.RoutingPolicy.toObject(message.node2Policy, options);
            return object;
        };

        /**
         * Converts this ChannelEdge to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEdge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEdge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEdge;
    })();

    lnrpc.ChannelGraphRequest = (function() {

        /**
         * Properties of a ChannelGraphRequest.
         * @memberof lnrpc
         * @interface IChannelGraphRequest
         * @property {boolean|null} [includeUnannounced] ChannelGraphRequest includeUnannounced
         */

        /**
         * Constructs a new ChannelGraphRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelGraphRequest.
         * @implements IChannelGraphRequest
         * @constructor
         * @param {lnrpc.IChannelGraphRequest=} [properties] Properties to set
         */
        function ChannelGraphRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelGraphRequest includeUnannounced.
         * @member {boolean} includeUnannounced
         * @memberof lnrpc.ChannelGraphRequest
         * @instance
         */
        ChannelGraphRequest.prototype.includeUnannounced = false;

        /**
         * Creates a new ChannelGraphRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest instance
         */
        ChannelGraphRequest.create = function create(properties) {
            return new ChannelGraphRequest(properties);
        };

        /**
         * Encodes the specified ChannelGraphRequest message. Does not implicitly {@link lnrpc.ChannelGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest} message ChannelGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.includeUnannounced != null && Object.hasOwnProperty.call(message, "includeUnannounced"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeUnannounced);
            return writer;
        };

        /**
         * Encodes the specified ChannelGraphRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest} message ChannelGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelGraphRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.includeUnannounced = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGraphRequest message.
         * @function verify
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.includeUnannounced != null && message.hasOwnProperty("includeUnannounced"))
                if (typeof message.includeUnannounced !== "boolean")
                    return "includeUnannounced: boolean expected";
            return null;
        };

        /**
         * Creates a ChannelGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         */
        ChannelGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelGraphRequest)
                return object;
            let message = new $root.lnrpc.ChannelGraphRequest();
            if (object.includeUnannounced != null)
                message.includeUnannounced = Boolean(object.includeUnannounced);
            return message;
        };

        /**
         * Creates a plain object from a ChannelGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.ChannelGraphRequest} message ChannelGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGraphRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.includeUnannounced = false;
            if (message.includeUnannounced != null && message.hasOwnProperty("includeUnannounced"))
                object.includeUnannounced = message.includeUnannounced;
            return object;
        };

        /**
         * Converts this ChannelGraphRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGraphRequest;
    })();

    lnrpc.ChannelGraph = (function() {

        /**
         * Properties of a ChannelGraph.
         * @memberof lnrpc
         * @interface IChannelGraph
         * @property {Array.<lnrpc.ILightningNode>|null} [nodes] ChannelGraph nodes
         * @property {Array.<lnrpc.IChannelEdge>|null} [edges] ChannelGraph edges
         */

        /**
         * Constructs a new ChannelGraph.
         * @memberof lnrpc
         * @classdesc Represents a ChannelGraph.
         * @implements IChannelGraph
         * @constructor
         * @param {lnrpc.IChannelGraph=} [properties] Properties to set
         */
        function ChannelGraph(properties) {
            this.nodes = [];
            this.edges = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelGraph nodes.
         * @member {Array.<lnrpc.ILightningNode>} nodes
         * @memberof lnrpc.ChannelGraph
         * @instance
         */
        ChannelGraph.prototype.nodes = $util.emptyArray;

        /**
         * ChannelGraph edges.
         * @member {Array.<lnrpc.IChannelEdge>} edges
         * @memberof lnrpc.ChannelGraph
         * @instance
         */
        ChannelGraph.prototype.edges = $util.emptyArray;

        /**
         * Creates a new ChannelGraph instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph=} [properties] Properties to set
         * @returns {lnrpc.ChannelGraph} ChannelGraph instance
         */
        ChannelGraph.create = function create(properties) {
            return new ChannelGraph(properties);
        };

        /**
         * Encodes the specified ChannelGraph message. Does not implicitly {@link lnrpc.ChannelGraph.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph} message ChannelGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    $root.lnrpc.LightningNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.edges != null && message.edges.length)
                for (let i = 0; i < message.edges.length; ++i)
                    $root.lnrpc.ChannelEdge.encode(message.edges[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelGraph message, length delimited. Does not implicitly {@link lnrpc.ChannelGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph} message ChannelGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGraph message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push($root.lnrpc.LightningNode.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.edges && message.edges.length))
                        message.edges = [];
                    message.edges.push($root.lnrpc.ChannelEdge.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGraph message.
         * @function verify
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (let i = 0; i < message.nodes.length; ++i) {
                    let error = $root.lnrpc.LightningNode.verify(message.nodes[i]);
                    if (error)
                        return "nodes." + error;
                }
            }
            if (message.edges != null && message.hasOwnProperty("edges")) {
                if (!Array.isArray(message.edges))
                    return "edges: array expected";
                for (let i = 0; i < message.edges.length; ++i) {
                    let error = $root.lnrpc.ChannelEdge.verify(message.edges[i]);
                    if (error)
                        return "edges." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChannelGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         */
        ChannelGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelGraph)
                return object;
            let message = new $root.lnrpc.ChannelGraph();
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".lnrpc.ChannelGraph.nodes: array expected");
                message.nodes = [];
                for (let i = 0; i < object.nodes.length; ++i) {
                    if (typeof object.nodes[i] !== "object")
                        throw TypeError(".lnrpc.ChannelGraph.nodes: object expected");
                    message.nodes[i] = $root.lnrpc.LightningNode.fromObject(object.nodes[i]);
                }
            }
            if (object.edges) {
                if (!Array.isArray(object.edges))
                    throw TypeError(".lnrpc.ChannelGraph.edges: array expected");
                message.edges = [];
                for (let i = 0; i < object.edges.length; ++i) {
                    if (typeof object.edges[i] !== "object")
                        throw TypeError(".lnrpc.ChannelGraph.edges: object expected");
                    message.edges[i] = $root.lnrpc.ChannelEdge.fromObject(object.edges[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.ChannelGraph} message ChannelGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.nodes = [];
                object.edges = [];
            }
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (let j = 0; j < message.nodes.length; ++j)
                    object.nodes[j] = $root.lnrpc.LightningNode.toObject(message.nodes[j], options);
            }
            if (message.edges && message.edges.length) {
                object.edges = [];
                for (let j = 0; j < message.edges.length; ++j)
                    object.edges[j] = $root.lnrpc.ChannelEdge.toObject(message.edges[j], options);
            }
            return object;
        };

        /**
         * Converts this ChannelGraph to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGraph;
    })();

    /**
     * NodeMetricType enum.
     * @name lnrpc.NodeMetricType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} BETWEENNESS_CENTRALITY=1 BETWEENNESS_CENTRALITY value
     */
    lnrpc.NodeMetricType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "BETWEENNESS_CENTRALITY"] = 1;
        return values;
    })();

    lnrpc.NodeMetricsRequest = (function() {

        /**
         * Properties of a NodeMetricsRequest.
         * @memberof lnrpc
         * @interface INodeMetricsRequest
         * @property {Array.<lnrpc.NodeMetricType>|null} [types] NodeMetricsRequest types
         */

        /**
         * Constructs a new NodeMetricsRequest.
         * @memberof lnrpc
         * @classdesc Represents a NodeMetricsRequest.
         * @implements INodeMetricsRequest
         * @constructor
         * @param {lnrpc.INodeMetricsRequest=} [properties] Properties to set
         */
        function NodeMetricsRequest(properties) {
            this.types = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeMetricsRequest types.
         * @member {Array.<lnrpc.NodeMetricType>} types
         * @memberof lnrpc.NodeMetricsRequest
         * @instance
         */
        NodeMetricsRequest.prototype.types = $util.emptyArray;

        /**
         * Creates a new NodeMetricsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {lnrpc.INodeMetricsRequest=} [properties] Properties to set
         * @returns {lnrpc.NodeMetricsRequest} NodeMetricsRequest instance
         */
        NodeMetricsRequest.create = function create(properties) {
            return new NodeMetricsRequest(properties);
        };

        /**
         * Encodes the specified NodeMetricsRequest message. Does not implicitly {@link lnrpc.NodeMetricsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {lnrpc.INodeMetricsRequest} message NodeMetricsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeMetricsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.types != null && message.types.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.types.length; ++i)
                    writer.int32(message.types[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified NodeMetricsRequest message, length delimited. Does not implicitly {@link lnrpc.NodeMetricsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {lnrpc.INodeMetricsRequest} message NodeMetricsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeMetricsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeMetricsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeMetricsRequest} NodeMetricsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeMetricsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeMetricsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.types && message.types.length))
                        message.types = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.types.push(reader.int32());
                    } else
                        message.types.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeMetricsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeMetricsRequest} NodeMetricsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeMetricsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeMetricsRequest message.
         * @function verify
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeMetricsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.types != null && message.hasOwnProperty("types")) {
                if (!Array.isArray(message.types))
                    return "types: array expected";
                for (let i = 0; i < message.types.length; ++i)
                    switch (message.types[i]) {
                    default:
                        return "types: enum value[] expected";
                    case 0:
                    case 1:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a NodeMetricsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeMetricsRequest} NodeMetricsRequest
         */
        NodeMetricsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeMetricsRequest)
                return object;
            let message = new $root.lnrpc.NodeMetricsRequest();
            if (object.types) {
                if (!Array.isArray(object.types))
                    throw TypeError(".lnrpc.NodeMetricsRequest.types: array expected");
                message.types = [];
                for (let i = 0; i < object.types.length; ++i)
                    switch (object.types[i]) {
                    default:
                    case "UNKNOWN":
                    case 0:
                        message.types[i] = 0;
                        break;
                    case "BETWEENNESS_CENTRALITY":
                    case 1:
                        message.types[i] = 1;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeMetricsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeMetricsRequest
         * @static
         * @param {lnrpc.NodeMetricsRequest} message NodeMetricsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeMetricsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.types = [];
            if (message.types && message.types.length) {
                object.types = [];
                for (let j = 0; j < message.types.length; ++j)
                    object.types[j] = options.enums === String ? $root.lnrpc.NodeMetricType[message.types[j]] : message.types[j];
            }
            return object;
        };

        /**
         * Converts this NodeMetricsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeMetricsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeMetricsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeMetricsRequest;
    })();

    lnrpc.NodeMetricsResponse = (function() {

        /**
         * Properties of a NodeMetricsResponse.
         * @memberof lnrpc
         * @interface INodeMetricsResponse
         * @property {Object.<string,lnrpc.IFloatMetric>|null} [betweennessCentrality] NodeMetricsResponse betweennessCentrality
         */

        /**
         * Constructs a new NodeMetricsResponse.
         * @memberof lnrpc
         * @classdesc Represents a NodeMetricsResponse.
         * @implements INodeMetricsResponse
         * @constructor
         * @param {lnrpc.INodeMetricsResponse=} [properties] Properties to set
         */
        function NodeMetricsResponse(properties) {
            this.betweennessCentrality = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeMetricsResponse betweennessCentrality.
         * @member {Object.<string,lnrpc.IFloatMetric>} betweennessCentrality
         * @memberof lnrpc.NodeMetricsResponse
         * @instance
         */
        NodeMetricsResponse.prototype.betweennessCentrality = $util.emptyObject;

        /**
         * Creates a new NodeMetricsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {lnrpc.INodeMetricsResponse=} [properties] Properties to set
         * @returns {lnrpc.NodeMetricsResponse} NodeMetricsResponse instance
         */
        NodeMetricsResponse.create = function create(properties) {
            return new NodeMetricsResponse(properties);
        };

        /**
         * Encodes the specified NodeMetricsResponse message. Does not implicitly {@link lnrpc.NodeMetricsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {lnrpc.INodeMetricsResponse} message NodeMetricsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeMetricsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.betweennessCentrality != null && Object.hasOwnProperty.call(message, "betweennessCentrality"))
                for (let keys = Object.keys(message.betweennessCentrality), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.lnrpc.FloatMetric.encode(message.betweennessCentrality[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified NodeMetricsResponse message, length delimited. Does not implicitly {@link lnrpc.NodeMetricsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {lnrpc.INodeMetricsResponse} message NodeMetricsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeMetricsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeMetricsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeMetricsResponse} NodeMetricsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeMetricsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeMetricsResponse(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.betweennessCentrality === $util.emptyObject)
                        message.betweennessCentrality = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.lnrpc.FloatMetric.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.betweennessCentrality[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeMetricsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeMetricsResponse} NodeMetricsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeMetricsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeMetricsResponse message.
         * @function verify
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeMetricsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.betweennessCentrality != null && message.hasOwnProperty("betweennessCentrality")) {
                if (!$util.isObject(message.betweennessCentrality))
                    return "betweennessCentrality: object expected";
                let key = Object.keys(message.betweennessCentrality);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.lnrpc.FloatMetric.verify(message.betweennessCentrality[key[i]]);
                    if (error)
                        return "betweennessCentrality." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeMetricsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeMetricsResponse} NodeMetricsResponse
         */
        NodeMetricsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeMetricsResponse)
                return object;
            let message = new $root.lnrpc.NodeMetricsResponse();
            if (object.betweennessCentrality) {
                if (typeof object.betweennessCentrality !== "object")
                    throw TypeError(".lnrpc.NodeMetricsResponse.betweennessCentrality: object expected");
                message.betweennessCentrality = {};
                for (let keys = Object.keys(object.betweennessCentrality), i = 0; i < keys.length; ++i) {
                    if (typeof object.betweennessCentrality[keys[i]] !== "object")
                        throw TypeError(".lnrpc.NodeMetricsResponse.betweennessCentrality: object expected");
                    message.betweennessCentrality[keys[i]] = $root.lnrpc.FloatMetric.fromObject(object.betweennessCentrality[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeMetricsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeMetricsResponse
         * @static
         * @param {lnrpc.NodeMetricsResponse} message NodeMetricsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeMetricsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.betweennessCentrality = {};
            let keys2;
            if (message.betweennessCentrality && (keys2 = Object.keys(message.betweennessCentrality)).length) {
                object.betweennessCentrality = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.betweennessCentrality[keys2[j]] = $root.lnrpc.FloatMetric.toObject(message.betweennessCentrality[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this NodeMetricsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeMetricsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeMetricsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeMetricsResponse;
    })();

    lnrpc.FloatMetric = (function() {

        /**
         * Properties of a FloatMetric.
         * @memberof lnrpc
         * @interface IFloatMetric
         * @property {number|null} [value] FloatMetric value
         * @property {number|null} [normalizedValue] FloatMetric normalizedValue
         */

        /**
         * Constructs a new FloatMetric.
         * @memberof lnrpc
         * @classdesc Represents a FloatMetric.
         * @implements IFloatMetric
         * @constructor
         * @param {lnrpc.IFloatMetric=} [properties] Properties to set
         */
        function FloatMetric(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatMetric value.
         * @member {number} value
         * @memberof lnrpc.FloatMetric
         * @instance
         */
        FloatMetric.prototype.value = 0;

        /**
         * FloatMetric normalizedValue.
         * @member {number} normalizedValue
         * @memberof lnrpc.FloatMetric
         * @instance
         */
        FloatMetric.prototype.normalizedValue = 0;

        /**
         * Creates a new FloatMetric instance using the specified properties.
         * @function create
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {lnrpc.IFloatMetric=} [properties] Properties to set
         * @returns {lnrpc.FloatMetric} FloatMetric instance
         */
        FloatMetric.create = function create(properties) {
            return new FloatMetric(properties);
        };

        /**
         * Encodes the specified FloatMetric message. Does not implicitly {@link lnrpc.FloatMetric.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {lnrpc.IFloatMetric} message FloatMetric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatMetric.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
            if (message.normalizedValue != null && Object.hasOwnProperty.call(message, "normalizedValue"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.normalizedValue);
            return writer;
        };

        /**
         * Encodes the specified FloatMetric message, length delimited. Does not implicitly {@link lnrpc.FloatMetric.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {lnrpc.IFloatMetric} message FloatMetric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatMetric.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FloatMetric message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FloatMetric} FloatMetric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatMetric.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FloatMetric();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.double();
                    break;
                case 2:
                    message.normalizedValue = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FloatMetric message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FloatMetric} FloatMetric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatMetric.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FloatMetric message.
         * @function verify
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FloatMetric.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            if (message.normalizedValue != null && message.hasOwnProperty("normalizedValue"))
                if (typeof message.normalizedValue !== "number")
                    return "normalizedValue: number expected";
            return null;
        };

        /**
         * Creates a FloatMetric message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FloatMetric} FloatMetric
         */
        FloatMetric.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FloatMetric)
                return object;
            let message = new $root.lnrpc.FloatMetric();
            if (object.value != null)
                message.value = Number(object.value);
            if (object.normalizedValue != null)
                message.normalizedValue = Number(object.normalizedValue);
            return message;
        };

        /**
         * Creates a plain object from a FloatMetric message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FloatMetric
         * @static
         * @param {lnrpc.FloatMetric} message FloatMetric
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FloatMetric.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.value = 0;
                object.normalizedValue = 0;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.normalizedValue != null && message.hasOwnProperty("normalizedValue"))
                object.normalizedValue = options.json && !isFinite(message.normalizedValue) ? String(message.normalizedValue) : message.normalizedValue;
            return object;
        };

        /**
         * Converts this FloatMetric to JSON.
         * @function toJSON
         * @memberof lnrpc.FloatMetric
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FloatMetric.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FloatMetric;
    })();

    lnrpc.ChanInfoRequest = (function() {

        /**
         * Properties of a ChanInfoRequest.
         * @memberof lnrpc
         * @interface IChanInfoRequest
         * @property {number|Long|null} [chanId] ChanInfoRequest chanId
         */

        /**
         * Constructs a new ChanInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChanInfoRequest.
         * @implements IChanInfoRequest
         * @constructor
         * @param {lnrpc.IChanInfoRequest=} [properties] Properties to set
         */
        function ChanInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChanInfoRequest chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChanInfoRequest
         * @instance
         */
        ChanInfoRequest.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChanInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest instance
         */
        ChanInfoRequest.create = function create(properties) {
            return new ChanInfoRequest(properties);
        };

        /**
         * Encodes the specified ChanInfoRequest message. Does not implicitly {@link lnrpc.ChanInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest} message ChanInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            return writer;
        };

        /**
         * Encodes the specified ChanInfoRequest message, length delimited. Does not implicitly {@link lnrpc.ChanInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest} message ChanInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanInfoRequest message.
         * @function verify
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChanInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         */
        ChanInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanInfoRequest)
                return object;
            let message = new $root.lnrpc.ChanInfoRequest();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChanInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.ChanInfoRequest} message ChanInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            return object;
        };

        /**
         * Converts this ChanInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanInfoRequest;
    })();

    lnrpc.NetworkInfoRequest = (function() {

        /**
         * Properties of a NetworkInfoRequest.
         * @memberof lnrpc
         * @interface INetworkInfoRequest
         */

        /**
         * Constructs a new NetworkInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a NetworkInfoRequest.
         * @implements INetworkInfoRequest
         * @constructor
         * @param {lnrpc.INetworkInfoRequest=} [properties] Properties to set
         */
        function NetworkInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NetworkInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest instance
         */
        NetworkInfoRequest.create = function create(properties) {
            return new NetworkInfoRequest(properties);
        };

        /**
         * Encodes the specified NetworkInfoRequest message. Does not implicitly {@link lnrpc.NetworkInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest} message NetworkInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NetworkInfoRequest message, length delimited. Does not implicitly {@link lnrpc.NetworkInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest} message NetworkInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NetworkInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfoRequest message.
         * @function verify
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a NetworkInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         */
        NetworkInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NetworkInfoRequest)
                return object;
            return new $root.lnrpc.NetworkInfoRequest();
        };

        /**
         * Creates a plain object from a NetworkInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.NetworkInfoRequest} message NetworkInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NetworkInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NetworkInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkInfoRequest;
    })();

    lnrpc.NetworkInfo = (function() {

        /**
         * Properties of a NetworkInfo.
         * @memberof lnrpc
         * @interface INetworkInfo
         * @property {number|null} [graphDiameter] NetworkInfo graphDiameter
         * @property {number|null} [avgOutDegree] NetworkInfo avgOutDegree
         * @property {number|null} [maxOutDegree] NetworkInfo maxOutDegree
         * @property {number|null} [numNodes] NetworkInfo numNodes
         * @property {number|null} [numChannels] NetworkInfo numChannels
         * @property {number|Long|null} [totalNetworkCapacity] NetworkInfo totalNetworkCapacity
         * @property {number|null} [avgChannelSize] NetworkInfo avgChannelSize
         * @property {number|Long|null} [minChannelSize] NetworkInfo minChannelSize
         * @property {number|Long|null} [maxChannelSize] NetworkInfo maxChannelSize
         * @property {number|Long|null} [medianChannelSizeSat] NetworkInfo medianChannelSizeSat
         * @property {number|Long|null} [numZombieChans] NetworkInfo numZombieChans
         */

        /**
         * Constructs a new NetworkInfo.
         * @memberof lnrpc
         * @classdesc Represents a NetworkInfo.
         * @implements INetworkInfo
         * @constructor
         * @param {lnrpc.INetworkInfo=} [properties] Properties to set
         */
        function NetworkInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkInfo graphDiameter.
         * @member {number} graphDiameter
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.graphDiameter = 0;

        /**
         * NetworkInfo avgOutDegree.
         * @member {number} avgOutDegree
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.avgOutDegree = 0;

        /**
         * NetworkInfo maxOutDegree.
         * @member {number} maxOutDegree
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.maxOutDegree = 0;

        /**
         * NetworkInfo numNodes.
         * @member {number} numNodes
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numNodes = 0;

        /**
         * NetworkInfo numChannels.
         * @member {number} numChannels
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numChannels = 0;

        /**
         * NetworkInfo totalNetworkCapacity.
         * @member {number|Long} totalNetworkCapacity
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.totalNetworkCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo avgChannelSize.
         * @member {number} avgChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.avgChannelSize = 0;

        /**
         * NetworkInfo minChannelSize.
         * @member {number|Long} minChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.minChannelSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo maxChannelSize.
         * @member {number|Long} maxChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.maxChannelSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo medianChannelSizeSat.
         * @member {number|Long} medianChannelSizeSat
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.medianChannelSizeSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo numZombieChans.
         * @member {number|Long} numZombieChans
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numZombieChans = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new NetworkInfo instance using the specified properties.
         * @function create
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo=} [properties] Properties to set
         * @returns {lnrpc.NetworkInfo} NetworkInfo instance
         */
        NetworkInfo.create = function create(properties) {
            return new NetworkInfo(properties);
        };

        /**
         * Encodes the specified NetworkInfo message. Does not implicitly {@link lnrpc.NetworkInfo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.graphDiameter != null && Object.hasOwnProperty.call(message, "graphDiameter"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.graphDiameter);
            if (message.avgOutDegree != null && Object.hasOwnProperty.call(message, "avgOutDegree"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.avgOutDegree);
            if (message.maxOutDegree != null && Object.hasOwnProperty.call(message, "maxOutDegree"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxOutDegree);
            if (message.numNodes != null && Object.hasOwnProperty.call(message, "numNodes"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numNodes);
            if (message.numChannels != null && Object.hasOwnProperty.call(message, "numChannels"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numChannels);
            if (message.totalNetworkCapacity != null && Object.hasOwnProperty.call(message, "totalNetworkCapacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalNetworkCapacity);
            if (message.avgChannelSize != null && Object.hasOwnProperty.call(message, "avgChannelSize"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.avgChannelSize);
            if (message.minChannelSize != null && Object.hasOwnProperty.call(message, "minChannelSize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.minChannelSize);
            if (message.maxChannelSize != null && Object.hasOwnProperty.call(message, "maxChannelSize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.maxChannelSize);
            if (message.medianChannelSizeSat != null && Object.hasOwnProperty.call(message, "medianChannelSizeSat"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.medianChannelSizeSat);
            if (message.numZombieChans != null && Object.hasOwnProperty.call(message, "numZombieChans"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.numZombieChans);
            return writer;
        };

        /**
         * Encodes the specified NetworkInfo message, length delimited. Does not implicitly {@link lnrpc.NetworkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NetworkInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.graphDiameter = reader.uint32();
                    break;
                case 2:
                    message.avgOutDegree = reader.double();
                    break;
                case 3:
                    message.maxOutDegree = reader.uint32();
                    break;
                case 4:
                    message.numNodes = reader.uint32();
                    break;
                case 5:
                    message.numChannels = reader.uint32();
                    break;
                case 6:
                    message.totalNetworkCapacity = reader.int64();
                    break;
                case 7:
                    message.avgChannelSize = reader.double();
                    break;
                case 8:
                    message.minChannelSize = reader.int64();
                    break;
                case 9:
                    message.maxChannelSize = reader.int64();
                    break;
                case 10:
                    message.medianChannelSizeSat = reader.int64();
                    break;
                case 11:
                    message.numZombieChans = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfo message.
         * @function verify
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                if (!$util.isInteger(message.graphDiameter))
                    return "graphDiameter: integer expected";
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                if (typeof message.avgOutDegree !== "number")
                    return "avgOutDegree: number expected";
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                if (!$util.isInteger(message.maxOutDegree))
                    return "maxOutDegree: integer expected";
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                if (!$util.isInteger(message.numNodes))
                    return "numNodes: integer expected";
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                if (!$util.isInteger(message.totalNetworkCapacity) && !(message.totalNetworkCapacity && $util.isInteger(message.totalNetworkCapacity.low) && $util.isInteger(message.totalNetworkCapacity.high)))
                    return "totalNetworkCapacity: integer|Long expected";
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                if (typeof message.avgChannelSize !== "number")
                    return "avgChannelSize: number expected";
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                if (!$util.isInteger(message.minChannelSize) && !(message.minChannelSize && $util.isInteger(message.minChannelSize.low) && $util.isInteger(message.minChannelSize.high)))
                    return "minChannelSize: integer|Long expected";
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                if (!$util.isInteger(message.maxChannelSize) && !(message.maxChannelSize && $util.isInteger(message.maxChannelSize.low) && $util.isInteger(message.maxChannelSize.high)))
                    return "maxChannelSize: integer|Long expected";
            if (message.medianChannelSizeSat != null && message.hasOwnProperty("medianChannelSizeSat"))
                if (!$util.isInteger(message.medianChannelSizeSat) && !(message.medianChannelSizeSat && $util.isInteger(message.medianChannelSizeSat.low) && $util.isInteger(message.medianChannelSizeSat.high)))
                    return "medianChannelSizeSat: integer|Long expected";
            if (message.numZombieChans != null && message.hasOwnProperty("numZombieChans"))
                if (!$util.isInteger(message.numZombieChans) && !(message.numZombieChans && $util.isInteger(message.numZombieChans.low) && $util.isInteger(message.numZombieChans.high)))
                    return "numZombieChans: integer|Long expected";
            return null;
        };

        /**
         * Creates a NetworkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         */
        NetworkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NetworkInfo)
                return object;
            let message = new $root.lnrpc.NetworkInfo();
            if (object.graphDiameter != null)
                message.graphDiameter = object.graphDiameter >>> 0;
            if (object.avgOutDegree != null)
                message.avgOutDegree = Number(object.avgOutDegree);
            if (object.maxOutDegree != null)
                message.maxOutDegree = object.maxOutDegree >>> 0;
            if (object.numNodes != null)
                message.numNodes = object.numNodes >>> 0;
            if (object.numChannels != null)
                message.numChannels = object.numChannels >>> 0;
            if (object.totalNetworkCapacity != null)
                if ($util.Long)
                    (message.totalNetworkCapacity = $util.Long.fromValue(object.totalNetworkCapacity)).unsigned = false;
                else if (typeof object.totalNetworkCapacity === "string")
                    message.totalNetworkCapacity = parseInt(object.totalNetworkCapacity, 10);
                else if (typeof object.totalNetworkCapacity === "number")
                    message.totalNetworkCapacity = object.totalNetworkCapacity;
                else if (typeof object.totalNetworkCapacity === "object")
                    message.totalNetworkCapacity = new $util.LongBits(object.totalNetworkCapacity.low >>> 0, object.totalNetworkCapacity.high >>> 0).toNumber();
            if (object.avgChannelSize != null)
                message.avgChannelSize = Number(object.avgChannelSize);
            if (object.minChannelSize != null)
                if ($util.Long)
                    (message.minChannelSize = $util.Long.fromValue(object.minChannelSize)).unsigned = false;
                else if (typeof object.minChannelSize === "string")
                    message.minChannelSize = parseInt(object.minChannelSize, 10);
                else if (typeof object.minChannelSize === "number")
                    message.minChannelSize = object.minChannelSize;
                else if (typeof object.minChannelSize === "object")
                    message.minChannelSize = new $util.LongBits(object.minChannelSize.low >>> 0, object.minChannelSize.high >>> 0).toNumber();
            if (object.maxChannelSize != null)
                if ($util.Long)
                    (message.maxChannelSize = $util.Long.fromValue(object.maxChannelSize)).unsigned = false;
                else if (typeof object.maxChannelSize === "string")
                    message.maxChannelSize = parseInt(object.maxChannelSize, 10);
                else if (typeof object.maxChannelSize === "number")
                    message.maxChannelSize = object.maxChannelSize;
                else if (typeof object.maxChannelSize === "object")
                    message.maxChannelSize = new $util.LongBits(object.maxChannelSize.low >>> 0, object.maxChannelSize.high >>> 0).toNumber();
            if (object.medianChannelSizeSat != null)
                if ($util.Long)
                    (message.medianChannelSizeSat = $util.Long.fromValue(object.medianChannelSizeSat)).unsigned = false;
                else if (typeof object.medianChannelSizeSat === "string")
                    message.medianChannelSizeSat = parseInt(object.medianChannelSizeSat, 10);
                else if (typeof object.medianChannelSizeSat === "number")
                    message.medianChannelSizeSat = object.medianChannelSizeSat;
                else if (typeof object.medianChannelSizeSat === "object")
                    message.medianChannelSizeSat = new $util.LongBits(object.medianChannelSizeSat.low >>> 0, object.medianChannelSizeSat.high >>> 0).toNumber();
            if (object.numZombieChans != null)
                if ($util.Long)
                    (message.numZombieChans = $util.Long.fromValue(object.numZombieChans)).unsigned = true;
                else if (typeof object.numZombieChans === "string")
                    message.numZombieChans = parseInt(object.numZombieChans, 10);
                else if (typeof object.numZombieChans === "number")
                    message.numZombieChans = object.numZombieChans;
                else if (typeof object.numZombieChans === "object")
                    message.numZombieChans = new $util.LongBits(object.numZombieChans.low >>> 0, object.numZombieChans.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a NetworkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.NetworkInfo} message NetworkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.graphDiameter = 0;
                object.avgOutDegree = 0;
                object.maxOutDegree = 0;
                object.numNodes = 0;
                object.numChannels = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalNetworkCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalNetworkCapacity = options.longs === String ? "0" : 0;
                object.avgChannelSize = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.minChannelSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minChannelSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.maxChannelSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxChannelSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.medianChannelSizeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.medianChannelSizeSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.numZombieChans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numZombieChans = options.longs === String ? "0" : 0;
            }
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                object.graphDiameter = message.graphDiameter;
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                object.avgOutDegree = options.json && !isFinite(message.avgOutDegree) ? String(message.avgOutDegree) : message.avgOutDegree;
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                object.maxOutDegree = message.maxOutDegree;
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                object.numNodes = message.numNodes;
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                if (typeof message.totalNetworkCapacity === "number")
                    object.totalNetworkCapacity = options.longs === String ? String(message.totalNetworkCapacity) : message.totalNetworkCapacity;
                else
                    object.totalNetworkCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.totalNetworkCapacity) : options.longs === Number ? new $util.LongBits(message.totalNetworkCapacity.low >>> 0, message.totalNetworkCapacity.high >>> 0).toNumber() : message.totalNetworkCapacity;
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                object.avgChannelSize = options.json && !isFinite(message.avgChannelSize) ? String(message.avgChannelSize) : message.avgChannelSize;
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                if (typeof message.minChannelSize === "number")
                    object.minChannelSize = options.longs === String ? String(message.minChannelSize) : message.minChannelSize;
                else
                    object.minChannelSize = options.longs === String ? $util.Long.prototype.toString.call(message.minChannelSize) : options.longs === Number ? new $util.LongBits(message.minChannelSize.low >>> 0, message.minChannelSize.high >>> 0).toNumber() : message.minChannelSize;
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                if (typeof message.maxChannelSize === "number")
                    object.maxChannelSize = options.longs === String ? String(message.maxChannelSize) : message.maxChannelSize;
                else
                    object.maxChannelSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxChannelSize) : options.longs === Number ? new $util.LongBits(message.maxChannelSize.low >>> 0, message.maxChannelSize.high >>> 0).toNumber() : message.maxChannelSize;
            if (message.medianChannelSizeSat != null && message.hasOwnProperty("medianChannelSizeSat"))
                if (typeof message.medianChannelSizeSat === "number")
                    object.medianChannelSizeSat = options.longs === String ? String(message.medianChannelSizeSat) : message.medianChannelSizeSat;
                else
                    object.medianChannelSizeSat = options.longs === String ? $util.Long.prototype.toString.call(message.medianChannelSizeSat) : options.longs === Number ? new $util.LongBits(message.medianChannelSizeSat.low >>> 0, message.medianChannelSizeSat.high >>> 0).toNumber() : message.medianChannelSizeSat;
            if (message.numZombieChans != null && message.hasOwnProperty("numZombieChans"))
                if (typeof message.numZombieChans === "number")
                    object.numZombieChans = options.longs === String ? String(message.numZombieChans) : message.numZombieChans;
                else
                    object.numZombieChans = options.longs === String ? $util.Long.prototype.toString.call(message.numZombieChans) : options.longs === Number ? new $util.LongBits(message.numZombieChans.low >>> 0, message.numZombieChans.high >>> 0).toNumber(true) : message.numZombieChans;
            return object;
        };

        /**
         * Converts this NetworkInfo to JSON.
         * @function toJSON
         * @memberof lnrpc.NetworkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkInfo;
    })();

    lnrpc.StopRequest = (function() {

        /**
         * Properties of a StopRequest.
         * @memberof lnrpc
         * @interface IStopRequest
         */

        /**
         * Constructs a new StopRequest.
         * @memberof lnrpc
         * @classdesc Represents a StopRequest.
         * @implements IStopRequest
         * @constructor
         * @param {lnrpc.IStopRequest=} [properties] Properties to set
         */
        function StopRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest=} [properties] Properties to set
         * @returns {lnrpc.StopRequest} StopRequest instance
         */
        StopRequest.create = function create(properties) {
            return new StopRequest(properties);
        };

        /**
         * Encodes the specified StopRequest message. Does not implicitly {@link lnrpc.StopRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest} message StopRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopRequest message, length delimited. Does not implicitly {@link lnrpc.StopRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest} message StopRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StopRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StopRequest} StopRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StopRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StopRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StopRequest} StopRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRequest message.
         * @function verify
         * @memberof lnrpc.StopRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StopRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StopRequest} StopRequest
         */
        StopRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StopRequest)
                return object;
            return new $root.lnrpc.StopRequest();
        };

        /**
         * Creates a plain object from a StopRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.StopRequest} message StopRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.StopRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRequest;
    })();

    lnrpc.StopResponse = (function() {

        /**
         * Properties of a StopResponse.
         * @memberof lnrpc
         * @interface IStopResponse
         */

        /**
         * Constructs a new StopResponse.
         * @memberof lnrpc
         * @classdesc Represents a StopResponse.
         * @implements IStopResponse
         * @constructor
         * @param {lnrpc.IStopResponse=} [properties] Properties to set
         */
        function StopResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse=} [properties] Properties to set
         * @returns {lnrpc.StopResponse} StopResponse instance
         */
        StopResponse.create = function create(properties) {
            return new StopResponse(properties);
        };

        /**
         * Encodes the specified StopResponse message. Does not implicitly {@link lnrpc.StopResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse} message StopResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopResponse message, length delimited. Does not implicitly {@link lnrpc.StopResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse} message StopResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StopResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StopResponse} StopResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StopResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StopResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StopResponse} StopResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopResponse message.
         * @function verify
         * @memberof lnrpc.StopResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StopResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StopResponse} StopResponse
         */
        StopResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StopResponse)
                return object;
            return new $root.lnrpc.StopResponse();
        };

        /**
         * Creates a plain object from a StopResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.StopResponse} message StopResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.StopResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopResponse;
    })();

    lnrpc.GraphTopologySubscription = (function() {

        /**
         * Properties of a GraphTopologySubscription.
         * @memberof lnrpc
         * @interface IGraphTopologySubscription
         */

        /**
         * Constructs a new GraphTopologySubscription.
         * @memberof lnrpc
         * @classdesc Represents a GraphTopologySubscription.
         * @implements IGraphTopologySubscription
         * @constructor
         * @param {lnrpc.IGraphTopologySubscription=} [properties] Properties to set
         */
        function GraphTopologySubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GraphTopologySubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription=} [properties] Properties to set
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription instance
         */
        GraphTopologySubscription.create = function create(properties) {
            return new GraphTopologySubscription(properties);
        };

        /**
         * Encodes the specified GraphTopologySubscription message. Does not implicitly {@link lnrpc.GraphTopologySubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription} message GraphTopologySubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologySubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GraphTopologySubscription message, length delimited. Does not implicitly {@link lnrpc.GraphTopologySubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription} message GraphTopologySubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologySubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphTopologySubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologySubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GraphTopologySubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphTopologySubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologySubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphTopologySubscription message.
         * @function verify
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphTopologySubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GraphTopologySubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         */
        GraphTopologySubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GraphTopologySubscription)
                return object;
            return new $root.lnrpc.GraphTopologySubscription();
        };

        /**
         * Creates a plain object from a GraphTopologySubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.GraphTopologySubscription} message GraphTopologySubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphTopologySubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GraphTopologySubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.GraphTopologySubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphTopologySubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphTopologySubscription;
    })();

    lnrpc.GraphTopologyUpdate = (function() {

        /**
         * Properties of a GraphTopologyUpdate.
         * @memberof lnrpc
         * @interface IGraphTopologyUpdate
         * @property {Array.<lnrpc.INodeUpdate>|null} [nodeUpdates] GraphTopologyUpdate nodeUpdates
         * @property {Array.<lnrpc.IChannelEdgeUpdate>|null} [channelUpdates] GraphTopologyUpdate channelUpdates
         * @property {Array.<lnrpc.IClosedChannelUpdate>|null} [closedChans] GraphTopologyUpdate closedChans
         */

        /**
         * Constructs a new GraphTopologyUpdate.
         * @memberof lnrpc
         * @classdesc Represents a GraphTopologyUpdate.
         * @implements IGraphTopologyUpdate
         * @constructor
         * @param {lnrpc.IGraphTopologyUpdate=} [properties] Properties to set
         */
        function GraphTopologyUpdate(properties) {
            this.nodeUpdates = [];
            this.channelUpdates = [];
            this.closedChans = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphTopologyUpdate nodeUpdates.
         * @member {Array.<lnrpc.INodeUpdate>} nodeUpdates
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.nodeUpdates = $util.emptyArray;

        /**
         * GraphTopologyUpdate channelUpdates.
         * @member {Array.<lnrpc.IChannelEdgeUpdate>} channelUpdates
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.channelUpdates = $util.emptyArray;

        /**
         * GraphTopologyUpdate closedChans.
         * @member {Array.<lnrpc.IClosedChannelUpdate>} closedChans
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.closedChans = $util.emptyArray;

        /**
         * Creates a new GraphTopologyUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate=} [properties] Properties to set
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate instance
         */
        GraphTopologyUpdate.create = function create(properties) {
            return new GraphTopologyUpdate(properties);
        };

        /**
         * Encodes the specified GraphTopologyUpdate message. Does not implicitly {@link lnrpc.GraphTopologyUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate} message GraphTopologyUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologyUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeUpdates != null && message.nodeUpdates.length)
                for (let i = 0; i < message.nodeUpdates.length; ++i)
                    $root.lnrpc.NodeUpdate.encode(message.nodeUpdates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelUpdates != null && message.channelUpdates.length)
                for (let i = 0; i < message.channelUpdates.length; ++i)
                    $root.lnrpc.ChannelEdgeUpdate.encode(message.channelUpdates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.closedChans != null && message.closedChans.length)
                for (let i = 0; i < message.closedChans.length; ++i)
                    $root.lnrpc.ClosedChannelUpdate.encode(message.closedChans[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphTopologyUpdate message, length delimited. Does not implicitly {@link lnrpc.GraphTopologyUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate} message GraphTopologyUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologyUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphTopologyUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologyUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GraphTopologyUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodeUpdates && message.nodeUpdates.length))
                        message.nodeUpdates = [];
                    message.nodeUpdates.push($root.lnrpc.NodeUpdate.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.channelUpdates && message.channelUpdates.length))
                        message.channelUpdates = [];
                    message.channelUpdates.push($root.lnrpc.ChannelEdgeUpdate.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.closedChans && message.closedChans.length))
                        message.closedChans = [];
                    message.closedChans.push($root.lnrpc.ClosedChannelUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphTopologyUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologyUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphTopologyUpdate message.
         * @function verify
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphTopologyUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeUpdates != null && message.hasOwnProperty("nodeUpdates")) {
                if (!Array.isArray(message.nodeUpdates))
                    return "nodeUpdates: array expected";
                for (let i = 0; i < message.nodeUpdates.length; ++i) {
                    let error = $root.lnrpc.NodeUpdate.verify(message.nodeUpdates[i]);
                    if (error)
                        return "nodeUpdates." + error;
                }
            }
            if (message.channelUpdates != null && message.hasOwnProperty("channelUpdates")) {
                if (!Array.isArray(message.channelUpdates))
                    return "channelUpdates: array expected";
                for (let i = 0; i < message.channelUpdates.length; ++i) {
                    let error = $root.lnrpc.ChannelEdgeUpdate.verify(message.channelUpdates[i]);
                    if (error)
                        return "channelUpdates." + error;
                }
            }
            if (message.closedChans != null && message.hasOwnProperty("closedChans")) {
                if (!Array.isArray(message.closedChans))
                    return "closedChans: array expected";
                for (let i = 0; i < message.closedChans.length; ++i) {
                    let error = $root.lnrpc.ClosedChannelUpdate.verify(message.closedChans[i]);
                    if (error)
                        return "closedChans." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphTopologyUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         */
        GraphTopologyUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GraphTopologyUpdate)
                return object;
            let message = new $root.lnrpc.GraphTopologyUpdate();
            if (object.nodeUpdates) {
                if (!Array.isArray(object.nodeUpdates))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.nodeUpdates: array expected");
                message.nodeUpdates = [];
                for (let i = 0; i < object.nodeUpdates.length; ++i) {
                    if (typeof object.nodeUpdates[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.nodeUpdates: object expected");
                    message.nodeUpdates[i] = $root.lnrpc.NodeUpdate.fromObject(object.nodeUpdates[i]);
                }
            }
            if (object.channelUpdates) {
                if (!Array.isArray(object.channelUpdates))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.channelUpdates: array expected");
                message.channelUpdates = [];
                for (let i = 0; i < object.channelUpdates.length; ++i) {
                    if (typeof object.channelUpdates[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.channelUpdates: object expected");
                    message.channelUpdates[i] = $root.lnrpc.ChannelEdgeUpdate.fromObject(object.channelUpdates[i]);
                }
            }
            if (object.closedChans) {
                if (!Array.isArray(object.closedChans))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.closedChans: array expected");
                message.closedChans = [];
                for (let i = 0; i < object.closedChans.length; ++i) {
                    if (typeof object.closedChans[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.closedChans: object expected");
                    message.closedChans[i] = $root.lnrpc.ClosedChannelUpdate.fromObject(object.closedChans[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphTopologyUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.GraphTopologyUpdate} message GraphTopologyUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphTopologyUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.nodeUpdates = [];
                object.channelUpdates = [];
                object.closedChans = [];
            }
            if (message.nodeUpdates && message.nodeUpdates.length) {
                object.nodeUpdates = [];
                for (let j = 0; j < message.nodeUpdates.length; ++j)
                    object.nodeUpdates[j] = $root.lnrpc.NodeUpdate.toObject(message.nodeUpdates[j], options);
            }
            if (message.channelUpdates && message.channelUpdates.length) {
                object.channelUpdates = [];
                for (let j = 0; j < message.channelUpdates.length; ++j)
                    object.channelUpdates[j] = $root.lnrpc.ChannelEdgeUpdate.toObject(message.channelUpdates[j], options);
            }
            if (message.closedChans && message.closedChans.length) {
                object.closedChans = [];
                for (let j = 0; j < message.closedChans.length; ++j)
                    object.closedChans[j] = $root.lnrpc.ClosedChannelUpdate.toObject(message.closedChans[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphTopologyUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphTopologyUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphTopologyUpdate;
    })();

    lnrpc.NodeUpdate = (function() {

        /**
         * Properties of a NodeUpdate.
         * @memberof lnrpc
         * @interface INodeUpdate
         * @property {Array.<string>|null} [addresses] NodeUpdate addresses
         * @property {string|null} [identityKey] NodeUpdate identityKey
         * @property {Uint8Array|null} [globalFeatures] NodeUpdate globalFeatures
         * @property {string|null} [alias] NodeUpdate alias
         * @property {string|null} [color] NodeUpdate color
         */

        /**
         * Constructs a new NodeUpdate.
         * @memberof lnrpc
         * @classdesc Represents a NodeUpdate.
         * @implements INodeUpdate
         * @constructor
         * @param {lnrpc.INodeUpdate=} [properties] Properties to set
         */
        function NodeUpdate(properties) {
            this.addresses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeUpdate addresses.
         * @member {Array.<string>} addresses
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.addresses = $util.emptyArray;

        /**
         * NodeUpdate identityKey.
         * @member {string} identityKey
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.identityKey = "";

        /**
         * NodeUpdate globalFeatures.
         * @member {Uint8Array} globalFeatures
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.globalFeatures = $util.newBuffer([]);

        /**
         * NodeUpdate alias.
         * @member {string} alias
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.alias = "";

        /**
         * NodeUpdate color.
         * @member {string} color
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.color = "";

        /**
         * Creates a new NodeUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate=} [properties] Properties to set
         * @returns {lnrpc.NodeUpdate} NodeUpdate instance
         */
        NodeUpdate.create = function create(properties) {
            return new NodeUpdate(properties);
        };

        /**
         * Encodes the specified NodeUpdate message. Does not implicitly {@link lnrpc.NodeUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate} message NodeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addresses != null && message.addresses.length)
                for (let i = 0; i < message.addresses.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.addresses[i]);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.identityKey);
            if (message.globalFeatures != null && Object.hasOwnProperty.call(message, "globalFeatures"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.globalFeatures);
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.alias);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
            return writer;
        };

        /**
         * Encodes the specified NodeUpdate message, length delimited. Does not implicitly {@link lnrpc.NodeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate} message NodeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push(reader.string());
                    break;
                case 2:
                    message.identityKey = reader.string();
                    break;
                case 3:
                    message.globalFeatures = reader.bytes();
                    break;
                case 4:
                    message.alias = reader.string();
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeUpdate message.
         * @function verify
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (let i = 0; i < message.addresses.length; ++i)
                    if (!$util.isString(message.addresses[i]))
                        return "addresses: string[] expected";
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!$util.isString(message.identityKey))
                    return "identityKey: string expected";
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                if (!(message.globalFeatures && typeof message.globalFeatures.length === "number" || $util.isString(message.globalFeatures)))
                    return "globalFeatures: buffer expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            return null;
        };

        /**
         * Creates a NodeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         */
        NodeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeUpdate)
                return object;
            let message = new $root.lnrpc.NodeUpdate();
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".lnrpc.NodeUpdate.addresses: array expected");
                message.addresses = [];
                for (let i = 0; i < object.addresses.length; ++i)
                    message.addresses[i] = String(object.addresses[i]);
            }
            if (object.identityKey != null)
                message.identityKey = String(object.identityKey);
            if (object.globalFeatures != null)
                if (typeof object.globalFeatures === "string")
                    $util.base64.decode(object.globalFeatures, message.globalFeatures = $util.newBuffer($util.base64.length(object.globalFeatures)), 0);
                else if (object.globalFeatures.length)
                    message.globalFeatures = object.globalFeatures;
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.color != null)
                message.color = String(object.color);
            return message;
        };

        /**
         * Creates a plain object from a NodeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.NodeUpdate} message NodeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults) {
                object.identityKey = "";
                if (options.bytes === String)
                    object.globalFeatures = "";
                else {
                    object.globalFeatures = [];
                    if (options.bytes !== Array)
                        object.globalFeatures = $util.newBuffer(object.globalFeatures);
                }
                object.alias = "";
                object.color = "";
            }
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (let j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = message.addresses[j];
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = message.identityKey;
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                object.globalFeatures = options.bytes === String ? $util.base64.encode(message.globalFeatures, 0, message.globalFeatures.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalFeatures) : message.globalFeatures;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };

        /**
         * Converts this NodeUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeUpdate;
    })();

    lnrpc.ChannelEdgeUpdate = (function() {

        /**
         * Properties of a ChannelEdgeUpdate.
         * @memberof lnrpc
         * @interface IChannelEdgeUpdate
         * @property {number|Long|null} [chanId] ChannelEdgeUpdate chanId
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ChannelEdgeUpdate chanPoint
         * @property {number|Long|null} [capacity] ChannelEdgeUpdate capacity
         * @property {lnrpc.IRoutingPolicy|null} [routingPolicy] ChannelEdgeUpdate routingPolicy
         * @property {string|null} [advertisingNode] ChannelEdgeUpdate advertisingNode
         * @property {string|null} [connectingNode] ChannelEdgeUpdate connectingNode
         */

        /**
         * Constructs a new ChannelEdgeUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEdgeUpdate.
         * @implements IChannelEdgeUpdate
         * @constructor
         * @param {lnrpc.IChannelEdgeUpdate=} [properties] Properties to set
         */
        function ChannelEdgeUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelEdgeUpdate chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelEdgeUpdate chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.chanPoint = null;

        /**
         * ChannelEdgeUpdate capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelEdgeUpdate routingPolicy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} routingPolicy
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.routingPolicy = null;

        /**
         * ChannelEdgeUpdate advertisingNode.
         * @member {string} advertisingNode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.advertisingNode = "";

        /**
         * ChannelEdgeUpdate connectingNode.
         * @member {string} connectingNode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.connectingNode = "";

        /**
         * Creates a new ChannelEdgeUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate instance
         */
        ChannelEdgeUpdate.create = function create(properties) {
            return new ChannelEdgeUpdate(properties);
        };

        /**
         * Encodes the specified ChannelEdgeUpdate message. Does not implicitly {@link lnrpc.ChannelEdgeUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate} message ChannelEdgeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdgeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.capacity != null && Object.hasOwnProperty.call(message, "capacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.capacity);
            if (message.routingPolicy != null && Object.hasOwnProperty.call(message, "routingPolicy"))
                $root.lnrpc.RoutingPolicy.encode(message.routingPolicy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.advertisingNode != null && Object.hasOwnProperty.call(message, "advertisingNode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.advertisingNode);
            if (message.connectingNode != null && Object.hasOwnProperty.call(message, "connectingNode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.connectingNode);
            return writer;
        };

        /**
         * Encodes the specified ChannelEdgeUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelEdgeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate} message ChannelEdgeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdgeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEdgeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdgeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEdgeUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.capacity = reader.int64();
                    break;
                case 4:
                    message.routingPolicy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.advertisingNode = reader.string();
                    break;
                case 6:
                    message.connectingNode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEdgeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdgeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEdgeUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEdgeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy")) {
                let error = $root.lnrpc.RoutingPolicy.verify(message.routingPolicy);
                if (error)
                    return "routingPolicy." + error;
            }
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                if (!$util.isString(message.advertisingNode))
                    return "advertisingNode: string expected";
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                if (!$util.isString(message.connectingNode))
                    return "connectingNode: string expected";
            return null;
        };

        /**
         * Creates a ChannelEdgeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         */
        ChannelEdgeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEdgeUpdate)
                return object;
            let message = new $root.lnrpc.ChannelEdgeUpdate();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ChannelEdgeUpdate.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.routingPolicy != null) {
                if (typeof object.routingPolicy !== "object")
                    throw TypeError(".lnrpc.ChannelEdgeUpdate.routingPolicy: object expected");
                message.routingPolicy = $root.lnrpc.RoutingPolicy.fromObject(object.routingPolicy);
            }
            if (object.advertisingNode != null)
                message.advertisingNode = String(object.advertisingNode);
            if (object.connectingNode != null)
                message.connectingNode = String(object.connectingNode);
            return message;
        };

        /**
         * Creates a plain object from a ChannelEdgeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.ChannelEdgeUpdate} message ChannelEdgeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEdgeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.chanPoint = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.routingPolicy = null;
                object.advertisingNode = "";
                object.connectingNode = "";
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy"))
                object.routingPolicy = $root.lnrpc.RoutingPolicy.toObject(message.routingPolicy, options);
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                object.advertisingNode = message.advertisingNode;
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                object.connectingNode = message.connectingNode;
            return object;
        };

        /**
         * Converts this ChannelEdgeUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEdgeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEdgeUpdate;
    })();

    lnrpc.ClosedChannelUpdate = (function() {

        /**
         * Properties of a ClosedChannelUpdate.
         * @memberof lnrpc
         * @interface IClosedChannelUpdate
         * @property {number|Long|null} [chanId] ClosedChannelUpdate chanId
         * @property {number|Long|null} [capacity] ClosedChannelUpdate capacity
         * @property {number|null} [closedHeight] ClosedChannelUpdate closedHeight
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ClosedChannelUpdate chanPoint
         */

        /**
         * Constructs a new ClosedChannelUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelUpdate.
         * @implements IClosedChannelUpdate
         * @constructor
         * @param {lnrpc.IClosedChannelUpdate=} [properties] Properties to set
         */
        function ClosedChannelUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelUpdate chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ClosedChannelUpdate capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ClosedChannelUpdate closedHeight.
         * @member {number} closedHeight
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.closedHeight = 0;

        /**
         * ClosedChannelUpdate chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.chanPoint = null;

        /**
         * Creates a new ClosedChannelUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate instance
         */
        ClosedChannelUpdate.create = function create(properties) {
            return new ClosedChannelUpdate(properties);
        };

        /**
         * Encodes the specified ClosedChannelUpdate message. Does not implicitly {@link lnrpc.ClosedChannelUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate} message ClosedChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.capacity != null && Object.hasOwnProperty.call(message, "capacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.capacity);
            if (message.closedHeight != null && Object.hasOwnProperty.call(message, "closedHeight"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.closedHeight);
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelUpdate message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate} message ClosedChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.capacity = reader.int64();
                    break;
                case 3:
                    message.closedHeight = reader.uint32();
                    break;
                case 4:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelUpdate message.
         * @function verify
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                if (!$util.isInteger(message.closedHeight))
                    return "closedHeight: integer expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            return null;
        };

        /**
         * Creates a ClosedChannelUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         */
        ClosedChannelUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelUpdate)
                return object;
            let message = new $root.lnrpc.ClosedChannelUpdate();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.closedHeight != null)
                message.closedHeight = object.closedHeight >>> 0;
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ClosedChannelUpdate.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.ClosedChannelUpdate} message ClosedChannelUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.closedHeight = 0;
                object.chanPoint = null;
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                object.closedHeight = message.closedHeight;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            return object;
        };

        /**
         * Converts this ClosedChannelUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelUpdate;
    })();

    lnrpc.HopHint = (function() {

        /**
         * Properties of a HopHint.
         * @memberof lnrpc
         * @interface IHopHint
         * @property {string|null} [nodeId] HopHint nodeId
         * @property {number|Long|null} [chanId] HopHint chanId
         * @property {number|null} [feeBaseMsat] HopHint feeBaseMsat
         * @property {number|null} [feeProportionalMillionths] HopHint feeProportionalMillionths
         * @property {number|null} [cltvExpiryDelta] HopHint cltvExpiryDelta
         */

        /**
         * Constructs a new HopHint.
         * @memberof lnrpc
         * @classdesc Represents a HopHint.
         * @implements IHopHint
         * @constructor
         * @param {lnrpc.IHopHint=} [properties] Properties to set
         */
        function HopHint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HopHint nodeId.
         * @member {string} nodeId
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.nodeId = "";

        /**
         * HopHint chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HopHint feeBaseMsat.
         * @member {number} feeBaseMsat
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.feeBaseMsat = 0;

        /**
         * HopHint feeProportionalMillionths.
         * @member {number} feeProportionalMillionths
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.feeProportionalMillionths = 0;

        /**
         * HopHint cltvExpiryDelta.
         * @member {number} cltvExpiryDelta
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.cltvExpiryDelta = 0;

        /**
         * Creates a new HopHint instance using the specified properties.
         * @function create
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint=} [properties] Properties to set
         * @returns {lnrpc.HopHint} HopHint instance
         */
        HopHint.create = function create(properties) {
            return new HopHint(properties);
        };

        /**
         * Encodes the specified HopHint message. Does not implicitly {@link lnrpc.HopHint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint} message HopHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HopHint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanId);
            if (message.feeBaseMsat != null && Object.hasOwnProperty.call(message, "feeBaseMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.feeBaseMsat);
            if (message.feeProportionalMillionths != null && Object.hasOwnProperty.call(message, "feeProportionalMillionths"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.feeProportionalMillionths);
            if (message.cltvExpiryDelta != null && Object.hasOwnProperty.call(message, "cltvExpiryDelta"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.cltvExpiryDelta);
            return writer;
        };

        /**
         * Encodes the specified HopHint message, length delimited. Does not implicitly {@link lnrpc.HopHint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint} message HopHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HopHint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HopHint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HopHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HopHint} HopHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HopHint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HopHint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodeId = reader.string();
                    break;
                case 2:
                    message.chanId = reader.uint64();
                    break;
                case 3:
                    message.feeBaseMsat = reader.uint32();
                    break;
                case 4:
                    message.feeProportionalMillionths = reader.uint32();
                    break;
                case 5:
                    message.cltvExpiryDelta = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HopHint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HopHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HopHint} HopHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HopHint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HopHint message.
         * @function verify
         * @memberof lnrpc.HopHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HopHint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isString(message.nodeId))
                    return "nodeId: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (!$util.isInteger(message.feeBaseMsat))
                    return "feeBaseMsat: integer expected";
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                if (!$util.isInteger(message.feeProportionalMillionths))
                    return "feeProportionalMillionths: integer expected";
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                if (!$util.isInteger(message.cltvExpiryDelta))
                    return "cltvExpiryDelta: integer expected";
            return null;
        };

        /**
         * Creates a HopHint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HopHint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HopHint} HopHint
         */
        HopHint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HopHint)
                return object;
            let message = new $root.lnrpc.HopHint();
            if (object.nodeId != null)
                message.nodeId = String(object.nodeId);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.feeBaseMsat != null)
                message.feeBaseMsat = object.feeBaseMsat >>> 0;
            if (object.feeProportionalMillionths != null)
                message.feeProportionalMillionths = object.feeProportionalMillionths >>> 0;
            if (object.cltvExpiryDelta != null)
                message.cltvExpiryDelta = object.cltvExpiryDelta >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HopHint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.HopHint} message HopHint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HopHint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.nodeId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.feeBaseMsat = 0;
                object.feeProportionalMillionths = 0;
                object.cltvExpiryDelta = 0;
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = message.nodeId;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                object.feeBaseMsat = message.feeBaseMsat;
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                object.feeProportionalMillionths = message.feeProportionalMillionths;
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                object.cltvExpiryDelta = message.cltvExpiryDelta;
            return object;
        };

        /**
         * Converts this HopHint to JSON.
         * @function toJSON
         * @memberof lnrpc.HopHint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HopHint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HopHint;
    })();

    lnrpc.RouteHint = (function() {

        /**
         * Properties of a RouteHint.
         * @memberof lnrpc
         * @interface IRouteHint
         * @property {Array.<lnrpc.IHopHint>|null} [hopHints] RouteHint hopHints
         */

        /**
         * Constructs a new RouteHint.
         * @memberof lnrpc
         * @classdesc Represents a RouteHint.
         * @implements IRouteHint
         * @constructor
         * @param {lnrpc.IRouteHint=} [properties] Properties to set
         */
        function RouteHint(properties) {
            this.hopHints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RouteHint hopHints.
         * @member {Array.<lnrpc.IHopHint>} hopHints
         * @memberof lnrpc.RouteHint
         * @instance
         */
        RouteHint.prototype.hopHints = $util.emptyArray;

        /**
         * Creates a new RouteHint instance using the specified properties.
         * @function create
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint=} [properties] Properties to set
         * @returns {lnrpc.RouteHint} RouteHint instance
         */
        RouteHint.create = function create(properties) {
            return new RouteHint(properties);
        };

        /**
         * Encodes the specified RouteHint message. Does not implicitly {@link lnrpc.RouteHint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint} message RouteHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteHint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hopHints != null && message.hopHints.length)
                for (let i = 0; i < message.hopHints.length; ++i)
                    $root.lnrpc.HopHint.encode(message.hopHints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RouteHint message, length delimited. Does not implicitly {@link lnrpc.RouteHint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint} message RouteHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteHint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RouteHint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RouteHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RouteHint} RouteHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteHint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RouteHint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.hopHints && message.hopHints.length))
                        message.hopHints = [];
                    message.hopHints.push($root.lnrpc.HopHint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RouteHint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RouteHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RouteHint} RouteHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteHint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RouteHint message.
         * @function verify
         * @memberof lnrpc.RouteHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RouteHint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hopHints != null && message.hasOwnProperty("hopHints")) {
                if (!Array.isArray(message.hopHints))
                    return "hopHints: array expected";
                for (let i = 0; i < message.hopHints.length; ++i) {
                    let error = $root.lnrpc.HopHint.verify(message.hopHints[i]);
                    if (error)
                        return "hopHints." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RouteHint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RouteHint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RouteHint} RouteHint
         */
        RouteHint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RouteHint)
                return object;
            let message = new $root.lnrpc.RouteHint();
            if (object.hopHints) {
                if (!Array.isArray(object.hopHints))
                    throw TypeError(".lnrpc.RouteHint.hopHints: array expected");
                message.hopHints = [];
                for (let i = 0; i < object.hopHints.length; ++i) {
                    if (typeof object.hopHints[i] !== "object")
                        throw TypeError(".lnrpc.RouteHint.hopHints: object expected");
                    message.hopHints[i] = $root.lnrpc.HopHint.fromObject(object.hopHints[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RouteHint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.RouteHint} message RouteHint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RouteHint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.hopHints = [];
            if (message.hopHints && message.hopHints.length) {
                object.hopHints = [];
                for (let j = 0; j < message.hopHints.length; ++j)
                    object.hopHints[j] = $root.lnrpc.HopHint.toObject(message.hopHints[j], options);
            }
            return object;
        };

        /**
         * Converts this RouteHint to JSON.
         * @function toJSON
         * @memberof lnrpc.RouteHint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RouteHint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RouteHint;
    })();

    lnrpc.Invoice = (function() {

        /**
         * Properties of an Invoice.
         * @memberof lnrpc
         * @interface IInvoice
         * @property {string|null} [memo] Invoice memo
         * @property {Uint8Array|null} [rPreimage] Invoice rPreimage
         * @property {Uint8Array|null} [rHash] Invoice rHash
         * @property {number|Long|null} [value] Invoice value
         * @property {number|Long|null} [valueMsat] Invoice valueMsat
         * @property {boolean|null} [settled] Invoice settled
         * @property {number|Long|null} [creationDate] Invoice creationDate
         * @property {number|Long|null} [settleDate] Invoice settleDate
         * @property {string|null} [paymentRequest] Invoice paymentRequest
         * @property {Uint8Array|null} [descriptionHash] Invoice descriptionHash
         * @property {number|Long|null} [expiry] Invoice expiry
         * @property {string|null} [fallbackAddr] Invoice fallbackAddr
         * @property {number|Long|null} [cltvExpiry] Invoice cltvExpiry
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] Invoice routeHints
         * @property {boolean|null} ["private"] Invoice private
         * @property {number|Long|null} [addIndex] Invoice addIndex
         * @property {number|Long|null} [settleIndex] Invoice settleIndex
         * @property {number|Long|null} [amtPaid] Invoice amtPaid
         * @property {number|Long|null} [amtPaidSat] Invoice amtPaidSat
         * @property {number|Long|null} [amtPaidMsat] Invoice amtPaidMsat
         * @property {lnrpc.Invoice.InvoiceState|null} [state] Invoice state
         * @property {Array.<lnrpc.IInvoiceHTLC>|null} [htlcs] Invoice htlcs
         * @property {Object.<string,lnrpc.IFeature>|null} [features] Invoice features
         * @property {boolean|null} [isKeysend] Invoice isKeysend
         */

        /**
         * Constructs a new Invoice.
         * @memberof lnrpc
         * @classdesc Represents an Invoice.
         * @implements IInvoice
         * @constructor
         * @param {lnrpc.IInvoice=} [properties] Properties to set
         */
        function Invoice(properties) {
            this.routeHints = [];
            this.htlcs = [];
            this.features = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Invoice memo.
         * @member {string} memo
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.memo = "";

        /**
         * Invoice rPreimage.
         * @member {Uint8Array} rPreimage
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.rPreimage = $util.newBuffer([]);

        /**
         * Invoice rHash.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.rHash = $util.newBuffer([]);

        /**
         * Invoice value.
         * @member {number|Long} value
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice valueMsat.
         * @member {number|Long} valueMsat
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.valueMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice settled.
         * @member {boolean} settled
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settled = false;

        /**
         * Invoice creationDate.
         * @member {number|Long} creationDate
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.creationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice settleDate.
         * @member {number|Long} settleDate
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settleDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice paymentRequest.
         * @member {string} paymentRequest
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.paymentRequest = "";

        /**
         * Invoice descriptionHash.
         * @member {Uint8Array} descriptionHash
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.descriptionHash = $util.newBuffer([]);

        /**
         * Invoice expiry.
         * @member {number|Long} expiry
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.expiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice fallbackAddr.
         * @member {string} fallbackAddr
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.fallbackAddr = "";

        /**
         * Invoice cltvExpiry.
         * @member {number|Long} cltvExpiry
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.cltvExpiry = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Invoice routeHints.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.routeHints = $util.emptyArray;

        /**
         * Invoice private.
         * @member {boolean} private
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype["private"] = false;

        /**
         * Invoice addIndex.
         * @member {number|Long} addIndex
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Invoice settleIndex.
         * @member {number|Long} settleIndex
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settleIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Invoice amtPaid.
         * @member {number|Long} amtPaid
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice amtPaidSat.
         * @member {number|Long} amtPaidSat
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaidSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice amtPaidMsat.
         * @member {number|Long} amtPaidMsat
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaidMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Invoice state.
         * @member {lnrpc.Invoice.InvoiceState} state
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.state = 0;

        /**
         * Invoice htlcs.
         * @member {Array.<lnrpc.IInvoiceHTLC>} htlcs
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.htlcs = $util.emptyArray;

        /**
         * Invoice features.
         * @member {Object.<string,lnrpc.IFeature>} features
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.features = $util.emptyObject;

        /**
         * Invoice isKeysend.
         * @member {boolean} isKeysend
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.isKeysend = false;

        /**
         * Creates a new Invoice instance using the specified properties.
         * @function create
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice=} [properties] Properties to set
         * @returns {lnrpc.Invoice} Invoice instance
         */
        Invoice.create = function create(properties) {
            return new Invoice(properties);
        };

        /**
         * Encodes the specified Invoice message. Does not implicitly {@link lnrpc.Invoice.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice} message Invoice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invoice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.memo);
            if (message.rPreimage != null && Object.hasOwnProperty.call(message, "rPreimage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rPreimage);
            if (message.rHash != null && Object.hasOwnProperty.call(message, "rHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rHash);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.value);
            if (message.settled != null && Object.hasOwnProperty.call(message, "settled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.settled);
            if (message.creationDate != null && Object.hasOwnProperty.call(message, "creationDate"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.creationDate);
            if (message.settleDate != null && Object.hasOwnProperty.call(message, "settleDate"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.settleDate);
            if (message.paymentRequest != null && Object.hasOwnProperty.call(message, "paymentRequest"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.paymentRequest);
            if (message.descriptionHash != null && Object.hasOwnProperty.call(message, "descriptionHash"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.descriptionHash);
            if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.expiry);
            if (message.fallbackAddr != null && Object.hasOwnProperty.call(message, "fallbackAddr"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.fallbackAddr);
            if (message.cltvExpiry != null && Object.hasOwnProperty.call(message, "cltvExpiry"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.cltvExpiry);
            if (message.routeHints != null && message.routeHints.length)
                for (let i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message["private"]);
            if (message.addIndex != null && Object.hasOwnProperty.call(message, "addIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.addIndex);
            if (message.settleIndex != null && Object.hasOwnProperty.call(message, "settleIndex"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.settleIndex);
            if (message.amtPaid != null && Object.hasOwnProperty.call(message, "amtPaid"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.amtPaid);
            if (message.amtPaidSat != null && Object.hasOwnProperty.call(message, "amtPaidSat"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.amtPaidSat);
            if (message.amtPaidMsat != null && Object.hasOwnProperty.call(message, "amtPaidMsat"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.amtPaidMsat);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.state);
            if (message.htlcs != null && message.htlcs.length)
                for (let i = 0; i < message.htlcs.length; ++i)
                    $root.lnrpc.InvoiceHTLC.encode(message.htlcs[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.valueMsat != null && Object.hasOwnProperty.call(message, "valueMsat"))
                writer.uint32(/* id 23, wireType 0 =*/184).int64(message.valueMsat);
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 24, wireType 2 =*/194).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.lnrpc.Feature.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.isKeysend != null && Object.hasOwnProperty.call(message, "isKeysend"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.isKeysend);
            return writer;
        };

        /**
         * Encodes the specified Invoice message, length delimited. Does not implicitly {@link lnrpc.Invoice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice} message Invoice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invoice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Invoice message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Invoice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Invoice} Invoice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invoice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Invoice(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.memo = reader.string();
                    break;
                case 3:
                    message.rPreimage = reader.bytes();
                    break;
                case 4:
                    message.rHash = reader.bytes();
                    break;
                case 5:
                    message.value = reader.int64();
                    break;
                case 23:
                    message.valueMsat = reader.int64();
                    break;
                case 6:
                    message.settled = reader.bool();
                    break;
                case 7:
                    message.creationDate = reader.int64();
                    break;
                case 8:
                    message.settleDate = reader.int64();
                    break;
                case 9:
                    message.paymentRequest = reader.string();
                    break;
                case 10:
                    message.descriptionHash = reader.bytes();
                    break;
                case 11:
                    message.expiry = reader.int64();
                    break;
                case 12:
                    message.fallbackAddr = reader.string();
                    break;
                case 13:
                    message.cltvExpiry = reader.uint64();
                    break;
                case 14:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message["private"] = reader.bool();
                    break;
                case 16:
                    message.addIndex = reader.uint64();
                    break;
                case 17:
                    message.settleIndex = reader.uint64();
                    break;
                case 18:
                    message.amtPaid = reader.int64();
                    break;
                case 19:
                    message.amtPaidSat = reader.int64();
                    break;
                case 20:
                    message.amtPaidMsat = reader.int64();
                    break;
                case 21:
                    message.state = reader.int32();
                    break;
                case 22:
                    if (!(message.htlcs && message.htlcs.length))
                        message.htlcs = [];
                    message.htlcs.push($root.lnrpc.InvoiceHTLC.decode(reader, reader.uint32()));
                    break;
                case 24:
                    if (message.features === $util.emptyObject)
                        message.features = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint32();
                            break;
                        case 2:
                            value = $root.lnrpc.Feature.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.features[key] = value;
                    break;
                case 25:
                    message.isKeysend = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Invoice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Invoice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Invoice} Invoice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invoice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Invoice message.
         * @function verify
         * @memberof lnrpc.Invoice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Invoice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                if (!(message.rPreimage && typeof message.rPreimage.length === "number" || $util.isString(message.rPreimage)))
                    return "rPreimage: buffer expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                if (!$util.isInteger(message.valueMsat) && !(message.valueMsat && $util.isInteger(message.valueMsat.low) && $util.isInteger(message.valueMsat.high)))
                    return "valueMsat: integer|Long expected";
            if (message.settled != null && message.hasOwnProperty("settled"))
                if (typeof message.settled !== "boolean")
                    return "settled: boolean expected";
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (!$util.isInteger(message.creationDate) && !(message.creationDate && $util.isInteger(message.creationDate.low) && $util.isInteger(message.creationDate.high)))
                    return "creationDate: integer|Long expected";
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                if (!$util.isInteger(message.settleDate) && !(message.settleDate && $util.isInteger(message.settleDate.low) && $util.isInteger(message.settleDate.high)))
                    return "settleDate: integer|Long expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                if (!(message.descriptionHash && typeof message.descriptionHash.length === "number" || $util.isString(message.descriptionHash)))
                    return "descriptionHash: buffer expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry) && !(message.expiry && $util.isInteger(message.expiry.low) && $util.isInteger(message.expiry.high)))
                    return "expiry: integer|Long expected";
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                if (!$util.isString(message.fallbackAddr))
                    return "fallbackAddr: string expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry) && !(message.cltvExpiry && $util.isInteger(message.cltvExpiry.low) && $util.isInteger(message.cltvExpiry.high)))
                    return "cltvExpiry: integer|Long expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (let i = 0; i < message.routeHints.length; ++i) {
                    let error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (!$util.isInteger(message.settleIndex) && !(message.settleIndex && $util.isInteger(message.settleIndex.low) && $util.isInteger(message.settleIndex.high)))
                    return "settleIndex: integer|Long expected";
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                if (!$util.isInteger(message.amtPaid) && !(message.amtPaid && $util.isInteger(message.amtPaid.low) && $util.isInteger(message.amtPaid.high)))
                    return "amtPaid: integer|Long expected";
            if (message.amtPaidSat != null && message.hasOwnProperty("amtPaidSat"))
                if (!$util.isInteger(message.amtPaidSat) && !(message.amtPaidSat && $util.isInteger(message.amtPaidSat.low) && $util.isInteger(message.amtPaidSat.high)))
                    return "amtPaidSat: integer|Long expected";
            if (message.amtPaidMsat != null && message.hasOwnProperty("amtPaidMsat"))
                if (!$util.isInteger(message.amtPaidMsat) && !(message.amtPaidMsat && $util.isInteger(message.amtPaidMsat.low) && $util.isInteger(message.amtPaidMsat.high)))
                    return "amtPaidMsat: integer|Long expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.htlcs != null && message.hasOwnProperty("htlcs")) {
                if (!Array.isArray(message.htlcs))
                    return "htlcs: array expected";
                for (let i = 0; i < message.htlcs.length; ++i) {
                    let error = $root.lnrpc.InvoiceHTLC.verify(message.htlcs[i]);
                    if (error)
                        return "htlcs." + error;
                }
            }
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "features: integer key{k:uint32} expected";
                    {
                        let error = $root.lnrpc.Feature.verify(message.features[key[i]]);
                        if (error)
                            return "features." + error;
                    }
                }
            }
            if (message.isKeysend != null && message.hasOwnProperty("isKeysend"))
                if (typeof message.isKeysend !== "boolean")
                    return "isKeysend: boolean expected";
            return null;
        };

        /**
         * Creates an Invoice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Invoice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Invoice} Invoice
         */
        Invoice.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Invoice)
                return object;
            let message = new $root.lnrpc.Invoice();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.rPreimage != null)
                if (typeof object.rPreimage === "string")
                    $util.base64.decode(object.rPreimage, message.rPreimage = $util.newBuffer($util.base64.length(object.rPreimage)), 0);
                else if (object.rPreimage.length)
                    message.rPreimage = object.rPreimage;
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.valueMsat != null)
                if ($util.Long)
                    (message.valueMsat = $util.Long.fromValue(object.valueMsat)).unsigned = false;
                else if (typeof object.valueMsat === "string")
                    message.valueMsat = parseInt(object.valueMsat, 10);
                else if (typeof object.valueMsat === "number")
                    message.valueMsat = object.valueMsat;
                else if (typeof object.valueMsat === "object")
                    message.valueMsat = new $util.LongBits(object.valueMsat.low >>> 0, object.valueMsat.high >>> 0).toNumber();
            if (object.settled != null)
                message.settled = Boolean(object.settled);
            if (object.creationDate != null)
                if ($util.Long)
                    (message.creationDate = $util.Long.fromValue(object.creationDate)).unsigned = false;
                else if (typeof object.creationDate === "string")
                    message.creationDate = parseInt(object.creationDate, 10);
                else if (typeof object.creationDate === "number")
                    message.creationDate = object.creationDate;
                else if (typeof object.creationDate === "object")
                    message.creationDate = new $util.LongBits(object.creationDate.low >>> 0, object.creationDate.high >>> 0).toNumber();
            if (object.settleDate != null)
                if ($util.Long)
                    (message.settleDate = $util.Long.fromValue(object.settleDate)).unsigned = false;
                else if (typeof object.settleDate === "string")
                    message.settleDate = parseInt(object.settleDate, 10);
                else if (typeof object.settleDate === "number")
                    message.settleDate = object.settleDate;
                else if (typeof object.settleDate === "object")
                    message.settleDate = new $util.LongBits(object.settleDate.low >>> 0, object.settleDate.high >>> 0).toNumber();
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.descriptionHash != null)
                if (typeof object.descriptionHash === "string")
                    $util.base64.decode(object.descriptionHash, message.descriptionHash = $util.newBuffer($util.base64.length(object.descriptionHash)), 0);
                else if (object.descriptionHash.length)
                    message.descriptionHash = object.descriptionHash;
            if (object.expiry != null)
                if ($util.Long)
                    (message.expiry = $util.Long.fromValue(object.expiry)).unsigned = false;
                else if (typeof object.expiry === "string")
                    message.expiry = parseInt(object.expiry, 10);
                else if (typeof object.expiry === "number")
                    message.expiry = object.expiry;
                else if (typeof object.expiry === "object")
                    message.expiry = new $util.LongBits(object.expiry.low >>> 0, object.expiry.high >>> 0).toNumber();
            if (object.fallbackAddr != null)
                message.fallbackAddr = String(object.fallbackAddr);
            if (object.cltvExpiry != null)
                if ($util.Long)
                    (message.cltvExpiry = $util.Long.fromValue(object.cltvExpiry)).unsigned = true;
                else if (typeof object.cltvExpiry === "string")
                    message.cltvExpiry = parseInt(object.cltvExpiry, 10);
                else if (typeof object.cltvExpiry === "number")
                    message.cltvExpiry = object.cltvExpiry;
                else if (typeof object.cltvExpiry === "object")
                    message.cltvExpiry = new $util.LongBits(object.cltvExpiry.low >>> 0, object.cltvExpiry.high >>> 0).toNumber(true);
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.Invoice.routeHints: array expected");
                message.routeHints = [];
                for (let i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.Invoice.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            if (object.settleIndex != null)
                if ($util.Long)
                    (message.settleIndex = $util.Long.fromValue(object.settleIndex)).unsigned = true;
                else if (typeof object.settleIndex === "string")
                    message.settleIndex = parseInt(object.settleIndex, 10);
                else if (typeof object.settleIndex === "number")
                    message.settleIndex = object.settleIndex;
                else if (typeof object.settleIndex === "object")
                    message.settleIndex = new $util.LongBits(object.settleIndex.low >>> 0, object.settleIndex.high >>> 0).toNumber(true);
            if (object.amtPaid != null)
                if ($util.Long)
                    (message.amtPaid = $util.Long.fromValue(object.amtPaid)).unsigned = false;
                else if (typeof object.amtPaid === "string")
                    message.amtPaid = parseInt(object.amtPaid, 10);
                else if (typeof object.amtPaid === "number")
                    message.amtPaid = object.amtPaid;
                else if (typeof object.amtPaid === "object")
                    message.amtPaid = new $util.LongBits(object.amtPaid.low >>> 0, object.amtPaid.high >>> 0).toNumber();
            if (object.amtPaidSat != null)
                if ($util.Long)
                    (message.amtPaidSat = $util.Long.fromValue(object.amtPaidSat)).unsigned = false;
                else if (typeof object.amtPaidSat === "string")
                    message.amtPaidSat = parseInt(object.amtPaidSat, 10);
                else if (typeof object.amtPaidSat === "number")
                    message.amtPaidSat = object.amtPaidSat;
                else if (typeof object.amtPaidSat === "object")
                    message.amtPaidSat = new $util.LongBits(object.amtPaidSat.low >>> 0, object.amtPaidSat.high >>> 0).toNumber();
            if (object.amtPaidMsat != null)
                if ($util.Long)
                    (message.amtPaidMsat = $util.Long.fromValue(object.amtPaidMsat)).unsigned = false;
                else if (typeof object.amtPaidMsat === "string")
                    message.amtPaidMsat = parseInt(object.amtPaidMsat, 10);
                else if (typeof object.amtPaidMsat === "number")
                    message.amtPaidMsat = object.amtPaidMsat;
                else if (typeof object.amtPaidMsat === "object")
                    message.amtPaidMsat = new $util.LongBits(object.amtPaidMsat.low >>> 0, object.amtPaidMsat.high >>> 0).toNumber();
            switch (object.state) {
            case "OPEN":
            case 0:
                message.state = 0;
                break;
            case "SETTLED":
            case 1:
                message.state = 1;
                break;
            case "CANCELED":
            case 2:
                message.state = 2;
                break;
            case "ACCEPTED":
            case 3:
                message.state = 3;
                break;
            }
            if (object.htlcs) {
                if (!Array.isArray(object.htlcs))
                    throw TypeError(".lnrpc.Invoice.htlcs: array expected");
                message.htlcs = [];
                for (let i = 0; i < object.htlcs.length; ++i) {
                    if (typeof object.htlcs[i] !== "object")
                        throw TypeError(".lnrpc.Invoice.htlcs: object expected");
                    message.htlcs[i] = $root.lnrpc.InvoiceHTLC.fromObject(object.htlcs[i]);
                }
            }
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".lnrpc.Invoice.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".lnrpc.Invoice.features: object expected");
                    message.features[keys[i]] = $root.lnrpc.Feature.fromObject(object.features[keys[i]]);
                }
            }
            if (object.isKeysend != null)
                message.isKeysend = Boolean(object.isKeysend);
            return message;
        };

        /**
         * Creates a plain object from an Invoice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.Invoice} message Invoice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Invoice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.routeHints = [];
                object.htlcs = [];
            }
            if (options.objects || options.defaults)
                object.features = {};
            if (options.defaults) {
                object.memo = "";
                if (options.bytes === String)
                    object.rPreimage = "";
                else {
                    object.rPreimage = [];
                    if (options.bytes !== Array)
                        object.rPreimage = $util.newBuffer(object.rPreimage);
                }
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                object.settled = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.settleDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleDate = options.longs === String ? "0" : 0;
                object.paymentRequest = "";
                if (options.bytes === String)
                    object.descriptionHash = "";
                else {
                    object.descriptionHash = [];
                    if (options.bytes !== Array)
                        object.descriptionHash = $util.newBuffer(object.descriptionHash);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiry = options.longs === String ? "0" : 0;
                object.fallbackAddr = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.cltvExpiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cltvExpiry = options.longs === String ? "0" : 0;
                object["private"] = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.settleIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtPaid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtPaidSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaidSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtPaidMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaidMsat = options.longs === String ? "0" : 0;
                object.state = options.enums === String ? "OPEN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.valueMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.valueMsat = options.longs === String ? "0" : 0;
                object.isKeysend = false;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                object.rPreimage = options.bytes === String ? $util.base64.encode(message.rPreimage, 0, message.rPreimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.rPreimage) : message.rPreimage;
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.settled != null && message.hasOwnProperty("settled"))
                object.settled = message.settled;
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (typeof message.creationDate === "number")
                    object.creationDate = options.longs === String ? String(message.creationDate) : message.creationDate;
                else
                    object.creationDate = options.longs === String ? $util.Long.prototype.toString.call(message.creationDate) : options.longs === Number ? new $util.LongBits(message.creationDate.low >>> 0, message.creationDate.high >>> 0).toNumber() : message.creationDate;
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                if (typeof message.settleDate === "number")
                    object.settleDate = options.longs === String ? String(message.settleDate) : message.settleDate;
                else
                    object.settleDate = options.longs === String ? $util.Long.prototype.toString.call(message.settleDate) : options.longs === Number ? new $util.LongBits(message.settleDate.low >>> 0, message.settleDate.high >>> 0).toNumber() : message.settleDate;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                object.descriptionHash = options.bytes === String ? $util.base64.encode(message.descriptionHash, 0, message.descriptionHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionHash) : message.descriptionHash;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (typeof message.expiry === "number")
                    object.expiry = options.longs === String ? String(message.expiry) : message.expiry;
                else
                    object.expiry = options.longs === String ? $util.Long.prototype.toString.call(message.expiry) : options.longs === Number ? new $util.LongBits(message.expiry.low >>> 0, message.expiry.high >>> 0).toNumber() : message.expiry;
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                object.fallbackAddr = message.fallbackAddr;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (typeof message.cltvExpiry === "number")
                    object.cltvExpiry = options.longs === String ? String(message.cltvExpiry) : message.cltvExpiry;
                else
                    object.cltvExpiry = options.longs === String ? $util.Long.prototype.toString.call(message.cltvExpiry) : options.longs === Number ? new $util.LongBits(message.cltvExpiry.low >>> 0, message.cltvExpiry.high >>> 0).toNumber(true) : message.cltvExpiry;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (let j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (typeof message.settleIndex === "number")
                    object.settleIndex = options.longs === String ? String(message.settleIndex) : message.settleIndex;
                else
                    object.settleIndex = options.longs === String ? $util.Long.prototype.toString.call(message.settleIndex) : options.longs === Number ? new $util.LongBits(message.settleIndex.low >>> 0, message.settleIndex.high >>> 0).toNumber(true) : message.settleIndex;
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                if (typeof message.amtPaid === "number")
                    object.amtPaid = options.longs === String ? String(message.amtPaid) : message.amtPaid;
                else
                    object.amtPaid = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaid) : options.longs === Number ? new $util.LongBits(message.amtPaid.low >>> 0, message.amtPaid.high >>> 0).toNumber() : message.amtPaid;
            if (message.amtPaidSat != null && message.hasOwnProperty("amtPaidSat"))
                if (typeof message.amtPaidSat === "number")
                    object.amtPaidSat = options.longs === String ? String(message.amtPaidSat) : message.amtPaidSat;
                else
                    object.amtPaidSat = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaidSat) : options.longs === Number ? new $util.LongBits(message.amtPaidSat.low >>> 0, message.amtPaidSat.high >>> 0).toNumber() : message.amtPaidSat;
            if (message.amtPaidMsat != null && message.hasOwnProperty("amtPaidMsat"))
                if (typeof message.amtPaidMsat === "number")
                    object.amtPaidMsat = options.longs === String ? String(message.amtPaidMsat) : message.amtPaidMsat;
                else
                    object.amtPaidMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaidMsat) : options.longs === Number ? new $util.LongBits(message.amtPaidMsat.low >>> 0, message.amtPaidMsat.high >>> 0).toNumber() : message.amtPaidMsat;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.lnrpc.Invoice.InvoiceState[message.state] : message.state;
            if (message.htlcs && message.htlcs.length) {
                object.htlcs = [];
                for (let j = 0; j < message.htlcs.length; ++j)
                    object.htlcs[j] = $root.lnrpc.InvoiceHTLC.toObject(message.htlcs[j], options);
            }
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                if (typeof message.valueMsat === "number")
                    object.valueMsat = options.longs === String ? String(message.valueMsat) : message.valueMsat;
                else
                    object.valueMsat = options.longs === String ? $util.Long.prototype.toString.call(message.valueMsat) : options.longs === Number ? new $util.LongBits(message.valueMsat.low >>> 0, message.valueMsat.high >>> 0).toNumber() : message.valueMsat;
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.lnrpc.Feature.toObject(message.features[keys2[j]], options);
            }
            if (message.isKeysend != null && message.hasOwnProperty("isKeysend"))
                object.isKeysend = message.isKeysend;
            return object;
        };

        /**
         * Converts this Invoice to JSON.
         * @function toJSON
         * @memberof lnrpc.Invoice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Invoice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * InvoiceState enum.
         * @name lnrpc.Invoice.InvoiceState
         * @enum {number}
         * @property {number} OPEN=0 OPEN value
         * @property {number} SETTLED=1 SETTLED value
         * @property {number} CANCELED=2 CANCELED value
         * @property {number} ACCEPTED=3 ACCEPTED value
         */
        Invoice.InvoiceState = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OPEN"] = 0;
            values[valuesById[1] = "SETTLED"] = 1;
            values[valuesById[2] = "CANCELED"] = 2;
            values[valuesById[3] = "ACCEPTED"] = 3;
            return values;
        })();

        return Invoice;
    })();

    /**
     * InvoiceHTLCState enum.
     * @name lnrpc.InvoiceHTLCState
     * @enum {number}
     * @property {number} ACCEPTED=0 ACCEPTED value
     * @property {number} SETTLED=1 SETTLED value
     * @property {number} CANCELED=2 CANCELED value
     */
    lnrpc.InvoiceHTLCState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ACCEPTED"] = 0;
        values[valuesById[1] = "SETTLED"] = 1;
        values[valuesById[2] = "CANCELED"] = 2;
        return values;
    })();

    lnrpc.InvoiceHTLC = (function() {

        /**
         * Properties of an InvoiceHTLC.
         * @memberof lnrpc
         * @interface IInvoiceHTLC
         * @property {number|Long|null} [chanId] InvoiceHTLC chanId
         * @property {number|Long|null} [htlcIndex] InvoiceHTLC htlcIndex
         * @property {number|Long|null} [amtMsat] InvoiceHTLC amtMsat
         * @property {number|null} [acceptHeight] InvoiceHTLC acceptHeight
         * @property {number|Long|null} [acceptTime] InvoiceHTLC acceptTime
         * @property {number|Long|null} [resolveTime] InvoiceHTLC resolveTime
         * @property {number|null} [expiryHeight] InvoiceHTLC expiryHeight
         * @property {lnrpc.InvoiceHTLCState|null} [state] InvoiceHTLC state
         * @property {Object.<string,Uint8Array>|null} [customRecords] InvoiceHTLC customRecords
         * @property {number|Long|null} [mppTotalAmtMsat] InvoiceHTLC mppTotalAmtMsat
         */

        /**
         * Constructs a new InvoiceHTLC.
         * @memberof lnrpc
         * @classdesc Represents an InvoiceHTLC.
         * @implements IInvoiceHTLC
         * @constructor
         * @param {lnrpc.IInvoiceHTLC=} [properties] Properties to set
         */
        function InvoiceHTLC(properties) {
            this.customRecords = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InvoiceHTLC chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * InvoiceHTLC htlcIndex.
         * @member {number|Long} htlcIndex
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.htlcIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * InvoiceHTLC amtMsat.
         * @member {number|Long} amtMsat
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.amtMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * InvoiceHTLC acceptHeight.
         * @member {number} acceptHeight
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.acceptHeight = 0;

        /**
         * InvoiceHTLC acceptTime.
         * @member {number|Long} acceptTime
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.acceptTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InvoiceHTLC resolveTime.
         * @member {number|Long} resolveTime
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.resolveTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InvoiceHTLC expiryHeight.
         * @member {number} expiryHeight
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.expiryHeight = 0;

        /**
         * InvoiceHTLC state.
         * @member {lnrpc.InvoiceHTLCState} state
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.state = 0;

        /**
         * InvoiceHTLC customRecords.
         * @member {Object.<string,Uint8Array>} customRecords
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.customRecords = $util.emptyObject;

        /**
         * InvoiceHTLC mppTotalAmtMsat.
         * @member {number|Long} mppTotalAmtMsat
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         */
        InvoiceHTLC.prototype.mppTotalAmtMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new InvoiceHTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {lnrpc.IInvoiceHTLC=} [properties] Properties to set
         * @returns {lnrpc.InvoiceHTLC} InvoiceHTLC instance
         */
        InvoiceHTLC.create = function create(properties) {
            return new InvoiceHTLC(properties);
        };

        /**
         * Encodes the specified InvoiceHTLC message. Does not implicitly {@link lnrpc.InvoiceHTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {lnrpc.IInvoiceHTLC} message InvoiceHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceHTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.htlcIndex != null && Object.hasOwnProperty.call(message, "htlcIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.htlcIndex);
            if (message.amtMsat != null && Object.hasOwnProperty.call(message, "amtMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.amtMsat);
            if (message.acceptHeight != null && Object.hasOwnProperty.call(message, "acceptHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.acceptHeight);
            if (message.acceptTime != null && Object.hasOwnProperty.call(message, "acceptTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.acceptTime);
            if (message.resolveTime != null && Object.hasOwnProperty.call(message, "resolveTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.resolveTime);
            if (message.expiryHeight != null && Object.hasOwnProperty.call(message, "expiryHeight"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.expiryHeight);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.state);
            if (message.customRecords != null && Object.hasOwnProperty.call(message, "customRecords"))
                for (let keys = Object.keys(message.customRecords), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.customRecords[keys[i]]).ldelim();
            if (message.mppTotalAmtMsat != null && Object.hasOwnProperty.call(message, "mppTotalAmtMsat"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.mppTotalAmtMsat);
            return writer;
        };

        /**
         * Encodes the specified InvoiceHTLC message, length delimited. Does not implicitly {@link lnrpc.InvoiceHTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {lnrpc.IInvoiceHTLC} message InvoiceHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceHTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvoiceHTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InvoiceHTLC} InvoiceHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceHTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InvoiceHTLC(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.htlcIndex = reader.uint64();
                    break;
                case 3:
                    message.amtMsat = reader.uint64();
                    break;
                case 4:
                    message.acceptHeight = reader.int32();
                    break;
                case 5:
                    message.acceptTime = reader.int64();
                    break;
                case 6:
                    message.resolveTime = reader.int64();
                    break;
                case 7:
                    message.expiryHeight = reader.int32();
                    break;
                case 8:
                    message.state = reader.int32();
                    break;
                case 9:
                    if (message.customRecords === $util.emptyObject)
                        message.customRecords = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = [];
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint64();
                            break;
                        case 2:
                            value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.customRecords[typeof key === "object" ? $util.longToHash(key) : key] = value;
                    break;
                case 10:
                    message.mppTotalAmtMsat = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvoiceHTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InvoiceHTLC} InvoiceHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceHTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvoiceHTLC message.
         * @function verify
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvoiceHTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.htlcIndex != null && message.hasOwnProperty("htlcIndex"))
                if (!$util.isInteger(message.htlcIndex) && !(message.htlcIndex && $util.isInteger(message.htlcIndex.low) && $util.isInteger(message.htlcIndex.high)))
                    return "htlcIndex: integer|Long expected";
            if (message.amtMsat != null && message.hasOwnProperty("amtMsat"))
                if (!$util.isInteger(message.amtMsat) && !(message.amtMsat && $util.isInteger(message.amtMsat.low) && $util.isInteger(message.amtMsat.high)))
                    return "amtMsat: integer|Long expected";
            if (message.acceptHeight != null && message.hasOwnProperty("acceptHeight"))
                if (!$util.isInteger(message.acceptHeight))
                    return "acceptHeight: integer expected";
            if (message.acceptTime != null && message.hasOwnProperty("acceptTime"))
                if (!$util.isInteger(message.acceptTime) && !(message.acceptTime && $util.isInteger(message.acceptTime.low) && $util.isInteger(message.acceptTime.high)))
                    return "acceptTime: integer|Long expected";
            if (message.resolveTime != null && message.hasOwnProperty("resolveTime"))
                if (!$util.isInteger(message.resolveTime) && !(message.resolveTime && $util.isInteger(message.resolveTime.low) && $util.isInteger(message.resolveTime.high)))
                    return "resolveTime: integer|Long expected";
            if (message.expiryHeight != null && message.hasOwnProperty("expiryHeight"))
                if (!$util.isInteger(message.expiryHeight))
                    return "expiryHeight: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.customRecords != null && message.hasOwnProperty("customRecords")) {
                if (!$util.isObject(message.customRecords))
                    return "customRecords: object expected";
                let key = Object.keys(message.customRecords);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "customRecords: integer|Long key{k:uint64} expected";
                    if (!(message.customRecords[key[i]] && typeof message.customRecords[key[i]].length === "number" || $util.isString(message.customRecords[key[i]])))
                        return "customRecords: buffer{k:uint64} expected";
                }
            }
            if (message.mppTotalAmtMsat != null && message.hasOwnProperty("mppTotalAmtMsat"))
                if (!$util.isInteger(message.mppTotalAmtMsat) && !(message.mppTotalAmtMsat && $util.isInteger(message.mppTotalAmtMsat.low) && $util.isInteger(message.mppTotalAmtMsat.high)))
                    return "mppTotalAmtMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates an InvoiceHTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InvoiceHTLC} InvoiceHTLC
         */
        InvoiceHTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InvoiceHTLC)
                return object;
            let message = new $root.lnrpc.InvoiceHTLC();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.htlcIndex != null)
                if ($util.Long)
                    (message.htlcIndex = $util.Long.fromValue(object.htlcIndex)).unsigned = true;
                else if (typeof object.htlcIndex === "string")
                    message.htlcIndex = parseInt(object.htlcIndex, 10);
                else if (typeof object.htlcIndex === "number")
                    message.htlcIndex = object.htlcIndex;
                else if (typeof object.htlcIndex === "object")
                    message.htlcIndex = new $util.LongBits(object.htlcIndex.low >>> 0, object.htlcIndex.high >>> 0).toNumber(true);
            if (object.amtMsat != null)
                if ($util.Long)
                    (message.amtMsat = $util.Long.fromValue(object.amtMsat)).unsigned = true;
                else if (typeof object.amtMsat === "string")
                    message.amtMsat = parseInt(object.amtMsat, 10);
                else if (typeof object.amtMsat === "number")
                    message.amtMsat = object.amtMsat;
                else if (typeof object.amtMsat === "object")
                    message.amtMsat = new $util.LongBits(object.amtMsat.low >>> 0, object.amtMsat.high >>> 0).toNumber(true);
            if (object.acceptHeight != null)
                message.acceptHeight = object.acceptHeight | 0;
            if (object.acceptTime != null)
                if ($util.Long)
                    (message.acceptTime = $util.Long.fromValue(object.acceptTime)).unsigned = false;
                else if (typeof object.acceptTime === "string")
                    message.acceptTime = parseInt(object.acceptTime, 10);
                else if (typeof object.acceptTime === "number")
                    message.acceptTime = object.acceptTime;
                else if (typeof object.acceptTime === "object")
                    message.acceptTime = new $util.LongBits(object.acceptTime.low >>> 0, object.acceptTime.high >>> 0).toNumber();
            if (object.resolveTime != null)
                if ($util.Long)
                    (message.resolveTime = $util.Long.fromValue(object.resolveTime)).unsigned = false;
                else if (typeof object.resolveTime === "string")
                    message.resolveTime = parseInt(object.resolveTime, 10);
                else if (typeof object.resolveTime === "number")
                    message.resolveTime = object.resolveTime;
                else if (typeof object.resolveTime === "object")
                    message.resolveTime = new $util.LongBits(object.resolveTime.low >>> 0, object.resolveTime.high >>> 0).toNumber();
            if (object.expiryHeight != null)
                message.expiryHeight = object.expiryHeight | 0;
            switch (object.state) {
            case "ACCEPTED":
            case 0:
                message.state = 0;
                break;
            case "SETTLED":
            case 1:
                message.state = 1;
                break;
            case "CANCELED":
            case 2:
                message.state = 2;
                break;
            }
            if (object.customRecords) {
                if (typeof object.customRecords !== "object")
                    throw TypeError(".lnrpc.InvoiceHTLC.customRecords: object expected");
                message.customRecords = {};
                for (let keys = Object.keys(object.customRecords), i = 0; i < keys.length; ++i)
                    if (typeof object.customRecords[keys[i]] === "string")
                        $util.base64.decode(object.customRecords[keys[i]], message.customRecords[keys[i]] = $util.newBuffer($util.base64.length(object.customRecords[keys[i]])), 0);
                    else if (object.customRecords[keys[i]].length)
                        message.customRecords[keys[i]] = object.customRecords[keys[i]];
            }
            if (object.mppTotalAmtMsat != null)
                if ($util.Long)
                    (message.mppTotalAmtMsat = $util.Long.fromValue(object.mppTotalAmtMsat)).unsigned = true;
                else if (typeof object.mppTotalAmtMsat === "string")
                    message.mppTotalAmtMsat = parseInt(object.mppTotalAmtMsat, 10);
                else if (typeof object.mppTotalAmtMsat === "number")
                    message.mppTotalAmtMsat = object.mppTotalAmtMsat;
                else if (typeof object.mppTotalAmtMsat === "object")
                    message.mppTotalAmtMsat = new $util.LongBits(object.mppTotalAmtMsat.low >>> 0, object.mppTotalAmtMsat.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an InvoiceHTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InvoiceHTLC
         * @static
         * @param {lnrpc.InvoiceHTLC} message InvoiceHTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvoiceHTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.customRecords = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.htlcIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.htlcIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtMsat = options.longs === String ? "0" : 0;
                object.acceptHeight = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.acceptTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.acceptTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.resolveTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resolveTime = options.longs === String ? "0" : 0;
                object.expiryHeight = 0;
                object.state = options.enums === String ? "ACCEPTED" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.mppTotalAmtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mppTotalAmtMsat = options.longs === String ? "0" : 0;
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.htlcIndex != null && message.hasOwnProperty("htlcIndex"))
                if (typeof message.htlcIndex === "number")
                    object.htlcIndex = options.longs === String ? String(message.htlcIndex) : message.htlcIndex;
                else
                    object.htlcIndex = options.longs === String ? $util.Long.prototype.toString.call(message.htlcIndex) : options.longs === Number ? new $util.LongBits(message.htlcIndex.low >>> 0, message.htlcIndex.high >>> 0).toNumber(true) : message.htlcIndex;
            if (message.amtMsat != null && message.hasOwnProperty("amtMsat"))
                if (typeof message.amtMsat === "number")
                    object.amtMsat = options.longs === String ? String(message.amtMsat) : message.amtMsat;
                else
                    object.amtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtMsat) : options.longs === Number ? new $util.LongBits(message.amtMsat.low >>> 0, message.amtMsat.high >>> 0).toNumber(true) : message.amtMsat;
            if (message.acceptHeight != null && message.hasOwnProperty("acceptHeight"))
                object.acceptHeight = message.acceptHeight;
            if (message.acceptTime != null && message.hasOwnProperty("acceptTime"))
                if (typeof message.acceptTime === "number")
                    object.acceptTime = options.longs === String ? String(message.acceptTime) : message.acceptTime;
                else
                    object.acceptTime = options.longs === String ? $util.Long.prototype.toString.call(message.acceptTime) : options.longs === Number ? new $util.LongBits(message.acceptTime.low >>> 0, message.acceptTime.high >>> 0).toNumber() : message.acceptTime;
            if (message.resolveTime != null && message.hasOwnProperty("resolveTime"))
                if (typeof message.resolveTime === "number")
                    object.resolveTime = options.longs === String ? String(message.resolveTime) : message.resolveTime;
                else
                    object.resolveTime = options.longs === String ? $util.Long.prototype.toString.call(message.resolveTime) : options.longs === Number ? new $util.LongBits(message.resolveTime.low >>> 0, message.resolveTime.high >>> 0).toNumber() : message.resolveTime;
            if (message.expiryHeight != null && message.hasOwnProperty("expiryHeight"))
                object.expiryHeight = message.expiryHeight;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.lnrpc.InvoiceHTLCState[message.state] : message.state;
            let keys2;
            if (message.customRecords && (keys2 = Object.keys(message.customRecords)).length) {
                object.customRecords = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.customRecords[keys2[j]] = options.bytes === String ? $util.base64.encode(message.customRecords[keys2[j]], 0, message.customRecords[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.customRecords[keys2[j]]) : message.customRecords[keys2[j]];
            }
            if (message.mppTotalAmtMsat != null && message.hasOwnProperty("mppTotalAmtMsat"))
                if (typeof message.mppTotalAmtMsat === "number")
                    object.mppTotalAmtMsat = options.longs === String ? String(message.mppTotalAmtMsat) : message.mppTotalAmtMsat;
                else
                    object.mppTotalAmtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.mppTotalAmtMsat) : options.longs === Number ? new $util.LongBits(message.mppTotalAmtMsat.low >>> 0, message.mppTotalAmtMsat.high >>> 0).toNumber(true) : message.mppTotalAmtMsat;
            return object;
        };

        /**
         * Converts this InvoiceHTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.InvoiceHTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvoiceHTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvoiceHTLC;
    })();

    lnrpc.AddInvoiceResponse = (function() {

        /**
         * Properties of an AddInvoiceResponse.
         * @memberof lnrpc
         * @interface IAddInvoiceResponse
         * @property {Uint8Array|null} [rHash] AddInvoiceResponse rHash
         * @property {string|null} [paymentRequest] AddInvoiceResponse paymentRequest
         * @property {number|Long|null} [addIndex] AddInvoiceResponse addIndex
         */

        /**
         * Constructs a new AddInvoiceResponse.
         * @memberof lnrpc
         * @classdesc Represents an AddInvoiceResponse.
         * @implements IAddInvoiceResponse
         * @constructor
         * @param {lnrpc.IAddInvoiceResponse=} [properties] Properties to set
         */
        function AddInvoiceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddInvoiceResponse rHash.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.rHash = $util.newBuffer([]);

        /**
         * AddInvoiceResponse paymentRequest.
         * @member {string} paymentRequest
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.paymentRequest = "";

        /**
         * AddInvoiceResponse addIndex.
         * @member {number|Long} addIndex
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AddInvoiceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse=} [properties] Properties to set
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse instance
         */
        AddInvoiceResponse.create = function create(properties) {
            return new AddInvoiceResponse(properties);
        };

        /**
         * Encodes the specified AddInvoiceResponse message. Does not implicitly {@link lnrpc.AddInvoiceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse} message AddInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddInvoiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rHash != null && Object.hasOwnProperty.call(message, "rHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rHash);
            if (message.paymentRequest != null && Object.hasOwnProperty.call(message, "paymentRequest"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentRequest);
            if (message.addIndex != null && Object.hasOwnProperty.call(message, "addIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.addIndex);
            return writer;
        };

        /**
         * Encodes the specified AddInvoiceResponse message, length delimited. Does not implicitly {@link lnrpc.AddInvoiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse} message AddInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddInvoiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddInvoiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddInvoiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AddInvoiceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rHash = reader.bytes();
                    break;
                case 2:
                    message.paymentRequest = reader.string();
                    break;
                case 16:
                    message.addIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddInvoiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddInvoiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddInvoiceResponse message.
         * @function verify
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddInvoiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an AddInvoiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         */
        AddInvoiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AddInvoiceResponse)
                return object;
            let message = new $root.lnrpc.AddInvoiceResponse();
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AddInvoiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.AddInvoiceResponse} message AddInvoiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddInvoiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
                object.paymentRequest = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
            }
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            return object;
        };

        /**
         * Converts this AddInvoiceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddInvoiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddInvoiceResponse;
    })();

    lnrpc.PaymentHash = (function() {

        /**
         * Properties of a PaymentHash.
         * @memberof lnrpc
         * @interface IPaymentHash
         * @property {string|null} [rHashStr] PaymentHash rHashStr
         * @property {Uint8Array|null} [rHash] PaymentHash rHash
         */

        /**
         * Constructs a new PaymentHash.
         * @memberof lnrpc
         * @classdesc Represents a PaymentHash.
         * @implements IPaymentHash
         * @constructor
         * @param {lnrpc.IPaymentHash=} [properties] Properties to set
         */
        function PaymentHash(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentHash rHashStr.
         * @member {string} rHashStr
         * @memberof lnrpc.PaymentHash
         * @instance
         */
        PaymentHash.prototype.rHashStr = "";

        /**
         * PaymentHash rHash.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.PaymentHash
         * @instance
         */
        PaymentHash.prototype.rHash = $util.newBuffer([]);

        /**
         * Creates a new PaymentHash instance using the specified properties.
         * @function create
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash=} [properties] Properties to set
         * @returns {lnrpc.PaymentHash} PaymentHash instance
         */
        PaymentHash.create = function create(properties) {
            return new PaymentHash(properties);
        };

        /**
         * Encodes the specified PaymentHash message. Does not implicitly {@link lnrpc.PaymentHash.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash} message PaymentHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentHash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rHashStr != null && Object.hasOwnProperty.call(message, "rHashStr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rHashStr);
            if (message.rHash != null && Object.hasOwnProperty.call(message, "rHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rHash);
            return writer;
        };

        /**
         * Encodes the specified PaymentHash message, length delimited. Does not implicitly {@link lnrpc.PaymentHash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash} message PaymentHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentHash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentHash message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PaymentHash} PaymentHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentHash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PaymentHash();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rHashStr = reader.string();
                    break;
                case 2:
                    message.rHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentHash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PaymentHash} PaymentHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentHash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentHash message.
         * @function verify
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentHash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                if (!$util.isString(message.rHashStr))
                    return "rHashStr: string expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            return null;
        };

        /**
         * Creates a PaymentHash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PaymentHash} PaymentHash
         */
        PaymentHash.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PaymentHash)
                return object;
            let message = new $root.lnrpc.PaymentHash();
            if (object.rHashStr != null)
                message.rHashStr = String(object.rHashStr);
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            return message;
        };

        /**
         * Creates a plain object from a PaymentHash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.PaymentHash} message PaymentHash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentHash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.rHashStr = "";
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
            }
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                object.rHashStr = message.rHashStr;
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            return object;
        };

        /**
         * Converts this PaymentHash to JSON.
         * @function toJSON
         * @memberof lnrpc.PaymentHash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentHash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaymentHash;
    })();

    lnrpc.ListInvoiceRequest = (function() {

        /**
         * Properties of a ListInvoiceRequest.
         * @memberof lnrpc
         * @interface IListInvoiceRequest
         * @property {boolean|null} [pendingOnly] ListInvoiceRequest pendingOnly
         * @property {number|Long|null} [indexOffset] ListInvoiceRequest indexOffset
         * @property {number|Long|null} [numMaxInvoices] ListInvoiceRequest numMaxInvoices
         * @property {boolean|null} [reversed] ListInvoiceRequest reversed
         */

        /**
         * Constructs a new ListInvoiceRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListInvoiceRequest.
         * @implements IListInvoiceRequest
         * @constructor
         * @param {lnrpc.IListInvoiceRequest=} [properties] Properties to set
         */
        function ListInvoiceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListInvoiceRequest pendingOnly.
         * @member {boolean} pendingOnly
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.pendingOnly = false;

        /**
         * ListInvoiceRequest indexOffset.
         * @member {number|Long} indexOffset
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.indexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ListInvoiceRequest numMaxInvoices.
         * @member {number|Long} numMaxInvoices
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.numMaxInvoices = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ListInvoiceRequest reversed.
         * @member {boolean} reversed
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.reversed = false;

        /**
         * Creates a new ListInvoiceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest=} [properties] Properties to set
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest instance
         */
        ListInvoiceRequest.create = function create(properties) {
            return new ListInvoiceRequest(properties);
        };

        /**
         * Encodes the specified ListInvoiceRequest message. Does not implicitly {@link lnrpc.ListInvoiceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest} message ListInvoiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pendingOnly != null && Object.hasOwnProperty.call(message, "pendingOnly"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.pendingOnly);
            if (message.indexOffset != null && Object.hasOwnProperty.call(message, "indexOffset"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.indexOffset);
            if (message.numMaxInvoices != null && Object.hasOwnProperty.call(message, "numMaxInvoices"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.numMaxInvoices);
            if (message.reversed != null && Object.hasOwnProperty.call(message, "reversed"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.reversed);
            return writer;
        };

        /**
         * Encodes the specified ListInvoiceRequest message, length delimited. Does not implicitly {@link lnrpc.ListInvoiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest} message ListInvoiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListInvoiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListInvoiceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pendingOnly = reader.bool();
                    break;
                case 4:
                    message.indexOffset = reader.uint64();
                    break;
                case 5:
                    message.numMaxInvoices = reader.uint64();
                    break;
                case 6:
                    message.reversed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListInvoiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListInvoiceRequest message.
         * @function verify
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListInvoiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                if (typeof message.pendingOnly !== "boolean")
                    return "pendingOnly: boolean expected";
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (!$util.isInteger(message.indexOffset) && !(message.indexOffset && $util.isInteger(message.indexOffset.low) && $util.isInteger(message.indexOffset.high)))
                    return "indexOffset: integer|Long expected";
            if (message.numMaxInvoices != null && message.hasOwnProperty("numMaxInvoices"))
                if (!$util.isInteger(message.numMaxInvoices) && !(message.numMaxInvoices && $util.isInteger(message.numMaxInvoices.low) && $util.isInteger(message.numMaxInvoices.high)))
                    return "numMaxInvoices: integer|Long expected";
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                if (typeof message.reversed !== "boolean")
                    return "reversed: boolean expected";
            return null;
        };

        /**
         * Creates a ListInvoiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         */
        ListInvoiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListInvoiceRequest)
                return object;
            let message = new $root.lnrpc.ListInvoiceRequest();
            if (object.pendingOnly != null)
                message.pendingOnly = Boolean(object.pendingOnly);
            if (object.indexOffset != null)
                if ($util.Long)
                    (message.indexOffset = $util.Long.fromValue(object.indexOffset)).unsigned = true;
                else if (typeof object.indexOffset === "string")
                    message.indexOffset = parseInt(object.indexOffset, 10);
                else if (typeof object.indexOffset === "number")
                    message.indexOffset = object.indexOffset;
                else if (typeof object.indexOffset === "object")
                    message.indexOffset = new $util.LongBits(object.indexOffset.low >>> 0, object.indexOffset.high >>> 0).toNumber(true);
            if (object.numMaxInvoices != null)
                if ($util.Long)
                    (message.numMaxInvoices = $util.Long.fromValue(object.numMaxInvoices)).unsigned = true;
                else if (typeof object.numMaxInvoices === "string")
                    message.numMaxInvoices = parseInt(object.numMaxInvoices, 10);
                else if (typeof object.numMaxInvoices === "number")
                    message.numMaxInvoices = object.numMaxInvoices;
                else if (typeof object.numMaxInvoices === "object")
                    message.numMaxInvoices = new $util.LongBits(object.numMaxInvoices.low >>> 0, object.numMaxInvoices.high >>> 0).toNumber(true);
            if (object.reversed != null)
                message.reversed = Boolean(object.reversed);
            return message;
        };

        /**
         * Creates a plain object from a ListInvoiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.ListInvoiceRequest} message ListInvoiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListInvoiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pendingOnly = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.indexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.indexOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.numMaxInvoices = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numMaxInvoices = options.longs === String ? "0" : 0;
                object.reversed = false;
            }
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                object.pendingOnly = message.pendingOnly;
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (typeof message.indexOffset === "number")
                    object.indexOffset = options.longs === String ? String(message.indexOffset) : message.indexOffset;
                else
                    object.indexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.indexOffset) : options.longs === Number ? new $util.LongBits(message.indexOffset.low >>> 0, message.indexOffset.high >>> 0).toNumber(true) : message.indexOffset;
            if (message.numMaxInvoices != null && message.hasOwnProperty("numMaxInvoices"))
                if (typeof message.numMaxInvoices === "number")
                    object.numMaxInvoices = options.longs === String ? String(message.numMaxInvoices) : message.numMaxInvoices;
                else
                    object.numMaxInvoices = options.longs === String ? $util.Long.prototype.toString.call(message.numMaxInvoices) : options.longs === Number ? new $util.LongBits(message.numMaxInvoices.low >>> 0, message.numMaxInvoices.high >>> 0).toNumber(true) : message.numMaxInvoices;
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                object.reversed = message.reversed;
            return object;
        };

        /**
         * Converts this ListInvoiceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListInvoiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListInvoiceRequest;
    })();

    lnrpc.ListInvoiceResponse = (function() {

        /**
         * Properties of a ListInvoiceResponse.
         * @memberof lnrpc
         * @interface IListInvoiceResponse
         * @property {Array.<lnrpc.IInvoice>|null} [invoices] ListInvoiceResponse invoices
         * @property {number|Long|null} [lastIndexOffset] ListInvoiceResponse lastIndexOffset
         * @property {number|Long|null} [firstIndexOffset] ListInvoiceResponse firstIndexOffset
         */

        /**
         * Constructs a new ListInvoiceResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListInvoiceResponse.
         * @implements IListInvoiceResponse
         * @constructor
         * @param {lnrpc.IListInvoiceResponse=} [properties] Properties to set
         */
        function ListInvoiceResponse(properties) {
            this.invoices = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListInvoiceResponse invoices.
         * @member {Array.<lnrpc.IInvoice>} invoices
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.invoices = $util.emptyArray;

        /**
         * ListInvoiceResponse lastIndexOffset.
         * @member {number|Long} lastIndexOffset
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.lastIndexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ListInvoiceResponse firstIndexOffset.
         * @member {number|Long} firstIndexOffset
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.firstIndexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ListInvoiceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse=} [properties] Properties to set
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse instance
         */
        ListInvoiceResponse.create = function create(properties) {
            return new ListInvoiceResponse(properties);
        };

        /**
         * Encodes the specified ListInvoiceResponse message. Does not implicitly {@link lnrpc.ListInvoiceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse} message ListInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invoices != null && message.invoices.length)
                for (let i = 0; i < message.invoices.length; ++i)
                    $root.lnrpc.Invoice.encode(message.invoices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lastIndexOffset != null && Object.hasOwnProperty.call(message, "lastIndexOffset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastIndexOffset);
            if (message.firstIndexOffset != null && Object.hasOwnProperty.call(message, "firstIndexOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.firstIndexOffset);
            return writer;
        };

        /**
         * Encodes the specified ListInvoiceResponse message, length delimited. Does not implicitly {@link lnrpc.ListInvoiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse} message ListInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListInvoiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListInvoiceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.invoices && message.invoices.length))
                        message.invoices = [];
                    message.invoices.push($root.lnrpc.Invoice.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastIndexOffset = reader.uint64();
                    break;
                case 3:
                    message.firstIndexOffset = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListInvoiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListInvoiceResponse message.
         * @function verify
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListInvoiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invoices != null && message.hasOwnProperty("invoices")) {
                if (!Array.isArray(message.invoices))
                    return "invoices: array expected";
                for (let i = 0; i < message.invoices.length; ++i) {
                    let error = $root.lnrpc.Invoice.verify(message.invoices[i]);
                    if (error)
                        return "invoices." + error;
                }
            }
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                if (!$util.isInteger(message.lastIndexOffset) && !(message.lastIndexOffset && $util.isInteger(message.lastIndexOffset.low) && $util.isInteger(message.lastIndexOffset.high)))
                    return "lastIndexOffset: integer|Long expected";
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                if (!$util.isInteger(message.firstIndexOffset) && !(message.firstIndexOffset && $util.isInteger(message.firstIndexOffset.low) && $util.isInteger(message.firstIndexOffset.high)))
                    return "firstIndexOffset: integer|Long expected";
            return null;
        };

        /**
         * Creates a ListInvoiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         */
        ListInvoiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListInvoiceResponse)
                return object;
            let message = new $root.lnrpc.ListInvoiceResponse();
            if (object.invoices) {
                if (!Array.isArray(object.invoices))
                    throw TypeError(".lnrpc.ListInvoiceResponse.invoices: array expected");
                message.invoices = [];
                for (let i = 0; i < object.invoices.length; ++i) {
                    if (typeof object.invoices[i] !== "object")
                        throw TypeError(".lnrpc.ListInvoiceResponse.invoices: object expected");
                    message.invoices[i] = $root.lnrpc.Invoice.fromObject(object.invoices[i]);
                }
            }
            if (object.lastIndexOffset != null)
                if ($util.Long)
                    (message.lastIndexOffset = $util.Long.fromValue(object.lastIndexOffset)).unsigned = true;
                else if (typeof object.lastIndexOffset === "string")
                    message.lastIndexOffset = parseInt(object.lastIndexOffset, 10);
                else if (typeof object.lastIndexOffset === "number")
                    message.lastIndexOffset = object.lastIndexOffset;
                else if (typeof object.lastIndexOffset === "object")
                    message.lastIndexOffset = new $util.LongBits(object.lastIndexOffset.low >>> 0, object.lastIndexOffset.high >>> 0).toNumber(true);
            if (object.firstIndexOffset != null)
                if ($util.Long)
                    (message.firstIndexOffset = $util.Long.fromValue(object.firstIndexOffset)).unsigned = true;
                else if (typeof object.firstIndexOffset === "string")
                    message.firstIndexOffset = parseInt(object.firstIndexOffset, 10);
                else if (typeof object.firstIndexOffset === "number")
                    message.firstIndexOffset = object.firstIndexOffset;
                else if (typeof object.firstIndexOffset === "object")
                    message.firstIndexOffset = new $util.LongBits(object.firstIndexOffset.low >>> 0, object.firstIndexOffset.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ListInvoiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.ListInvoiceResponse} message ListInvoiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListInvoiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.invoices = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lastIndexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastIndexOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.firstIndexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.firstIndexOffset = options.longs === String ? "0" : 0;
            }
            if (message.invoices && message.invoices.length) {
                object.invoices = [];
                for (let j = 0; j < message.invoices.length; ++j)
                    object.invoices[j] = $root.lnrpc.Invoice.toObject(message.invoices[j], options);
            }
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                if (typeof message.lastIndexOffset === "number")
                    object.lastIndexOffset = options.longs === String ? String(message.lastIndexOffset) : message.lastIndexOffset;
                else
                    object.lastIndexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.lastIndexOffset) : options.longs === Number ? new $util.LongBits(message.lastIndexOffset.low >>> 0, message.lastIndexOffset.high >>> 0).toNumber(true) : message.lastIndexOffset;
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                if (typeof message.firstIndexOffset === "number")
                    object.firstIndexOffset = options.longs === String ? String(message.firstIndexOffset) : message.firstIndexOffset;
                else
                    object.firstIndexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.firstIndexOffset) : options.longs === Number ? new $util.LongBits(message.firstIndexOffset.low >>> 0, message.firstIndexOffset.high >>> 0).toNumber(true) : message.firstIndexOffset;
            return object;
        };

        /**
         * Converts this ListInvoiceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListInvoiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListInvoiceResponse;
    })();

    lnrpc.InvoiceSubscription = (function() {

        /**
         * Properties of an InvoiceSubscription.
         * @memberof lnrpc
         * @interface IInvoiceSubscription
         * @property {number|Long|null} [addIndex] InvoiceSubscription addIndex
         * @property {number|Long|null} [settleIndex] InvoiceSubscription settleIndex
         */

        /**
         * Constructs a new InvoiceSubscription.
         * @memberof lnrpc
         * @classdesc Represents an InvoiceSubscription.
         * @implements IInvoiceSubscription
         * @constructor
         * @param {lnrpc.IInvoiceSubscription=} [properties] Properties to set
         */
        function InvoiceSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InvoiceSubscription addIndex.
         * @member {number|Long} addIndex
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         */
        InvoiceSubscription.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * InvoiceSubscription settleIndex.
         * @member {number|Long} settleIndex
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         */
        InvoiceSubscription.prototype.settleIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new InvoiceSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription=} [properties] Properties to set
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription instance
         */
        InvoiceSubscription.create = function create(properties) {
            return new InvoiceSubscription(properties);
        };

        /**
         * Encodes the specified InvoiceSubscription message. Does not implicitly {@link lnrpc.InvoiceSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription} message InvoiceSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addIndex != null && Object.hasOwnProperty.call(message, "addIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.addIndex);
            if (message.settleIndex != null && Object.hasOwnProperty.call(message, "settleIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.settleIndex);
            return writer;
        };

        /**
         * Encodes the specified InvoiceSubscription message, length delimited. Does not implicitly {@link lnrpc.InvoiceSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription} message InvoiceSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvoiceSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InvoiceSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addIndex = reader.uint64();
                    break;
                case 2:
                    message.settleIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvoiceSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvoiceSubscription message.
         * @function verify
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvoiceSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (!$util.isInteger(message.settleIndex) && !(message.settleIndex && $util.isInteger(message.settleIndex.low) && $util.isInteger(message.settleIndex.high)))
                    return "settleIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an InvoiceSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         */
        InvoiceSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InvoiceSubscription)
                return object;
            let message = new $root.lnrpc.InvoiceSubscription();
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            if (object.settleIndex != null)
                if ($util.Long)
                    (message.settleIndex = $util.Long.fromValue(object.settleIndex)).unsigned = true;
                else if (typeof object.settleIndex === "string")
                    message.settleIndex = parseInt(object.settleIndex, 10);
                else if (typeof object.settleIndex === "number")
                    message.settleIndex = object.settleIndex;
                else if (typeof object.settleIndex === "object")
                    message.settleIndex = new $util.LongBits(object.settleIndex.low >>> 0, object.settleIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an InvoiceSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.InvoiceSubscription} message InvoiceSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvoiceSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.settleIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleIndex = options.longs === String ? "0" : 0;
            }
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (typeof message.settleIndex === "number")
                    object.settleIndex = options.longs === String ? String(message.settleIndex) : message.settleIndex;
                else
                    object.settleIndex = options.longs === String ? $util.Long.prototype.toString.call(message.settleIndex) : options.longs === Number ? new $util.LongBits(message.settleIndex.low >>> 0, message.settleIndex.high >>> 0).toNumber(true) : message.settleIndex;
            return object;
        };

        /**
         * Converts this InvoiceSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvoiceSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvoiceSubscription;
    })();

    /**
     * PaymentFailureReason enum.
     * @name lnrpc.PaymentFailureReason
     * @enum {number}
     * @property {number} FAILURE_REASON_NONE=0 FAILURE_REASON_NONE value
     * @property {number} FAILURE_REASON_TIMEOUT=1 FAILURE_REASON_TIMEOUT value
     * @property {number} FAILURE_REASON_NO_ROUTE=2 FAILURE_REASON_NO_ROUTE value
     * @property {number} FAILURE_REASON_ERROR=3 FAILURE_REASON_ERROR value
     * @property {number} FAILURE_REASON_INCORRECT_PAYMENT_DETAILS=4 FAILURE_REASON_INCORRECT_PAYMENT_DETAILS value
     * @property {number} FAILURE_REASON_INSUFFICIENT_BALANCE=5 FAILURE_REASON_INSUFFICIENT_BALANCE value
     */
    lnrpc.PaymentFailureReason = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FAILURE_REASON_NONE"] = 0;
        values[valuesById[1] = "FAILURE_REASON_TIMEOUT"] = 1;
        values[valuesById[2] = "FAILURE_REASON_NO_ROUTE"] = 2;
        values[valuesById[3] = "FAILURE_REASON_ERROR"] = 3;
        values[valuesById[4] = "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS"] = 4;
        values[valuesById[5] = "FAILURE_REASON_INSUFFICIENT_BALANCE"] = 5;
        return values;
    })();

    lnrpc.Payment = (function() {

        /**
         * Properties of a Payment.
         * @memberof lnrpc
         * @interface IPayment
         * @property {string|null} [paymentHash] Payment paymentHash
         * @property {number|Long|null} [value] Payment value
         * @property {number|Long|null} [creationDate] Payment creationDate
         * @property {number|Long|null} [fee] Payment fee
         * @property {string|null} [paymentPreimage] Payment paymentPreimage
         * @property {number|Long|null} [valueSat] Payment valueSat
         * @property {number|Long|null} [valueMsat] Payment valueMsat
         * @property {string|null} [paymentRequest] Payment paymentRequest
         * @property {lnrpc.Payment.PaymentStatus|null} [status] Payment status
         * @property {number|Long|null} [feeSat] Payment feeSat
         * @property {number|Long|null} [feeMsat] Payment feeMsat
         * @property {number|Long|null} [creationTimeNs] Payment creationTimeNs
         * @property {Array.<lnrpc.IHTLCAttempt>|null} [htlcs] Payment htlcs
         * @property {number|Long|null} [paymentIndex] Payment paymentIndex
         * @property {lnrpc.PaymentFailureReason|null} [failureReason] Payment failureReason
         */

        /**
         * Constructs a new Payment.
         * @memberof lnrpc
         * @classdesc Represents a Payment.
         * @implements IPayment
         * @constructor
         * @param {lnrpc.IPayment=} [properties] Properties to set
         */
        function Payment(properties) {
            this.htlcs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payment paymentHash.
         * @member {string} paymentHash
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentHash = "";

        /**
         * Payment value.
         * @member {number|Long} value
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment creationDate.
         * @member {number|Long} creationDate
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.creationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment fee.
         * @member {number|Long} fee
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment paymentPreimage.
         * @member {string} paymentPreimage
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentPreimage = "";

        /**
         * Payment valueSat.
         * @member {number|Long} valueSat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.valueSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment valueMsat.
         * @member {number|Long} valueMsat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.valueMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment paymentRequest.
         * @member {string} paymentRequest
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentRequest = "";

        /**
         * Payment status.
         * @member {lnrpc.Payment.PaymentStatus} status
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.status = 0;

        /**
         * Payment feeSat.
         * @member {number|Long} feeSat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.feeSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment feeMsat.
         * @member {number|Long} feeMsat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment creationTimeNs.
         * @member {number|Long} creationTimeNs
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.creationTimeNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Payment htlcs.
         * @member {Array.<lnrpc.IHTLCAttempt>} htlcs
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.htlcs = $util.emptyArray;

        /**
         * Payment paymentIndex.
         * @member {number|Long} paymentIndex
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Payment failureReason.
         * @member {lnrpc.PaymentFailureReason} failureReason
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.failureReason = 0;

        /**
         * Creates a new Payment instance using the specified properties.
         * @function create
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment=} [properties] Properties to set
         * @returns {lnrpc.Payment} Payment instance
         */
        Payment.create = function create(properties) {
            return new Payment(properties);
        };

        /**
         * Encodes the specified Payment message. Does not implicitly {@link lnrpc.Payment.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentHash != null && Object.hasOwnProperty.call(message, "paymentHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.paymentHash);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
            if (message.creationDate != null && Object.hasOwnProperty.call(message, "creationDate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creationDate);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fee);
            if (message.paymentPreimage != null && Object.hasOwnProperty.call(message, "paymentPreimage"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.paymentPreimage);
            if (message.valueSat != null && Object.hasOwnProperty.call(message, "valueSat"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.valueSat);
            if (message.valueMsat != null && Object.hasOwnProperty.call(message, "valueMsat"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.valueMsat);
            if (message.paymentRequest != null && Object.hasOwnProperty.call(message, "paymentRequest"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.paymentRequest);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.status);
            if (message.feeSat != null && Object.hasOwnProperty.call(message, "feeSat"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.feeSat);
            if (message.feeMsat != null && Object.hasOwnProperty.call(message, "feeMsat"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.feeMsat);
            if (message.creationTimeNs != null && Object.hasOwnProperty.call(message, "creationTimeNs"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.creationTimeNs);
            if (message.htlcs != null && message.htlcs.length)
                for (let i = 0; i < message.htlcs.length; ++i)
                    $root.lnrpc.HTLCAttempt.encode(message.htlcs[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.paymentIndex != null && Object.hasOwnProperty.call(message, "paymentIndex"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.paymentIndex);
            if (message.failureReason != null && Object.hasOwnProperty.call(message, "failureReason"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.failureReason);
            return writer;
        };

        /**
         * Encodes the specified Payment message, length delimited. Does not implicitly {@link lnrpc.Payment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payment message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Payment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentHash = reader.string();
                    break;
                case 2:
                    message.value = reader.int64();
                    break;
                case 3:
                    message.creationDate = reader.int64();
                    break;
                case 5:
                    message.fee = reader.int64();
                    break;
                case 6:
                    message.paymentPreimage = reader.string();
                    break;
                case 7:
                    message.valueSat = reader.int64();
                    break;
                case 8:
                    message.valueMsat = reader.int64();
                    break;
                case 9:
                    message.paymentRequest = reader.string();
                    break;
                case 10:
                    message.status = reader.int32();
                    break;
                case 11:
                    message.feeSat = reader.int64();
                    break;
                case 12:
                    message.feeMsat = reader.int64();
                    break;
                case 13:
                    message.creationTimeNs = reader.int64();
                    break;
                case 14:
                    if (!(message.htlcs && message.htlcs.length))
                        message.htlcs = [];
                    message.htlcs.push($root.lnrpc.HTLCAttempt.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.paymentIndex = reader.uint64();
                    break;
                case 16:
                    message.failureReason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payment message.
         * @function verify
         * @memberof lnrpc.Payment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!$util.isString(message.paymentHash))
                    return "paymentHash: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (!$util.isInteger(message.creationDate) && !(message.creationDate && $util.isInteger(message.creationDate.low) && $util.isInteger(message.creationDate.high)))
                    return "creationDate: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                if (!$util.isString(message.paymentPreimage))
                    return "paymentPreimage: string expected";
            if (message.valueSat != null && message.hasOwnProperty("valueSat"))
                if (!$util.isInteger(message.valueSat) && !(message.valueSat && $util.isInteger(message.valueSat.low) && $util.isInteger(message.valueSat.high)))
                    return "valueSat: integer|Long expected";
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                if (!$util.isInteger(message.valueMsat) && !(message.valueMsat && $util.isInteger(message.valueMsat.low) && $util.isInteger(message.valueMsat.high)))
                    return "valueMsat: integer|Long expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (!$util.isInteger(message.feeSat) && !(message.feeSat && $util.isInteger(message.feeSat.low) && $util.isInteger(message.feeSat.high)))
                    return "feeSat: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            if (message.creationTimeNs != null && message.hasOwnProperty("creationTimeNs"))
                if (!$util.isInteger(message.creationTimeNs) && !(message.creationTimeNs && $util.isInteger(message.creationTimeNs.low) && $util.isInteger(message.creationTimeNs.high)))
                    return "creationTimeNs: integer|Long expected";
            if (message.htlcs != null && message.hasOwnProperty("htlcs")) {
                if (!Array.isArray(message.htlcs))
                    return "htlcs: array expected";
                for (let i = 0; i < message.htlcs.length; ++i) {
                    let error = $root.lnrpc.HTLCAttempt.verify(message.htlcs[i]);
                    if (error)
                        return "htlcs." + error;
                }
            }
            if (message.paymentIndex != null && message.hasOwnProperty("paymentIndex"))
                if (!$util.isInteger(message.paymentIndex) && !(message.paymentIndex && $util.isInteger(message.paymentIndex.low) && $util.isInteger(message.paymentIndex.high)))
                    return "paymentIndex: integer|Long expected";
            if (message.failureReason != null && message.hasOwnProperty("failureReason"))
                switch (message.failureReason) {
                default:
                    return "failureReason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a Payment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Payment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Payment} Payment
         */
        Payment.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Payment)
                return object;
            let message = new $root.lnrpc.Payment();
            if (object.paymentHash != null)
                message.paymentHash = String(object.paymentHash);
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.creationDate != null)
                if ($util.Long)
                    (message.creationDate = $util.Long.fromValue(object.creationDate)).unsigned = false;
                else if (typeof object.creationDate === "string")
                    message.creationDate = parseInt(object.creationDate, 10);
                else if (typeof object.creationDate === "number")
                    message.creationDate = object.creationDate;
                else if (typeof object.creationDate === "object")
                    message.creationDate = new $util.LongBits(object.creationDate.low >>> 0, object.creationDate.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.paymentPreimage != null)
                message.paymentPreimage = String(object.paymentPreimage);
            if (object.valueSat != null)
                if ($util.Long)
                    (message.valueSat = $util.Long.fromValue(object.valueSat)).unsigned = false;
                else if (typeof object.valueSat === "string")
                    message.valueSat = parseInt(object.valueSat, 10);
                else if (typeof object.valueSat === "number")
                    message.valueSat = object.valueSat;
                else if (typeof object.valueSat === "object")
                    message.valueSat = new $util.LongBits(object.valueSat.low >>> 0, object.valueSat.high >>> 0).toNumber();
            if (object.valueMsat != null)
                if ($util.Long)
                    (message.valueMsat = $util.Long.fromValue(object.valueMsat)).unsigned = false;
                else if (typeof object.valueMsat === "string")
                    message.valueMsat = parseInt(object.valueMsat, 10);
                else if (typeof object.valueMsat === "number")
                    message.valueMsat = object.valueMsat;
                else if (typeof object.valueMsat === "object")
                    message.valueMsat = new $util.LongBits(object.valueMsat.low >>> 0, object.valueMsat.high >>> 0).toNumber();
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "IN_FLIGHT":
            case 1:
                message.status = 1;
                break;
            case "SUCCEEDED":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            }
            if (object.feeSat != null)
                if ($util.Long)
                    (message.feeSat = $util.Long.fromValue(object.feeSat)).unsigned = false;
                else if (typeof object.feeSat === "string")
                    message.feeSat = parseInt(object.feeSat, 10);
                else if (typeof object.feeSat === "number")
                    message.feeSat = object.feeSat;
                else if (typeof object.feeSat === "object")
                    message.feeSat = new $util.LongBits(object.feeSat.low >>> 0, object.feeSat.high >>> 0).toNumber();
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = false;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber();
            if (object.creationTimeNs != null)
                if ($util.Long)
                    (message.creationTimeNs = $util.Long.fromValue(object.creationTimeNs)).unsigned = false;
                else if (typeof object.creationTimeNs === "string")
                    message.creationTimeNs = parseInt(object.creationTimeNs, 10);
                else if (typeof object.creationTimeNs === "number")
                    message.creationTimeNs = object.creationTimeNs;
                else if (typeof object.creationTimeNs === "object")
                    message.creationTimeNs = new $util.LongBits(object.creationTimeNs.low >>> 0, object.creationTimeNs.high >>> 0).toNumber();
            if (object.htlcs) {
                if (!Array.isArray(object.htlcs))
                    throw TypeError(".lnrpc.Payment.htlcs: array expected");
                message.htlcs = [];
                for (let i = 0; i < object.htlcs.length; ++i) {
                    if (typeof object.htlcs[i] !== "object")
                        throw TypeError(".lnrpc.Payment.htlcs: object expected");
                    message.htlcs[i] = $root.lnrpc.HTLCAttempt.fromObject(object.htlcs[i]);
                }
            }
            if (object.paymentIndex != null)
                if ($util.Long)
                    (message.paymentIndex = $util.Long.fromValue(object.paymentIndex)).unsigned = true;
                else if (typeof object.paymentIndex === "string")
                    message.paymentIndex = parseInt(object.paymentIndex, 10);
                else if (typeof object.paymentIndex === "number")
                    message.paymentIndex = object.paymentIndex;
                else if (typeof object.paymentIndex === "object")
                    message.paymentIndex = new $util.LongBits(object.paymentIndex.low >>> 0, object.paymentIndex.high >>> 0).toNumber(true);
            switch (object.failureReason) {
            case "FAILURE_REASON_NONE":
            case 0:
                message.failureReason = 0;
                break;
            case "FAILURE_REASON_TIMEOUT":
            case 1:
                message.failureReason = 1;
                break;
            case "FAILURE_REASON_NO_ROUTE":
            case 2:
                message.failureReason = 2;
                break;
            case "FAILURE_REASON_ERROR":
            case 3:
                message.failureReason = 3;
                break;
            case "FAILURE_REASON_INCORRECT_PAYMENT_DETAILS":
            case 4:
                message.failureReason = 4;
                break;
            case "FAILURE_REASON_INSUFFICIENT_BALANCE":
            case 5:
                message.failureReason = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Payment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.Payment} message Payment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.htlcs = [];
            if (options.defaults) {
                object.paymentHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.paymentPreimage = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.valueSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.valueSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.valueMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.valueMsat = options.longs === String ? "0" : 0;
                object.paymentRequest = "";
                object.status = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creationTimeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationTimeNs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.paymentIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.paymentIndex = options.longs === String ? "0" : 0;
                object.failureReason = options.enums === String ? "FAILURE_REASON_NONE" : 0;
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = message.paymentHash;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (typeof message.creationDate === "number")
                    object.creationDate = options.longs === String ? String(message.creationDate) : message.creationDate;
                else
                    object.creationDate = options.longs === String ? $util.Long.prototype.toString.call(message.creationDate) : options.longs === Number ? new $util.LongBits(message.creationDate.low >>> 0, message.creationDate.high >>> 0).toNumber() : message.creationDate;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                object.paymentPreimage = message.paymentPreimage;
            if (message.valueSat != null && message.hasOwnProperty("valueSat"))
                if (typeof message.valueSat === "number")
                    object.valueSat = options.longs === String ? String(message.valueSat) : message.valueSat;
                else
                    object.valueSat = options.longs === String ? $util.Long.prototype.toString.call(message.valueSat) : options.longs === Number ? new $util.LongBits(message.valueSat.low >>> 0, message.valueSat.high >>> 0).toNumber() : message.valueSat;
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                if (typeof message.valueMsat === "number")
                    object.valueMsat = options.longs === String ? String(message.valueMsat) : message.valueMsat;
                else
                    object.valueMsat = options.longs === String ? $util.Long.prototype.toString.call(message.valueMsat) : options.longs === Number ? new $util.LongBits(message.valueMsat.low >>> 0, message.valueMsat.high >>> 0).toNumber() : message.valueMsat;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.lnrpc.Payment.PaymentStatus[message.status] : message.status;
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (typeof message.feeSat === "number")
                    object.feeSat = options.longs === String ? String(message.feeSat) : message.feeSat;
                else
                    object.feeSat = options.longs === String ? $util.Long.prototype.toString.call(message.feeSat) : options.longs === Number ? new $util.LongBits(message.feeSat.low >>> 0, message.feeSat.high >>> 0).toNumber() : message.feeSat;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber() : message.feeMsat;
            if (message.creationTimeNs != null && message.hasOwnProperty("creationTimeNs"))
                if (typeof message.creationTimeNs === "number")
                    object.creationTimeNs = options.longs === String ? String(message.creationTimeNs) : message.creationTimeNs;
                else
                    object.creationTimeNs = options.longs === String ? $util.Long.prototype.toString.call(message.creationTimeNs) : options.longs === Number ? new $util.LongBits(message.creationTimeNs.low >>> 0, message.creationTimeNs.high >>> 0).toNumber() : message.creationTimeNs;
            if (message.htlcs && message.htlcs.length) {
                object.htlcs = [];
                for (let j = 0; j < message.htlcs.length; ++j)
                    object.htlcs[j] = $root.lnrpc.HTLCAttempt.toObject(message.htlcs[j], options);
            }
            if (message.paymentIndex != null && message.hasOwnProperty("paymentIndex"))
                if (typeof message.paymentIndex === "number")
                    object.paymentIndex = options.longs === String ? String(message.paymentIndex) : message.paymentIndex;
                else
                    object.paymentIndex = options.longs === String ? $util.Long.prototype.toString.call(message.paymentIndex) : options.longs === Number ? new $util.LongBits(message.paymentIndex.low >>> 0, message.paymentIndex.high >>> 0).toNumber(true) : message.paymentIndex;
            if (message.failureReason != null && message.hasOwnProperty("failureReason"))
                object.failureReason = options.enums === String ? $root.lnrpc.PaymentFailureReason[message.failureReason] : message.failureReason;
            return object;
        };

        /**
         * Converts this Payment to JSON.
         * @function toJSON
         * @memberof lnrpc.Payment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PaymentStatus enum.
         * @name lnrpc.Payment.PaymentStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} IN_FLIGHT=1 IN_FLIGHT value
         * @property {number} SUCCEEDED=2 SUCCEEDED value
         * @property {number} FAILED=3 FAILED value
         */
        Payment.PaymentStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "IN_FLIGHT"] = 1;
            values[valuesById[2] = "SUCCEEDED"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            return values;
        })();

        return Payment;
    })();

    lnrpc.HTLCAttempt = (function() {

        /**
         * Properties of a HTLCAttempt.
         * @memberof lnrpc
         * @interface IHTLCAttempt
         * @property {lnrpc.HTLCAttempt.HTLCStatus|null} [status] HTLCAttempt status
         * @property {lnrpc.IRoute|null} [route] HTLCAttempt route
         * @property {number|Long|null} [attemptTimeNs] HTLCAttempt attemptTimeNs
         * @property {number|Long|null} [resolveTimeNs] HTLCAttempt resolveTimeNs
         * @property {lnrpc.IFailure|null} [failure] HTLCAttempt failure
         * @property {Uint8Array|null} [preimage] HTLCAttempt preimage
         */

        /**
         * Constructs a new HTLCAttempt.
         * @memberof lnrpc
         * @classdesc Represents a HTLCAttempt.
         * @implements IHTLCAttempt
         * @constructor
         * @param {lnrpc.IHTLCAttempt=} [properties] Properties to set
         */
        function HTLCAttempt(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HTLCAttempt status.
         * @member {lnrpc.HTLCAttempt.HTLCStatus} status
         * @memberof lnrpc.HTLCAttempt
         * @instance
         */
        HTLCAttempt.prototype.status = 0;

        /**
         * HTLCAttempt route.
         * @member {lnrpc.IRoute|null|undefined} route
         * @memberof lnrpc.HTLCAttempt
         * @instance
         */
        HTLCAttempt.prototype.route = null;

        /**
         * HTLCAttempt attemptTimeNs.
         * @member {number|Long} attemptTimeNs
         * @memberof lnrpc.HTLCAttempt
         * @instance
         */
        HTLCAttempt.prototype.attemptTimeNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HTLCAttempt resolveTimeNs.
         * @member {number|Long} resolveTimeNs
         * @memberof lnrpc.HTLCAttempt
         * @instance
         */
        HTLCAttempt.prototype.resolveTimeNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HTLCAttempt failure.
         * @member {lnrpc.IFailure|null|undefined} failure
         * @memberof lnrpc.HTLCAttempt
         * @instance
         */
        HTLCAttempt.prototype.failure = null;

        /**
         * HTLCAttempt preimage.
         * @member {Uint8Array} preimage
         * @memberof lnrpc.HTLCAttempt
         * @instance
         */
        HTLCAttempt.prototype.preimage = $util.newBuffer([]);

        /**
         * Creates a new HTLCAttempt instance using the specified properties.
         * @function create
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {lnrpc.IHTLCAttempt=} [properties] Properties to set
         * @returns {lnrpc.HTLCAttempt} HTLCAttempt instance
         */
        HTLCAttempt.create = function create(properties) {
            return new HTLCAttempt(properties);
        };

        /**
         * Encodes the specified HTLCAttempt message. Does not implicitly {@link lnrpc.HTLCAttempt.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {lnrpc.IHTLCAttempt} message HTLCAttempt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLCAttempt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.route != null && Object.hasOwnProperty.call(message, "route"))
                $root.lnrpc.Route.encode(message.route, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.attemptTimeNs != null && Object.hasOwnProperty.call(message, "attemptTimeNs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.attemptTimeNs);
            if (message.resolveTimeNs != null && Object.hasOwnProperty.call(message, "resolveTimeNs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.resolveTimeNs);
            if (message.failure != null && Object.hasOwnProperty.call(message, "failure"))
                $root.lnrpc.Failure.encode(message.failure, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.preimage != null && Object.hasOwnProperty.call(message, "preimage"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.preimage);
            return writer;
        };

        /**
         * Encodes the specified HTLCAttempt message, length delimited. Does not implicitly {@link lnrpc.HTLCAttempt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {lnrpc.IHTLCAttempt} message HTLCAttempt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLCAttempt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HTLCAttempt message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HTLCAttempt} HTLCAttempt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLCAttempt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HTLCAttempt();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.route = $root.lnrpc.Route.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.attemptTimeNs = reader.int64();
                    break;
                case 4:
                    message.resolveTimeNs = reader.int64();
                    break;
                case 5:
                    message.failure = $root.lnrpc.Failure.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.preimage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HTLCAttempt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HTLCAttempt} HTLCAttempt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLCAttempt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HTLCAttempt message.
         * @function verify
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HTLCAttempt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.route != null && message.hasOwnProperty("route")) {
                let error = $root.lnrpc.Route.verify(message.route);
                if (error)
                    return "route." + error;
            }
            if (message.attemptTimeNs != null && message.hasOwnProperty("attemptTimeNs"))
                if (!$util.isInteger(message.attemptTimeNs) && !(message.attemptTimeNs && $util.isInteger(message.attemptTimeNs.low) && $util.isInteger(message.attemptTimeNs.high)))
                    return "attemptTimeNs: integer|Long expected";
            if (message.resolveTimeNs != null && message.hasOwnProperty("resolveTimeNs"))
                if (!$util.isInteger(message.resolveTimeNs) && !(message.resolveTimeNs && $util.isInteger(message.resolveTimeNs.low) && $util.isInteger(message.resolveTimeNs.high)))
                    return "resolveTimeNs: integer|Long expected";
            if (message.failure != null && message.hasOwnProperty("failure")) {
                let error = $root.lnrpc.Failure.verify(message.failure);
                if (error)
                    return "failure." + error;
            }
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                if (!(message.preimage && typeof message.preimage.length === "number" || $util.isString(message.preimage)))
                    return "preimage: buffer expected";
            return null;
        };

        /**
         * Creates a HTLCAttempt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HTLCAttempt} HTLCAttempt
         */
        HTLCAttempt.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HTLCAttempt)
                return object;
            let message = new $root.lnrpc.HTLCAttempt();
            switch (object.status) {
            case "IN_FLIGHT":
            case 0:
                message.status = 0;
                break;
            case "SUCCEEDED":
            case 1:
                message.status = 1;
                break;
            case "FAILED":
            case 2:
                message.status = 2;
                break;
            }
            if (object.route != null) {
                if (typeof object.route !== "object")
                    throw TypeError(".lnrpc.HTLCAttempt.route: object expected");
                message.route = $root.lnrpc.Route.fromObject(object.route);
            }
            if (object.attemptTimeNs != null)
                if ($util.Long)
                    (message.attemptTimeNs = $util.Long.fromValue(object.attemptTimeNs)).unsigned = false;
                else if (typeof object.attemptTimeNs === "string")
                    message.attemptTimeNs = parseInt(object.attemptTimeNs, 10);
                else if (typeof object.attemptTimeNs === "number")
                    message.attemptTimeNs = object.attemptTimeNs;
                else if (typeof object.attemptTimeNs === "object")
                    message.attemptTimeNs = new $util.LongBits(object.attemptTimeNs.low >>> 0, object.attemptTimeNs.high >>> 0).toNumber();
            if (object.resolveTimeNs != null)
                if ($util.Long)
                    (message.resolveTimeNs = $util.Long.fromValue(object.resolveTimeNs)).unsigned = false;
                else if (typeof object.resolveTimeNs === "string")
                    message.resolveTimeNs = parseInt(object.resolveTimeNs, 10);
                else if (typeof object.resolveTimeNs === "number")
                    message.resolveTimeNs = object.resolveTimeNs;
                else if (typeof object.resolveTimeNs === "object")
                    message.resolveTimeNs = new $util.LongBits(object.resolveTimeNs.low >>> 0, object.resolveTimeNs.high >>> 0).toNumber();
            if (object.failure != null) {
                if (typeof object.failure !== "object")
                    throw TypeError(".lnrpc.HTLCAttempt.failure: object expected");
                message.failure = $root.lnrpc.Failure.fromObject(object.failure);
            }
            if (object.preimage != null)
                if (typeof object.preimage === "string")
                    $util.base64.decode(object.preimage, message.preimage = $util.newBuffer($util.base64.length(object.preimage)), 0);
                else if (object.preimage.length)
                    message.preimage = object.preimage;
            return message;
        };

        /**
         * Creates a plain object from a HTLCAttempt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HTLCAttempt
         * @static
         * @param {lnrpc.HTLCAttempt} message HTLCAttempt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HTLCAttempt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "IN_FLIGHT" : 0;
                object.route = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.attemptTimeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.attemptTimeNs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.resolveTimeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resolveTimeNs = options.longs === String ? "0" : 0;
                object.failure = null;
                if (options.bytes === String)
                    object.preimage = "";
                else {
                    object.preimage = [];
                    if (options.bytes !== Array)
                        object.preimage = $util.newBuffer(object.preimage);
                }
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.lnrpc.HTLCAttempt.HTLCStatus[message.status] : message.status;
            if (message.route != null && message.hasOwnProperty("route"))
                object.route = $root.lnrpc.Route.toObject(message.route, options);
            if (message.attemptTimeNs != null && message.hasOwnProperty("attemptTimeNs"))
                if (typeof message.attemptTimeNs === "number")
                    object.attemptTimeNs = options.longs === String ? String(message.attemptTimeNs) : message.attemptTimeNs;
                else
                    object.attemptTimeNs = options.longs === String ? $util.Long.prototype.toString.call(message.attemptTimeNs) : options.longs === Number ? new $util.LongBits(message.attemptTimeNs.low >>> 0, message.attemptTimeNs.high >>> 0).toNumber() : message.attemptTimeNs;
            if (message.resolveTimeNs != null && message.hasOwnProperty("resolveTimeNs"))
                if (typeof message.resolveTimeNs === "number")
                    object.resolveTimeNs = options.longs === String ? String(message.resolveTimeNs) : message.resolveTimeNs;
                else
                    object.resolveTimeNs = options.longs === String ? $util.Long.prototype.toString.call(message.resolveTimeNs) : options.longs === Number ? new $util.LongBits(message.resolveTimeNs.low >>> 0, message.resolveTimeNs.high >>> 0).toNumber() : message.resolveTimeNs;
            if (message.failure != null && message.hasOwnProperty("failure"))
                object.failure = $root.lnrpc.Failure.toObject(message.failure, options);
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                object.preimage = options.bytes === String ? $util.base64.encode(message.preimage, 0, message.preimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimage) : message.preimage;
            return object;
        };

        /**
         * Converts this HTLCAttempt to JSON.
         * @function toJSON
         * @memberof lnrpc.HTLCAttempt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HTLCAttempt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * HTLCStatus enum.
         * @name lnrpc.HTLCAttempt.HTLCStatus
         * @enum {number}
         * @property {number} IN_FLIGHT=0 IN_FLIGHT value
         * @property {number} SUCCEEDED=1 SUCCEEDED value
         * @property {number} FAILED=2 FAILED value
         */
        HTLCAttempt.HTLCStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IN_FLIGHT"] = 0;
            values[valuesById[1] = "SUCCEEDED"] = 1;
            values[valuesById[2] = "FAILED"] = 2;
            return values;
        })();

        return HTLCAttempt;
    })();

    lnrpc.ListPaymentsRequest = (function() {

        /**
         * Properties of a ListPaymentsRequest.
         * @memberof lnrpc
         * @interface IListPaymentsRequest
         * @property {boolean|null} [includeIncomplete] ListPaymentsRequest includeIncomplete
         * @property {number|Long|null} [indexOffset] ListPaymentsRequest indexOffset
         * @property {number|Long|null} [maxPayments] ListPaymentsRequest maxPayments
         * @property {boolean|null} [reversed] ListPaymentsRequest reversed
         */

        /**
         * Constructs a new ListPaymentsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPaymentsRequest.
         * @implements IListPaymentsRequest
         * @constructor
         * @param {lnrpc.IListPaymentsRequest=} [properties] Properties to set
         */
        function ListPaymentsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPaymentsRequest includeIncomplete.
         * @member {boolean} includeIncomplete
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         */
        ListPaymentsRequest.prototype.includeIncomplete = false;

        /**
         * ListPaymentsRequest indexOffset.
         * @member {number|Long} indexOffset
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         */
        ListPaymentsRequest.prototype.indexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ListPaymentsRequest maxPayments.
         * @member {number|Long} maxPayments
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         */
        ListPaymentsRequest.prototype.maxPayments = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ListPaymentsRequest reversed.
         * @member {boolean} reversed
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         */
        ListPaymentsRequest.prototype.reversed = false;

        /**
         * Creates a new ListPaymentsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest instance
         */
        ListPaymentsRequest.create = function create(properties) {
            return new ListPaymentsRequest(properties);
        };

        /**
         * Encodes the specified ListPaymentsRequest message. Does not implicitly {@link lnrpc.ListPaymentsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest} message ListPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.includeIncomplete != null && Object.hasOwnProperty.call(message, "includeIncomplete"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeIncomplete);
            if (message.indexOffset != null && Object.hasOwnProperty.call(message, "indexOffset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.indexOffset);
            if (message.maxPayments != null && Object.hasOwnProperty.call(message, "maxPayments"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.maxPayments);
            if (message.reversed != null && Object.hasOwnProperty.call(message, "reversed"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.reversed);
            return writer;
        };

        /**
         * Encodes the specified ListPaymentsRequest message, length delimited. Does not implicitly {@link lnrpc.ListPaymentsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest} message ListPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPaymentsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPaymentsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.includeIncomplete = reader.bool();
                    break;
                case 2:
                    message.indexOffset = reader.uint64();
                    break;
                case 3:
                    message.maxPayments = reader.uint64();
                    break;
                case 4:
                    message.reversed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPaymentsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPaymentsRequest message.
         * @function verify
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPaymentsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.includeIncomplete != null && message.hasOwnProperty("includeIncomplete"))
                if (typeof message.includeIncomplete !== "boolean")
                    return "includeIncomplete: boolean expected";
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (!$util.isInteger(message.indexOffset) && !(message.indexOffset && $util.isInteger(message.indexOffset.low) && $util.isInteger(message.indexOffset.high)))
                    return "indexOffset: integer|Long expected";
            if (message.maxPayments != null && message.hasOwnProperty("maxPayments"))
                if (!$util.isInteger(message.maxPayments) && !(message.maxPayments && $util.isInteger(message.maxPayments.low) && $util.isInteger(message.maxPayments.high)))
                    return "maxPayments: integer|Long expected";
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                if (typeof message.reversed !== "boolean")
                    return "reversed: boolean expected";
            return null;
        };

        /**
         * Creates a ListPaymentsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         */
        ListPaymentsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPaymentsRequest)
                return object;
            let message = new $root.lnrpc.ListPaymentsRequest();
            if (object.includeIncomplete != null)
                message.includeIncomplete = Boolean(object.includeIncomplete);
            if (object.indexOffset != null)
                if ($util.Long)
                    (message.indexOffset = $util.Long.fromValue(object.indexOffset)).unsigned = true;
                else if (typeof object.indexOffset === "string")
                    message.indexOffset = parseInt(object.indexOffset, 10);
                else if (typeof object.indexOffset === "number")
                    message.indexOffset = object.indexOffset;
                else if (typeof object.indexOffset === "object")
                    message.indexOffset = new $util.LongBits(object.indexOffset.low >>> 0, object.indexOffset.high >>> 0).toNumber(true);
            if (object.maxPayments != null)
                if ($util.Long)
                    (message.maxPayments = $util.Long.fromValue(object.maxPayments)).unsigned = true;
                else if (typeof object.maxPayments === "string")
                    message.maxPayments = parseInt(object.maxPayments, 10);
                else if (typeof object.maxPayments === "number")
                    message.maxPayments = object.maxPayments;
                else if (typeof object.maxPayments === "object")
                    message.maxPayments = new $util.LongBits(object.maxPayments.low >>> 0, object.maxPayments.high >>> 0).toNumber(true);
            if (object.reversed != null)
                message.reversed = Boolean(object.reversed);
            return message;
        };

        /**
         * Creates a plain object from a ListPaymentsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.ListPaymentsRequest} message ListPaymentsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPaymentsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.includeIncomplete = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.indexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.indexOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxPayments = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxPayments = options.longs === String ? "0" : 0;
                object.reversed = false;
            }
            if (message.includeIncomplete != null && message.hasOwnProperty("includeIncomplete"))
                object.includeIncomplete = message.includeIncomplete;
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (typeof message.indexOffset === "number")
                    object.indexOffset = options.longs === String ? String(message.indexOffset) : message.indexOffset;
                else
                    object.indexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.indexOffset) : options.longs === Number ? new $util.LongBits(message.indexOffset.low >>> 0, message.indexOffset.high >>> 0).toNumber(true) : message.indexOffset;
            if (message.maxPayments != null && message.hasOwnProperty("maxPayments"))
                if (typeof message.maxPayments === "number")
                    object.maxPayments = options.longs === String ? String(message.maxPayments) : message.maxPayments;
                else
                    object.maxPayments = options.longs === String ? $util.Long.prototype.toString.call(message.maxPayments) : options.longs === Number ? new $util.LongBits(message.maxPayments.low >>> 0, message.maxPayments.high >>> 0).toNumber(true) : message.maxPayments;
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                object.reversed = message.reversed;
            return object;
        };

        /**
         * Converts this ListPaymentsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPaymentsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPaymentsRequest;
    })();

    lnrpc.ListPaymentsResponse = (function() {

        /**
         * Properties of a ListPaymentsResponse.
         * @memberof lnrpc
         * @interface IListPaymentsResponse
         * @property {Array.<lnrpc.IPayment>|null} [payments] ListPaymentsResponse payments
         * @property {number|Long|null} [firstIndexOffset] ListPaymentsResponse firstIndexOffset
         * @property {number|Long|null} [lastIndexOffset] ListPaymentsResponse lastIndexOffset
         */

        /**
         * Constructs a new ListPaymentsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPaymentsResponse.
         * @implements IListPaymentsResponse
         * @constructor
         * @param {lnrpc.IListPaymentsResponse=} [properties] Properties to set
         */
        function ListPaymentsResponse(properties) {
            this.payments = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPaymentsResponse payments.
         * @member {Array.<lnrpc.IPayment>} payments
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         */
        ListPaymentsResponse.prototype.payments = $util.emptyArray;

        /**
         * ListPaymentsResponse firstIndexOffset.
         * @member {number|Long} firstIndexOffset
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         */
        ListPaymentsResponse.prototype.firstIndexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ListPaymentsResponse lastIndexOffset.
         * @member {number|Long} lastIndexOffset
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         */
        ListPaymentsResponse.prototype.lastIndexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ListPaymentsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse instance
         */
        ListPaymentsResponse.create = function create(properties) {
            return new ListPaymentsResponse(properties);
        };

        /**
         * Encodes the specified ListPaymentsResponse message. Does not implicitly {@link lnrpc.ListPaymentsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse} message ListPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payments != null && message.payments.length)
                for (let i = 0; i < message.payments.length; ++i)
                    $root.lnrpc.Payment.encode(message.payments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.firstIndexOffset != null && Object.hasOwnProperty.call(message, "firstIndexOffset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.firstIndexOffset);
            if (message.lastIndexOffset != null && Object.hasOwnProperty.call(message, "lastIndexOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.lastIndexOffset);
            return writer;
        };

        /**
         * Encodes the specified ListPaymentsResponse message, length delimited. Does not implicitly {@link lnrpc.ListPaymentsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse} message ListPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPaymentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPaymentsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.payments && message.payments.length))
                        message.payments = [];
                    message.payments.push($root.lnrpc.Payment.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.firstIndexOffset = reader.uint64();
                    break;
                case 3:
                    message.lastIndexOffset = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPaymentsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPaymentsResponse message.
         * @function verify
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPaymentsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payments != null && message.hasOwnProperty("payments")) {
                if (!Array.isArray(message.payments))
                    return "payments: array expected";
                for (let i = 0; i < message.payments.length; ++i) {
                    let error = $root.lnrpc.Payment.verify(message.payments[i]);
                    if (error)
                        return "payments." + error;
                }
            }
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                if (!$util.isInteger(message.firstIndexOffset) && !(message.firstIndexOffset && $util.isInteger(message.firstIndexOffset.low) && $util.isInteger(message.firstIndexOffset.high)))
                    return "firstIndexOffset: integer|Long expected";
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                if (!$util.isInteger(message.lastIndexOffset) && !(message.lastIndexOffset && $util.isInteger(message.lastIndexOffset.low) && $util.isInteger(message.lastIndexOffset.high)))
                    return "lastIndexOffset: integer|Long expected";
            return null;
        };

        /**
         * Creates a ListPaymentsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         */
        ListPaymentsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPaymentsResponse)
                return object;
            let message = new $root.lnrpc.ListPaymentsResponse();
            if (object.payments) {
                if (!Array.isArray(object.payments))
                    throw TypeError(".lnrpc.ListPaymentsResponse.payments: array expected");
                message.payments = [];
                for (let i = 0; i < object.payments.length; ++i) {
                    if (typeof object.payments[i] !== "object")
                        throw TypeError(".lnrpc.ListPaymentsResponse.payments: object expected");
                    message.payments[i] = $root.lnrpc.Payment.fromObject(object.payments[i]);
                }
            }
            if (object.firstIndexOffset != null)
                if ($util.Long)
                    (message.firstIndexOffset = $util.Long.fromValue(object.firstIndexOffset)).unsigned = true;
                else if (typeof object.firstIndexOffset === "string")
                    message.firstIndexOffset = parseInt(object.firstIndexOffset, 10);
                else if (typeof object.firstIndexOffset === "number")
                    message.firstIndexOffset = object.firstIndexOffset;
                else if (typeof object.firstIndexOffset === "object")
                    message.firstIndexOffset = new $util.LongBits(object.firstIndexOffset.low >>> 0, object.firstIndexOffset.high >>> 0).toNumber(true);
            if (object.lastIndexOffset != null)
                if ($util.Long)
                    (message.lastIndexOffset = $util.Long.fromValue(object.lastIndexOffset)).unsigned = true;
                else if (typeof object.lastIndexOffset === "string")
                    message.lastIndexOffset = parseInt(object.lastIndexOffset, 10);
                else if (typeof object.lastIndexOffset === "number")
                    message.lastIndexOffset = object.lastIndexOffset;
                else if (typeof object.lastIndexOffset === "object")
                    message.lastIndexOffset = new $util.LongBits(object.lastIndexOffset.low >>> 0, object.lastIndexOffset.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ListPaymentsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.ListPaymentsResponse} message ListPaymentsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPaymentsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.payments = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.firstIndexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.firstIndexOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lastIndexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastIndexOffset = options.longs === String ? "0" : 0;
            }
            if (message.payments && message.payments.length) {
                object.payments = [];
                for (let j = 0; j < message.payments.length; ++j)
                    object.payments[j] = $root.lnrpc.Payment.toObject(message.payments[j], options);
            }
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                if (typeof message.firstIndexOffset === "number")
                    object.firstIndexOffset = options.longs === String ? String(message.firstIndexOffset) : message.firstIndexOffset;
                else
                    object.firstIndexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.firstIndexOffset) : options.longs === Number ? new $util.LongBits(message.firstIndexOffset.low >>> 0, message.firstIndexOffset.high >>> 0).toNumber(true) : message.firstIndexOffset;
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                if (typeof message.lastIndexOffset === "number")
                    object.lastIndexOffset = options.longs === String ? String(message.lastIndexOffset) : message.lastIndexOffset;
                else
                    object.lastIndexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.lastIndexOffset) : options.longs === Number ? new $util.LongBits(message.lastIndexOffset.low >>> 0, message.lastIndexOffset.high >>> 0).toNumber(true) : message.lastIndexOffset;
            return object;
        };

        /**
         * Converts this ListPaymentsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPaymentsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPaymentsResponse;
    })();

    lnrpc.DeleteAllPaymentsRequest = (function() {

        /**
         * Properties of a DeleteAllPaymentsRequest.
         * @memberof lnrpc
         * @interface IDeleteAllPaymentsRequest
         */

        /**
         * Constructs a new DeleteAllPaymentsRequest.
         * @memberof lnrpc
         * @classdesc Represents a DeleteAllPaymentsRequest.
         * @implements IDeleteAllPaymentsRequest
         * @constructor
         * @param {lnrpc.IDeleteAllPaymentsRequest=} [properties] Properties to set
         */
        function DeleteAllPaymentsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteAllPaymentsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest=} [properties] Properties to set
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest instance
         */
        DeleteAllPaymentsRequest.create = function create(properties) {
            return new DeleteAllPaymentsRequest(properties);
        };

        /**
         * Encodes the specified DeleteAllPaymentsRequest message. Does not implicitly {@link lnrpc.DeleteAllPaymentsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest} message DeleteAllPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteAllPaymentsRequest message, length delimited. Does not implicitly {@link lnrpc.DeleteAllPaymentsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest} message DeleteAllPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAllPaymentsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteAllPaymentsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAllPaymentsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAllPaymentsRequest message.
         * @function verify
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAllPaymentsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteAllPaymentsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         */
        DeleteAllPaymentsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteAllPaymentsRequest)
                return object;
            return new $root.lnrpc.DeleteAllPaymentsRequest();
        };

        /**
         * Creates a plain object from a DeleteAllPaymentsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.DeleteAllPaymentsRequest} message DeleteAllPaymentsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAllPaymentsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteAllPaymentsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAllPaymentsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAllPaymentsRequest;
    })();

    lnrpc.DeleteAllPaymentsResponse = (function() {

        /**
         * Properties of a DeleteAllPaymentsResponse.
         * @memberof lnrpc
         * @interface IDeleteAllPaymentsResponse
         */

        /**
         * Constructs a new DeleteAllPaymentsResponse.
         * @memberof lnrpc
         * @classdesc Represents a DeleteAllPaymentsResponse.
         * @implements IDeleteAllPaymentsResponse
         * @constructor
         * @param {lnrpc.IDeleteAllPaymentsResponse=} [properties] Properties to set
         */
        function DeleteAllPaymentsResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteAllPaymentsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse=} [properties] Properties to set
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse instance
         */
        DeleteAllPaymentsResponse.create = function create(properties) {
            return new DeleteAllPaymentsResponse(properties);
        };

        /**
         * Encodes the specified DeleteAllPaymentsResponse message. Does not implicitly {@link lnrpc.DeleteAllPaymentsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse} message DeleteAllPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteAllPaymentsResponse message, length delimited. Does not implicitly {@link lnrpc.DeleteAllPaymentsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse} message DeleteAllPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAllPaymentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteAllPaymentsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAllPaymentsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAllPaymentsResponse message.
         * @function verify
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAllPaymentsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteAllPaymentsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         */
        DeleteAllPaymentsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteAllPaymentsResponse)
                return object;
            return new $root.lnrpc.DeleteAllPaymentsResponse();
        };

        /**
         * Creates a plain object from a DeleteAllPaymentsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.DeleteAllPaymentsResponse} message DeleteAllPaymentsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAllPaymentsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteAllPaymentsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAllPaymentsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAllPaymentsResponse;
    })();

    lnrpc.AbandonChannelRequest = (function() {

        /**
         * Properties of an AbandonChannelRequest.
         * @memberof lnrpc
         * @interface IAbandonChannelRequest
         * @property {lnrpc.IChannelPoint|null} [channelPoint] AbandonChannelRequest channelPoint
         * @property {boolean|null} [pendingFundingShimOnly] AbandonChannelRequest pendingFundingShimOnly
         */

        /**
         * Constructs a new AbandonChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents an AbandonChannelRequest.
         * @implements IAbandonChannelRequest
         * @constructor
         * @param {lnrpc.IAbandonChannelRequest=} [properties] Properties to set
         */
        function AbandonChannelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AbandonChannelRequest channelPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.AbandonChannelRequest
         * @instance
         */
        AbandonChannelRequest.prototype.channelPoint = null;

        /**
         * AbandonChannelRequest pendingFundingShimOnly.
         * @member {boolean} pendingFundingShimOnly
         * @memberof lnrpc.AbandonChannelRequest
         * @instance
         */
        AbandonChannelRequest.prototype.pendingFundingShimOnly = false;

        /**
         * Creates a new AbandonChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.IAbandonChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest instance
         */
        AbandonChannelRequest.create = function create(properties) {
            return new AbandonChannelRequest(properties);
        };

        /**
         * Encodes the specified AbandonChannelRequest message. Does not implicitly {@link lnrpc.AbandonChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.IAbandonChannelRequest} message AbandonChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pendingFundingShimOnly != null && Object.hasOwnProperty.call(message, "pendingFundingShimOnly"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.pendingFundingShimOnly);
            return writer;
        };

        /**
         * Encodes the specified AbandonChannelRequest message, length delimited. Does not implicitly {@link lnrpc.AbandonChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.IAbandonChannelRequest} message AbandonChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AbandonChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AbandonChannelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pendingFundingShimOnly = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AbandonChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AbandonChannelRequest message.
         * @function verify
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AbandonChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            if (message.pendingFundingShimOnly != null && message.hasOwnProperty("pendingFundingShimOnly"))
                if (typeof message.pendingFundingShimOnly !== "boolean")
                    return "pendingFundingShimOnly: boolean expected";
            return null;
        };

        /**
         * Creates an AbandonChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest
         */
        AbandonChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AbandonChannelRequest)
                return object;
            let message = new $root.lnrpc.AbandonChannelRequest();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.AbandonChannelRequest.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            if (object.pendingFundingShimOnly != null)
                message.pendingFundingShimOnly = Boolean(object.pendingFundingShimOnly);
            return message;
        };

        /**
         * Creates a plain object from an AbandonChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.AbandonChannelRequest} message AbandonChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AbandonChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.channelPoint = null;
                object.pendingFundingShimOnly = false;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            if (message.pendingFundingShimOnly != null && message.hasOwnProperty("pendingFundingShimOnly"))
                object.pendingFundingShimOnly = message.pendingFundingShimOnly;
            return object;
        };

        /**
         * Converts this AbandonChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.AbandonChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AbandonChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AbandonChannelRequest;
    })();

    lnrpc.AbandonChannelResponse = (function() {

        /**
         * Properties of an AbandonChannelResponse.
         * @memberof lnrpc
         * @interface IAbandonChannelResponse
         */

        /**
         * Constructs a new AbandonChannelResponse.
         * @memberof lnrpc
         * @classdesc Represents an AbandonChannelResponse.
         * @implements IAbandonChannelResponse
         * @constructor
         * @param {lnrpc.IAbandonChannelResponse=} [properties] Properties to set
         */
        function AbandonChannelResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AbandonChannelResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.IAbandonChannelResponse=} [properties] Properties to set
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse instance
         */
        AbandonChannelResponse.create = function create(properties) {
            return new AbandonChannelResponse(properties);
        };

        /**
         * Encodes the specified AbandonChannelResponse message. Does not implicitly {@link lnrpc.AbandonChannelResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.IAbandonChannelResponse} message AbandonChannelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AbandonChannelResponse message, length delimited. Does not implicitly {@link lnrpc.AbandonChannelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.IAbandonChannelResponse} message AbandonChannelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AbandonChannelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AbandonChannelResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AbandonChannelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AbandonChannelResponse message.
         * @function verify
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AbandonChannelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an AbandonChannelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse
         */
        AbandonChannelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AbandonChannelResponse)
                return object;
            return new $root.lnrpc.AbandonChannelResponse();
        };

        /**
         * Creates a plain object from an AbandonChannelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.AbandonChannelResponse} message AbandonChannelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AbandonChannelResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AbandonChannelResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.AbandonChannelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AbandonChannelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AbandonChannelResponse;
    })();

    lnrpc.DebugLevelRequest = (function() {

        /**
         * Properties of a DebugLevelRequest.
         * @memberof lnrpc
         * @interface IDebugLevelRequest
         * @property {boolean|null} [show] DebugLevelRequest show
         * @property {string|null} [levelSpec] DebugLevelRequest levelSpec
         */

        /**
         * Constructs a new DebugLevelRequest.
         * @memberof lnrpc
         * @classdesc Represents a DebugLevelRequest.
         * @implements IDebugLevelRequest
         * @constructor
         * @param {lnrpc.IDebugLevelRequest=} [properties] Properties to set
         */
        function DebugLevelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugLevelRequest show.
         * @member {boolean} show
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         */
        DebugLevelRequest.prototype.show = false;

        /**
         * DebugLevelRequest levelSpec.
         * @member {string} levelSpec
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         */
        DebugLevelRequest.prototype.levelSpec = "";

        /**
         * Creates a new DebugLevelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest=} [properties] Properties to set
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest instance
         */
        DebugLevelRequest.create = function create(properties) {
            return new DebugLevelRequest(properties);
        };

        /**
         * Encodes the specified DebugLevelRequest message. Does not implicitly {@link lnrpc.DebugLevelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest} message DebugLevelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.show != null && Object.hasOwnProperty.call(message, "show"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.show);
            if (message.levelSpec != null && Object.hasOwnProperty.call(message, "levelSpec"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.levelSpec);
            return writer;
        };

        /**
         * Encodes the specified DebugLevelRequest message, length delimited. Does not implicitly {@link lnrpc.DebugLevelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest} message DebugLevelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugLevelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DebugLevelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.show = reader.bool();
                    break;
                case 2:
                    message.levelSpec = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugLevelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugLevelRequest message.
         * @function verify
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLevelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.show != null && message.hasOwnProperty("show"))
                if (typeof message.show !== "boolean")
                    return "show: boolean expected";
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                if (!$util.isString(message.levelSpec))
                    return "levelSpec: string expected";
            return null;
        };

        /**
         * Creates a DebugLevelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         */
        DebugLevelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DebugLevelRequest)
                return object;
            let message = new $root.lnrpc.DebugLevelRequest();
            if (object.show != null)
                message.show = Boolean(object.show);
            if (object.levelSpec != null)
                message.levelSpec = String(object.levelSpec);
            return message;
        };

        /**
         * Creates a plain object from a DebugLevelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.DebugLevelRequest} message DebugLevelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLevelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.show = false;
                object.levelSpec = "";
            }
            if (message.show != null && message.hasOwnProperty("show"))
                object.show = message.show;
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                object.levelSpec = message.levelSpec;
            return object;
        };

        /**
         * Converts this DebugLevelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLevelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebugLevelRequest;
    })();

    lnrpc.DebugLevelResponse = (function() {

        /**
         * Properties of a DebugLevelResponse.
         * @memberof lnrpc
         * @interface IDebugLevelResponse
         * @property {string|null} [subSystems] DebugLevelResponse subSystems
         */

        /**
         * Constructs a new DebugLevelResponse.
         * @memberof lnrpc
         * @classdesc Represents a DebugLevelResponse.
         * @implements IDebugLevelResponse
         * @constructor
         * @param {lnrpc.IDebugLevelResponse=} [properties] Properties to set
         */
        function DebugLevelResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugLevelResponse subSystems.
         * @member {string} subSystems
         * @memberof lnrpc.DebugLevelResponse
         * @instance
         */
        DebugLevelResponse.prototype.subSystems = "";

        /**
         * Creates a new DebugLevelResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse=} [properties] Properties to set
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse instance
         */
        DebugLevelResponse.create = function create(properties) {
            return new DebugLevelResponse(properties);
        };

        /**
         * Encodes the specified DebugLevelResponse message. Does not implicitly {@link lnrpc.DebugLevelResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse} message DebugLevelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subSystems != null && Object.hasOwnProperty.call(message, "subSystems"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.subSystems);
            return writer;
        };

        /**
         * Encodes the specified DebugLevelResponse message, length delimited. Does not implicitly {@link lnrpc.DebugLevelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse} message DebugLevelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugLevelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DebugLevelResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subSystems = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugLevelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugLevelResponse message.
         * @function verify
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLevelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                if (!$util.isString(message.subSystems))
                    return "subSystems: string expected";
            return null;
        };

        /**
         * Creates a DebugLevelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         */
        DebugLevelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DebugLevelResponse)
                return object;
            let message = new $root.lnrpc.DebugLevelResponse();
            if (object.subSystems != null)
                message.subSystems = String(object.subSystems);
            return message;
        };

        /**
         * Creates a plain object from a DebugLevelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.DebugLevelResponse} message DebugLevelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLevelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.subSystems = "";
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                object.subSystems = message.subSystems;
            return object;
        };

        /**
         * Converts this DebugLevelResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DebugLevelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLevelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebugLevelResponse;
    })();

    lnrpc.PayReqString = (function() {

        /**
         * Properties of a PayReqString.
         * @memberof lnrpc
         * @interface IPayReqString
         * @property {string|null} [payReq] PayReqString payReq
         */

        /**
         * Constructs a new PayReqString.
         * @memberof lnrpc
         * @classdesc Represents a PayReqString.
         * @implements IPayReqString
         * @constructor
         * @param {lnrpc.IPayReqString=} [properties] Properties to set
         */
        function PayReqString(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayReqString payReq.
         * @member {string} payReq
         * @memberof lnrpc.PayReqString
         * @instance
         */
        PayReqString.prototype.payReq = "";

        /**
         * Creates a new PayReqString instance using the specified properties.
         * @function create
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString=} [properties] Properties to set
         * @returns {lnrpc.PayReqString} PayReqString instance
         */
        PayReqString.create = function create(properties) {
            return new PayReqString(properties);
        };

        /**
         * Encodes the specified PayReqString message. Does not implicitly {@link lnrpc.PayReqString.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString} message PayReqString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReqString.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payReq != null && Object.hasOwnProperty.call(message, "payReq"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payReq);
            return writer;
        };

        /**
         * Encodes the specified PayReqString message, length delimited. Does not implicitly {@link lnrpc.PayReqString.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString} message PayReqString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReqString.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayReqString message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PayReqString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PayReqString} PayReqString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReqString.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PayReqString();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payReq = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayReqString message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PayReqString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PayReqString} PayReqString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReqString.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayReqString message.
         * @function verify
         * @memberof lnrpc.PayReqString
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayReqString.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                if (!$util.isString(message.payReq))
                    return "payReq: string expected";
            return null;
        };

        /**
         * Creates a PayReqString message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PayReqString
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PayReqString} PayReqString
         */
        PayReqString.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PayReqString)
                return object;
            let message = new $root.lnrpc.PayReqString();
            if (object.payReq != null)
                message.payReq = String(object.payReq);
            return message;
        };

        /**
         * Creates a plain object from a PayReqString message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.PayReqString} message PayReqString
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayReqString.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.payReq = "";
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                object.payReq = message.payReq;
            return object;
        };

        /**
         * Converts this PayReqString to JSON.
         * @function toJSON
         * @memberof lnrpc.PayReqString
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayReqString.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayReqString;
    })();

    lnrpc.PayReq = (function() {

        /**
         * Properties of a PayReq.
         * @memberof lnrpc
         * @interface IPayReq
         * @property {string|null} [destination] PayReq destination
         * @property {string|null} [paymentHash] PayReq paymentHash
         * @property {number|Long|null} [numSatoshis] PayReq numSatoshis
         * @property {number|Long|null} [timestamp] PayReq timestamp
         * @property {number|Long|null} [expiry] PayReq expiry
         * @property {string|null} [description] PayReq description
         * @property {string|null} [descriptionHash] PayReq descriptionHash
         * @property {string|null} [fallbackAddr] PayReq fallbackAddr
         * @property {number|Long|null} [cltvExpiry] PayReq cltvExpiry
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] PayReq routeHints
         * @property {Uint8Array|null} [paymentAddr] PayReq paymentAddr
         * @property {number|Long|null} [numMsat] PayReq numMsat
         * @property {Object.<string,lnrpc.IFeature>|null} [features] PayReq features
         */

        /**
         * Constructs a new PayReq.
         * @memberof lnrpc
         * @classdesc Represents a PayReq.
         * @implements IPayReq
         * @constructor
         * @param {lnrpc.IPayReq=} [properties] Properties to set
         */
        function PayReq(properties) {
            this.routeHints = [];
            this.features = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayReq destination.
         * @member {string} destination
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.destination = "";

        /**
         * PayReq paymentHash.
         * @member {string} paymentHash
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.paymentHash = "";

        /**
         * PayReq numSatoshis.
         * @member {number|Long} numSatoshis
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.numSatoshis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq timestamp.
         * @member {number|Long} timestamp
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq expiry.
         * @member {number|Long} expiry
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.expiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq description.
         * @member {string} description
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.description = "";

        /**
         * PayReq descriptionHash.
         * @member {string} descriptionHash
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.descriptionHash = "";

        /**
         * PayReq fallbackAddr.
         * @member {string} fallbackAddr
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.fallbackAddr = "";

        /**
         * PayReq cltvExpiry.
         * @member {number|Long} cltvExpiry
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.cltvExpiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq routeHints.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.routeHints = $util.emptyArray;

        /**
         * PayReq paymentAddr.
         * @member {Uint8Array} paymentAddr
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.paymentAddr = $util.newBuffer([]);

        /**
         * PayReq numMsat.
         * @member {number|Long} numMsat
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.numMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq features.
         * @member {Object.<string,lnrpc.IFeature>} features
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.features = $util.emptyObject;

        /**
         * Creates a new PayReq instance using the specified properties.
         * @function create
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq=} [properties] Properties to set
         * @returns {lnrpc.PayReq} PayReq instance
         */
        PayReq.create = function create(properties) {
            return new PayReq(properties);
        };

        /**
         * Encodes the specified PayReq message. Does not implicitly {@link lnrpc.PayReq.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq} message PayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
            if (message.paymentHash != null && Object.hasOwnProperty.call(message, "paymentHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentHash);
            if (message.numSatoshis != null && Object.hasOwnProperty.call(message, "numSatoshis"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.numSatoshis);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            if (message.expiry != null && Object.hasOwnProperty.call(message, "expiry"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiry);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
            if (message.descriptionHash != null && Object.hasOwnProperty.call(message, "descriptionHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.descriptionHash);
            if (message.fallbackAddr != null && Object.hasOwnProperty.call(message, "fallbackAddr"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fallbackAddr);
            if (message.cltvExpiry != null && Object.hasOwnProperty.call(message, "cltvExpiry"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.cltvExpiry);
            if (message.routeHints != null && message.routeHints.length)
                for (let i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.paymentAddr != null && Object.hasOwnProperty.call(message, "paymentAddr"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.paymentAddr);
            if (message.numMsat != null && Object.hasOwnProperty.call(message, "numMsat"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.numMsat);
            if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                for (let keys = Object.keys(message.features), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 13, wireType 2 =*/106).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.lnrpc.Feature.encode(message.features[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified PayReq message, length delimited. Does not implicitly {@link lnrpc.PayReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq} message PayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayReq message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PayReq} PayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PayReq(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.destination = reader.string();
                    break;
                case 2:
                    message.paymentHash = reader.string();
                    break;
                case 3:
                    message.numSatoshis = reader.int64();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                case 5:
                    message.expiry = reader.int64();
                    break;
                case 6:
                    message.description = reader.string();
                    break;
                case 7:
                    message.descriptionHash = reader.string();
                    break;
                case 8:
                    message.fallbackAddr = reader.string();
                    break;
                case 9:
                    message.cltvExpiry = reader.int64();
                    break;
                case 10:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.paymentAddr = reader.bytes();
                    break;
                case 12:
                    message.numMsat = reader.int64();
                    break;
                case 13:
                    if (message.features === $util.emptyObject)
                        message.features = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.uint32();
                            break;
                        case 2:
                            value = $root.lnrpc.Feature.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.features[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PayReq} PayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayReq message.
         * @function verify
         * @memberof lnrpc.PayReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!$util.isString(message.destination))
                    return "destination: string expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!$util.isString(message.paymentHash))
                    return "paymentHash: string expected";
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                if (!$util.isInteger(message.numSatoshis) && !(message.numSatoshis && $util.isInteger(message.numSatoshis.low) && $util.isInteger(message.numSatoshis.high)))
                    return "numSatoshis: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry) && !(message.expiry && $util.isInteger(message.expiry.low) && $util.isInteger(message.expiry.high)))
                    return "expiry: integer|Long expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                if (!$util.isString(message.descriptionHash))
                    return "descriptionHash: string expected";
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                if (!$util.isString(message.fallbackAddr))
                    return "fallbackAddr: string expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry) && !(message.cltvExpiry && $util.isInteger(message.cltvExpiry.low) && $util.isInteger(message.cltvExpiry.high)))
                    return "cltvExpiry: integer|Long expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (let i = 0; i < message.routeHints.length; ++i) {
                    let error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            if (message.paymentAddr != null && message.hasOwnProperty("paymentAddr"))
                if (!(message.paymentAddr && typeof message.paymentAddr.length === "number" || $util.isString(message.paymentAddr)))
                    return "paymentAddr: buffer expected";
            if (message.numMsat != null && message.hasOwnProperty("numMsat"))
                if (!$util.isInteger(message.numMsat) && !(message.numMsat && $util.isInteger(message.numMsat.low) && $util.isInteger(message.numMsat.high)))
                    return "numMsat: integer|Long expected";
            if (message.features != null && message.hasOwnProperty("features")) {
                if (!$util.isObject(message.features))
                    return "features: object expected";
                let key = Object.keys(message.features);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "features: integer key{k:uint32} expected";
                    {
                        let error = $root.lnrpc.Feature.verify(message.features[key[i]]);
                        if (error)
                            return "features." + error;
                    }
                }
            }
            return null;
        };

        /**
         * Creates a PayReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PayReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PayReq} PayReq
         */
        PayReq.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PayReq)
                return object;
            let message = new $root.lnrpc.PayReq();
            if (object.destination != null)
                message.destination = String(object.destination);
            if (object.paymentHash != null)
                message.paymentHash = String(object.paymentHash);
            if (object.numSatoshis != null)
                if ($util.Long)
                    (message.numSatoshis = $util.Long.fromValue(object.numSatoshis)).unsigned = false;
                else if (typeof object.numSatoshis === "string")
                    message.numSatoshis = parseInt(object.numSatoshis, 10);
                else if (typeof object.numSatoshis === "number")
                    message.numSatoshis = object.numSatoshis;
                else if (typeof object.numSatoshis === "object")
                    message.numSatoshis = new $util.LongBits(object.numSatoshis.low >>> 0, object.numSatoshis.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.expiry != null)
                if ($util.Long)
                    (message.expiry = $util.Long.fromValue(object.expiry)).unsigned = false;
                else if (typeof object.expiry === "string")
                    message.expiry = parseInt(object.expiry, 10);
                else if (typeof object.expiry === "number")
                    message.expiry = object.expiry;
                else if (typeof object.expiry === "object")
                    message.expiry = new $util.LongBits(object.expiry.low >>> 0, object.expiry.high >>> 0).toNumber();
            if (object.description != null)
                message.description = String(object.description);
            if (object.descriptionHash != null)
                message.descriptionHash = String(object.descriptionHash);
            if (object.fallbackAddr != null)
                message.fallbackAddr = String(object.fallbackAddr);
            if (object.cltvExpiry != null)
                if ($util.Long)
                    (message.cltvExpiry = $util.Long.fromValue(object.cltvExpiry)).unsigned = false;
                else if (typeof object.cltvExpiry === "string")
                    message.cltvExpiry = parseInt(object.cltvExpiry, 10);
                else if (typeof object.cltvExpiry === "number")
                    message.cltvExpiry = object.cltvExpiry;
                else if (typeof object.cltvExpiry === "object")
                    message.cltvExpiry = new $util.LongBits(object.cltvExpiry.low >>> 0, object.cltvExpiry.high >>> 0).toNumber();
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.PayReq.routeHints: array expected");
                message.routeHints = [];
                for (let i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.PayReq.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            if (object.paymentAddr != null)
                if (typeof object.paymentAddr === "string")
                    $util.base64.decode(object.paymentAddr, message.paymentAddr = $util.newBuffer($util.base64.length(object.paymentAddr)), 0);
                else if (object.paymentAddr.length)
                    message.paymentAddr = object.paymentAddr;
            if (object.numMsat != null)
                if ($util.Long)
                    (message.numMsat = $util.Long.fromValue(object.numMsat)).unsigned = false;
                else if (typeof object.numMsat === "string")
                    message.numMsat = parseInt(object.numMsat, 10);
                else if (typeof object.numMsat === "number")
                    message.numMsat = object.numMsat;
                else if (typeof object.numMsat === "object")
                    message.numMsat = new $util.LongBits(object.numMsat.low >>> 0, object.numMsat.high >>> 0).toNumber();
            if (object.features) {
                if (typeof object.features !== "object")
                    throw TypeError(".lnrpc.PayReq.features: object expected");
                message.features = {};
                for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i) {
                    if (typeof object.features[keys[i]] !== "object")
                        throw TypeError(".lnrpc.PayReq.features: object expected");
                    message.features[keys[i]] = $root.lnrpc.Feature.fromObject(object.features[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PayReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.PayReq} message PayReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.routeHints = [];
            if (options.objects || options.defaults)
                object.features = {};
            if (options.defaults) {
                object.destination = "";
                object.paymentHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.numSatoshis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numSatoshis = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiry = options.longs === String ? "0" : 0;
                object.description = "";
                object.descriptionHash = "";
                object.fallbackAddr = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.cltvExpiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cltvExpiry = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.paymentAddr = "";
                else {
                    object.paymentAddr = [];
                    if (options.bytes !== Array)
                        object.paymentAddr = $util.newBuffer(object.paymentAddr);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.numMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numMsat = options.longs === String ? "0" : 0;
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = message.destination;
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = message.paymentHash;
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                if (typeof message.numSatoshis === "number")
                    object.numSatoshis = options.longs === String ? String(message.numSatoshis) : message.numSatoshis;
                else
                    object.numSatoshis = options.longs === String ? $util.Long.prototype.toString.call(message.numSatoshis) : options.longs === Number ? new $util.LongBits(message.numSatoshis.low >>> 0, message.numSatoshis.high >>> 0).toNumber() : message.numSatoshis;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (typeof message.expiry === "number")
                    object.expiry = options.longs === String ? String(message.expiry) : message.expiry;
                else
                    object.expiry = options.longs === String ? $util.Long.prototype.toString.call(message.expiry) : options.longs === Number ? new $util.LongBits(message.expiry.low >>> 0, message.expiry.high >>> 0).toNumber() : message.expiry;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                object.descriptionHash = message.descriptionHash;
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                object.fallbackAddr = message.fallbackAddr;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (typeof message.cltvExpiry === "number")
                    object.cltvExpiry = options.longs === String ? String(message.cltvExpiry) : message.cltvExpiry;
                else
                    object.cltvExpiry = options.longs === String ? $util.Long.prototype.toString.call(message.cltvExpiry) : options.longs === Number ? new $util.LongBits(message.cltvExpiry.low >>> 0, message.cltvExpiry.high >>> 0).toNumber() : message.cltvExpiry;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (let j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            if (message.paymentAddr != null && message.hasOwnProperty("paymentAddr"))
                object.paymentAddr = options.bytes === String ? $util.base64.encode(message.paymentAddr, 0, message.paymentAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentAddr) : message.paymentAddr;
            if (message.numMsat != null && message.hasOwnProperty("numMsat"))
                if (typeof message.numMsat === "number")
                    object.numMsat = options.longs === String ? String(message.numMsat) : message.numMsat;
                else
                    object.numMsat = options.longs === String ? $util.Long.prototype.toString.call(message.numMsat) : options.longs === Number ? new $util.LongBits(message.numMsat.low >>> 0, message.numMsat.high >>> 0).toNumber() : message.numMsat;
            let keys2;
            if (message.features && (keys2 = Object.keys(message.features)).length) {
                object.features = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.features[keys2[j]] = $root.lnrpc.Feature.toObject(message.features[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this PayReq to JSON.
         * @function toJSON
         * @memberof lnrpc.PayReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayReq;
    })();

    /**
     * FeatureBit enum.
     * @name lnrpc.FeatureBit
     * @enum {number}
     * @property {number} DATALOSS_PROTECT_REQ=0 DATALOSS_PROTECT_REQ value
     * @property {number} DATALOSS_PROTECT_OPT=1 DATALOSS_PROTECT_OPT value
     * @property {number} INITIAL_ROUING_SYNC=3 INITIAL_ROUING_SYNC value
     * @property {number} UPFRONT_SHUTDOWN_SCRIPT_REQ=4 UPFRONT_SHUTDOWN_SCRIPT_REQ value
     * @property {number} UPFRONT_SHUTDOWN_SCRIPT_OPT=5 UPFRONT_SHUTDOWN_SCRIPT_OPT value
     * @property {number} GOSSIP_QUERIES_REQ=6 GOSSIP_QUERIES_REQ value
     * @property {number} GOSSIP_QUERIES_OPT=7 GOSSIP_QUERIES_OPT value
     * @property {number} TLV_ONION_REQ=8 TLV_ONION_REQ value
     * @property {number} TLV_ONION_OPT=9 TLV_ONION_OPT value
     * @property {number} EXT_GOSSIP_QUERIES_REQ=10 EXT_GOSSIP_QUERIES_REQ value
     * @property {number} EXT_GOSSIP_QUERIES_OPT=11 EXT_GOSSIP_QUERIES_OPT value
     * @property {number} STATIC_REMOTE_KEY_REQ=12 STATIC_REMOTE_KEY_REQ value
     * @property {number} STATIC_REMOTE_KEY_OPT=13 STATIC_REMOTE_KEY_OPT value
     * @property {number} PAYMENT_ADDR_REQ=14 PAYMENT_ADDR_REQ value
     * @property {number} PAYMENT_ADDR_OPT=15 PAYMENT_ADDR_OPT value
     * @property {number} MPP_REQ=16 MPP_REQ value
     * @property {number} MPP_OPT=17 MPP_OPT value
     */
    lnrpc.FeatureBit = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DATALOSS_PROTECT_REQ"] = 0;
        values[valuesById[1] = "DATALOSS_PROTECT_OPT"] = 1;
        values[valuesById[3] = "INITIAL_ROUING_SYNC"] = 3;
        values[valuesById[4] = "UPFRONT_SHUTDOWN_SCRIPT_REQ"] = 4;
        values[valuesById[5] = "UPFRONT_SHUTDOWN_SCRIPT_OPT"] = 5;
        values[valuesById[6] = "GOSSIP_QUERIES_REQ"] = 6;
        values[valuesById[7] = "GOSSIP_QUERIES_OPT"] = 7;
        values[valuesById[8] = "TLV_ONION_REQ"] = 8;
        values[valuesById[9] = "TLV_ONION_OPT"] = 9;
        values[valuesById[10] = "EXT_GOSSIP_QUERIES_REQ"] = 10;
        values[valuesById[11] = "EXT_GOSSIP_QUERIES_OPT"] = 11;
        values[valuesById[12] = "STATIC_REMOTE_KEY_REQ"] = 12;
        values[valuesById[13] = "STATIC_REMOTE_KEY_OPT"] = 13;
        values[valuesById[14] = "PAYMENT_ADDR_REQ"] = 14;
        values[valuesById[15] = "PAYMENT_ADDR_OPT"] = 15;
        values[valuesById[16] = "MPP_REQ"] = 16;
        values[valuesById[17] = "MPP_OPT"] = 17;
        return values;
    })();

    lnrpc.Feature = (function() {

        /**
         * Properties of a Feature.
         * @memberof lnrpc
         * @interface IFeature
         * @property {string|null} [name] Feature name
         * @property {boolean|null} [isRequired] Feature isRequired
         * @property {boolean|null} [isKnown] Feature isKnown
         */

        /**
         * Constructs a new Feature.
         * @memberof lnrpc
         * @classdesc Represents a Feature.
         * @implements IFeature
         * @constructor
         * @param {lnrpc.IFeature=} [properties] Properties to set
         */
        function Feature(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Feature name.
         * @member {string} name
         * @memberof lnrpc.Feature
         * @instance
         */
        Feature.prototype.name = "";

        /**
         * Feature isRequired.
         * @member {boolean} isRequired
         * @memberof lnrpc.Feature
         * @instance
         */
        Feature.prototype.isRequired = false;

        /**
         * Feature isKnown.
         * @member {boolean} isKnown
         * @memberof lnrpc.Feature
         * @instance
         */
        Feature.prototype.isKnown = false;

        /**
         * Creates a new Feature instance using the specified properties.
         * @function create
         * @memberof lnrpc.Feature
         * @static
         * @param {lnrpc.IFeature=} [properties] Properties to set
         * @returns {lnrpc.Feature} Feature instance
         */
        Feature.create = function create(properties) {
            return new Feature(properties);
        };

        /**
         * Encodes the specified Feature message. Does not implicitly {@link lnrpc.Feature.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Feature
         * @static
         * @param {lnrpc.IFeature} message Feature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Feature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.isRequired != null && Object.hasOwnProperty.call(message, "isRequired"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isRequired);
            if (message.isKnown != null && Object.hasOwnProperty.call(message, "isKnown"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isKnown);
            return writer;
        };

        /**
         * Encodes the specified Feature message, length delimited. Does not implicitly {@link lnrpc.Feature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Feature
         * @static
         * @param {lnrpc.IFeature} message Feature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Feature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Feature message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Feature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Feature} Feature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Feature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Feature();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.isRequired = reader.bool();
                    break;
                case 4:
                    message.isKnown = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Feature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Feature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Feature} Feature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Feature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Feature message.
         * @function verify
         * @memberof lnrpc.Feature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Feature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                if (typeof message.isRequired !== "boolean")
                    return "isRequired: boolean expected";
            if (message.isKnown != null && message.hasOwnProperty("isKnown"))
                if (typeof message.isKnown !== "boolean")
                    return "isKnown: boolean expected";
            return null;
        };

        /**
         * Creates a Feature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Feature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Feature} Feature
         */
        Feature.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Feature)
                return object;
            let message = new $root.lnrpc.Feature();
            if (object.name != null)
                message.name = String(object.name);
            if (object.isRequired != null)
                message.isRequired = Boolean(object.isRequired);
            if (object.isKnown != null)
                message.isKnown = Boolean(object.isKnown);
            return message;
        };

        /**
         * Creates a plain object from a Feature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Feature
         * @static
         * @param {lnrpc.Feature} message Feature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Feature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.isRequired = false;
                object.isKnown = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                object.isRequired = message.isRequired;
            if (message.isKnown != null && message.hasOwnProperty("isKnown"))
                object.isKnown = message.isKnown;
            return object;
        };

        /**
         * Converts this Feature to JSON.
         * @function toJSON
         * @memberof lnrpc.Feature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Feature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Feature;
    })();

    lnrpc.FeeReportRequest = (function() {

        /**
         * Properties of a FeeReportRequest.
         * @memberof lnrpc
         * @interface IFeeReportRequest
         */

        /**
         * Constructs a new FeeReportRequest.
         * @memberof lnrpc
         * @classdesc Represents a FeeReportRequest.
         * @implements IFeeReportRequest
         * @constructor
         * @param {lnrpc.IFeeReportRequest=} [properties] Properties to set
         */
        function FeeReportRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FeeReportRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest=} [properties] Properties to set
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest instance
         */
        FeeReportRequest.create = function create(properties) {
            return new FeeReportRequest(properties);
        };

        /**
         * Encodes the specified FeeReportRequest message. Does not implicitly {@link lnrpc.FeeReportRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest} message FeeReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FeeReportRequest message, length delimited. Does not implicitly {@link lnrpc.FeeReportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest} message FeeReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeReportRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeReportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReportRequest message.
         * @function verify
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FeeReportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         */
        FeeReportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeReportRequest)
                return object;
            return new $root.lnrpc.FeeReportRequest();
        };

        /**
         * Creates a plain object from a FeeReportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.FeeReportRequest} message FeeReportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReportRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FeeReportRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeReportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeReportRequest;
    })();

    lnrpc.ChannelFeeReport = (function() {

        /**
         * Properties of a ChannelFeeReport.
         * @memberof lnrpc
         * @interface IChannelFeeReport
         * @property {number|Long|null} [chanId] ChannelFeeReport chanId
         * @property {string|null} [channelPoint] ChannelFeeReport channelPoint
         * @property {number|Long|null} [baseFeeMsat] ChannelFeeReport baseFeeMsat
         * @property {number|Long|null} [feePerMil] ChannelFeeReport feePerMil
         * @property {number|null} [feeRate] ChannelFeeReport feeRate
         */

        /**
         * Constructs a new ChannelFeeReport.
         * @memberof lnrpc
         * @classdesc Represents a ChannelFeeReport.
         * @implements IChannelFeeReport
         * @constructor
         * @param {lnrpc.IChannelFeeReport=} [properties] Properties to set
         */
        function ChannelFeeReport(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelFeeReport chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelFeeReport channelPoint.
         * @member {string} channelPoint
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.channelPoint = "";

        /**
         * ChannelFeeReport baseFeeMsat.
         * @member {number|Long} baseFeeMsat
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.baseFeeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelFeeReport feePerMil.
         * @member {number|Long} feePerMil
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.feePerMil = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelFeeReport feeRate.
         * @member {number} feeRate
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.feeRate = 0;

        /**
         * Creates a new ChannelFeeReport instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport=} [properties] Properties to set
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport instance
         */
        ChannelFeeReport.create = function create(properties) {
            return new ChannelFeeReport(properties);
        };

        /**
         * Encodes the specified ChannelFeeReport message. Does not implicitly {@link lnrpc.ChannelFeeReport.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport} message ChannelFeeReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFeeReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && Object.hasOwnProperty.call(message, "channelPoint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelPoint);
            if (message.baseFeeMsat != null && Object.hasOwnProperty.call(message, "baseFeeMsat"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.baseFeeMsat);
            if (message.feePerMil != null && Object.hasOwnProperty.call(message, "feePerMil"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.feePerMil);
            if (message.feeRate != null && Object.hasOwnProperty.call(message, "feeRate"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.feeRate);
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.chanId);
            return writer;
        };

        /**
         * Encodes the specified ChannelFeeReport message, length delimited. Does not implicitly {@link lnrpc.ChannelFeeReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport} message ChannelFeeReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFeeReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelFeeReport message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFeeReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelFeeReport();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.chanId = reader.uint64();
                    break;
                case 1:
                    message.channelPoint = reader.string();
                    break;
                case 2:
                    message.baseFeeMsat = reader.int64();
                    break;
                case 3:
                    message.feePerMil = reader.int64();
                    break;
                case 4:
                    message.feeRate = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelFeeReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFeeReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelFeeReport message.
         * @function verify
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelFeeReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (!$util.isInteger(message.baseFeeMsat) && !(message.baseFeeMsat && $util.isInteger(message.baseFeeMsat.low) && $util.isInteger(message.baseFeeMsat.high)))
                    return "baseFeeMsat: integer|Long expected";
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                if (!$util.isInteger(message.feePerMil) && !(message.feePerMil && $util.isInteger(message.feePerMil.low) && $util.isInteger(message.feePerMil.high)))
                    return "feePerMil: integer|Long expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (typeof message.feeRate !== "number")
                    return "feeRate: number expected";
            return null;
        };

        /**
         * Creates a ChannelFeeReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         */
        ChannelFeeReport.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelFeeReport)
                return object;
            let message = new $root.lnrpc.ChannelFeeReport();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.baseFeeMsat != null)
                if ($util.Long)
                    (message.baseFeeMsat = $util.Long.fromValue(object.baseFeeMsat)).unsigned = false;
                else if (typeof object.baseFeeMsat === "string")
                    message.baseFeeMsat = parseInt(object.baseFeeMsat, 10);
                else if (typeof object.baseFeeMsat === "number")
                    message.baseFeeMsat = object.baseFeeMsat;
                else if (typeof object.baseFeeMsat === "object")
                    message.baseFeeMsat = new $util.LongBits(object.baseFeeMsat.low >>> 0, object.baseFeeMsat.high >>> 0).toNumber();
            if (object.feePerMil != null)
                if ($util.Long)
                    (message.feePerMil = $util.Long.fromValue(object.feePerMil)).unsigned = false;
                else if (typeof object.feePerMil === "string")
                    message.feePerMil = parseInt(object.feePerMil, 10);
                else if (typeof object.feePerMil === "number")
                    message.feePerMil = object.feePerMil;
                else if (typeof object.feePerMil === "object")
                    message.feePerMil = new $util.LongBits(object.feePerMil.low >>> 0, object.feePerMil.high >>> 0).toNumber();
            if (object.feeRate != null)
                message.feeRate = Number(object.feeRate);
            return message;
        };

        /**
         * Creates a plain object from a ChannelFeeReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.ChannelFeeReport} message ChannelFeeReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelFeeReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.channelPoint = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.baseFeeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.baseFeeMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feePerMil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerMil = options.longs === String ? "0" : 0;
                object.feeRate = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (typeof message.baseFeeMsat === "number")
                    object.baseFeeMsat = options.longs === String ? String(message.baseFeeMsat) : message.baseFeeMsat;
                else
                    object.baseFeeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.baseFeeMsat) : options.longs === Number ? new $util.LongBits(message.baseFeeMsat.low >>> 0, message.baseFeeMsat.high >>> 0).toNumber() : message.baseFeeMsat;
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                if (typeof message.feePerMil === "number")
                    object.feePerMil = options.longs === String ? String(message.feePerMil) : message.feePerMil;
                else
                    object.feePerMil = options.longs === String ? $util.Long.prototype.toString.call(message.feePerMil) : options.longs === Number ? new $util.LongBits(message.feePerMil.low >>> 0, message.feePerMil.high >>> 0).toNumber() : message.feePerMil;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = options.json && !isFinite(message.feeRate) ? String(message.feeRate) : message.feeRate;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            return object;
        };

        /**
         * Converts this ChannelFeeReport to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelFeeReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelFeeReport;
    })();

    lnrpc.FeeReportResponse = (function() {

        /**
         * Properties of a FeeReportResponse.
         * @memberof lnrpc
         * @interface IFeeReportResponse
         * @property {Array.<lnrpc.IChannelFeeReport>|null} [channelFees] FeeReportResponse channelFees
         * @property {number|Long|null} [dayFeeSum] FeeReportResponse dayFeeSum
         * @property {number|Long|null} [weekFeeSum] FeeReportResponse weekFeeSum
         * @property {number|Long|null} [monthFeeSum] FeeReportResponse monthFeeSum
         */

        /**
         * Constructs a new FeeReportResponse.
         * @memberof lnrpc
         * @classdesc Represents a FeeReportResponse.
         * @implements IFeeReportResponse
         * @constructor
         * @param {lnrpc.IFeeReportResponse=} [properties] Properties to set
         */
        function FeeReportResponse(properties) {
            this.channelFees = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeReportResponse channelFees.
         * @member {Array.<lnrpc.IChannelFeeReport>} channelFees
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.channelFees = $util.emptyArray;

        /**
         * FeeReportResponse dayFeeSum.
         * @member {number|Long} dayFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.dayFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FeeReportResponse weekFeeSum.
         * @member {number|Long} weekFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.weekFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FeeReportResponse monthFeeSum.
         * @member {number|Long} monthFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.monthFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FeeReportResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse=} [properties] Properties to set
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse instance
         */
        FeeReportResponse.create = function create(properties) {
            return new FeeReportResponse(properties);
        };

        /**
         * Encodes the specified FeeReportResponse message. Does not implicitly {@link lnrpc.FeeReportResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse} message FeeReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelFees != null && message.channelFees.length)
                for (let i = 0; i < message.channelFees.length; ++i)
                    $root.lnrpc.ChannelFeeReport.encode(message.channelFees[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.dayFeeSum != null && Object.hasOwnProperty.call(message, "dayFeeSum"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.dayFeeSum);
            if (message.weekFeeSum != null && Object.hasOwnProperty.call(message, "weekFeeSum"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.weekFeeSum);
            if (message.monthFeeSum != null && Object.hasOwnProperty.call(message, "monthFeeSum"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.monthFeeSum);
            return writer;
        };

        /**
         * Encodes the specified FeeReportResponse message, length delimited. Does not implicitly {@link lnrpc.FeeReportResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse} message FeeReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeReportResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channelFees && message.channelFees.length))
                        message.channelFees = [];
                    message.channelFees.push($root.lnrpc.ChannelFeeReport.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.dayFeeSum = reader.uint64();
                    break;
                case 3:
                    message.weekFeeSum = reader.uint64();
                    break;
                case 4:
                    message.monthFeeSum = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeReportResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReportResponse message.
         * @function verify
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReportResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelFees != null && message.hasOwnProperty("channelFees")) {
                if (!Array.isArray(message.channelFees))
                    return "channelFees: array expected";
                for (let i = 0; i < message.channelFees.length; ++i) {
                    let error = $root.lnrpc.ChannelFeeReport.verify(message.channelFees[i]);
                    if (error)
                        return "channelFees." + error;
                }
            }
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                if (!$util.isInteger(message.dayFeeSum) && !(message.dayFeeSum && $util.isInteger(message.dayFeeSum.low) && $util.isInteger(message.dayFeeSum.high)))
                    return "dayFeeSum: integer|Long expected";
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                if (!$util.isInteger(message.weekFeeSum) && !(message.weekFeeSum && $util.isInteger(message.weekFeeSum.low) && $util.isInteger(message.weekFeeSum.high)))
                    return "weekFeeSum: integer|Long expected";
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                if (!$util.isInteger(message.monthFeeSum) && !(message.monthFeeSum && $util.isInteger(message.monthFeeSum.low) && $util.isInteger(message.monthFeeSum.high)))
                    return "monthFeeSum: integer|Long expected";
            return null;
        };

        /**
         * Creates a FeeReportResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         */
        FeeReportResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeReportResponse)
                return object;
            let message = new $root.lnrpc.FeeReportResponse();
            if (object.channelFees) {
                if (!Array.isArray(object.channelFees))
                    throw TypeError(".lnrpc.FeeReportResponse.channelFees: array expected");
                message.channelFees = [];
                for (let i = 0; i < object.channelFees.length; ++i) {
                    if (typeof object.channelFees[i] !== "object")
                        throw TypeError(".lnrpc.FeeReportResponse.channelFees: object expected");
                    message.channelFees[i] = $root.lnrpc.ChannelFeeReport.fromObject(object.channelFees[i]);
                }
            }
            if (object.dayFeeSum != null)
                if ($util.Long)
                    (message.dayFeeSum = $util.Long.fromValue(object.dayFeeSum)).unsigned = true;
                else if (typeof object.dayFeeSum === "string")
                    message.dayFeeSum = parseInt(object.dayFeeSum, 10);
                else if (typeof object.dayFeeSum === "number")
                    message.dayFeeSum = object.dayFeeSum;
                else if (typeof object.dayFeeSum === "object")
                    message.dayFeeSum = new $util.LongBits(object.dayFeeSum.low >>> 0, object.dayFeeSum.high >>> 0).toNumber(true);
            if (object.weekFeeSum != null)
                if ($util.Long)
                    (message.weekFeeSum = $util.Long.fromValue(object.weekFeeSum)).unsigned = true;
                else if (typeof object.weekFeeSum === "string")
                    message.weekFeeSum = parseInt(object.weekFeeSum, 10);
                else if (typeof object.weekFeeSum === "number")
                    message.weekFeeSum = object.weekFeeSum;
                else if (typeof object.weekFeeSum === "object")
                    message.weekFeeSum = new $util.LongBits(object.weekFeeSum.low >>> 0, object.weekFeeSum.high >>> 0).toNumber(true);
            if (object.monthFeeSum != null)
                if ($util.Long)
                    (message.monthFeeSum = $util.Long.fromValue(object.monthFeeSum)).unsigned = true;
                else if (typeof object.monthFeeSum === "string")
                    message.monthFeeSum = parseInt(object.monthFeeSum, 10);
                else if (typeof object.monthFeeSum === "number")
                    message.monthFeeSum = object.monthFeeSum;
                else if (typeof object.monthFeeSum === "object")
                    message.monthFeeSum = new $util.LongBits(object.monthFeeSum.low >>> 0, object.monthFeeSum.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a FeeReportResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.FeeReportResponse} message FeeReportResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReportResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channelFees = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.dayFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dayFeeSum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.weekFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.weekFeeSum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.monthFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.monthFeeSum = options.longs === String ? "0" : 0;
            }
            if (message.channelFees && message.channelFees.length) {
                object.channelFees = [];
                for (let j = 0; j < message.channelFees.length; ++j)
                    object.channelFees[j] = $root.lnrpc.ChannelFeeReport.toObject(message.channelFees[j], options);
            }
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                if (typeof message.dayFeeSum === "number")
                    object.dayFeeSum = options.longs === String ? String(message.dayFeeSum) : message.dayFeeSum;
                else
                    object.dayFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.dayFeeSum) : options.longs === Number ? new $util.LongBits(message.dayFeeSum.low >>> 0, message.dayFeeSum.high >>> 0).toNumber(true) : message.dayFeeSum;
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                if (typeof message.weekFeeSum === "number")
                    object.weekFeeSum = options.longs === String ? String(message.weekFeeSum) : message.weekFeeSum;
                else
                    object.weekFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.weekFeeSum) : options.longs === Number ? new $util.LongBits(message.weekFeeSum.low >>> 0, message.weekFeeSum.high >>> 0).toNumber(true) : message.weekFeeSum;
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                if (typeof message.monthFeeSum === "number")
                    object.monthFeeSum = options.longs === String ? String(message.monthFeeSum) : message.monthFeeSum;
                else
                    object.monthFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.monthFeeSum) : options.longs === Number ? new $util.LongBits(message.monthFeeSum.low >>> 0, message.monthFeeSum.high >>> 0).toNumber(true) : message.monthFeeSum;
            return object;
        };

        /**
         * Converts this FeeReportResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeReportResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReportResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeReportResponse;
    })();

    lnrpc.PolicyUpdateRequest = (function() {

        /**
         * Properties of a PolicyUpdateRequest.
         * @memberof lnrpc
         * @interface IPolicyUpdateRequest
         * @property {boolean|null} [global] PolicyUpdateRequest global
         * @property {lnrpc.IChannelPoint|null} [chanPoint] PolicyUpdateRequest chanPoint
         * @property {number|Long|null} [baseFeeMsat] PolicyUpdateRequest baseFeeMsat
         * @property {number|null} [feeRate] PolicyUpdateRequest feeRate
         * @property {number|null} [timeLockDelta] PolicyUpdateRequest timeLockDelta
         * @property {number|Long|null} [maxHtlcMsat] PolicyUpdateRequest maxHtlcMsat
         * @property {number|Long|null} [minHtlcMsat] PolicyUpdateRequest minHtlcMsat
         * @property {boolean|null} [minHtlcMsatSpecified] PolicyUpdateRequest minHtlcMsatSpecified
         */

        /**
         * Constructs a new PolicyUpdateRequest.
         * @memberof lnrpc
         * @classdesc Represents a PolicyUpdateRequest.
         * @implements IPolicyUpdateRequest
         * @constructor
         * @param {lnrpc.IPolicyUpdateRequest=} [properties] Properties to set
         */
        function PolicyUpdateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PolicyUpdateRequest global.
         * @member {boolean|null|undefined} global
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.global = null;

        /**
         * PolicyUpdateRequest chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.chanPoint = null;

        /**
         * PolicyUpdateRequest baseFeeMsat.
         * @member {number|Long} baseFeeMsat
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.baseFeeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PolicyUpdateRequest feeRate.
         * @member {number} feeRate
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.feeRate = 0;

        /**
         * PolicyUpdateRequest timeLockDelta.
         * @member {number} timeLockDelta
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.timeLockDelta = 0;

        /**
         * PolicyUpdateRequest maxHtlcMsat.
         * @member {number|Long} maxHtlcMsat
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.maxHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PolicyUpdateRequest minHtlcMsat.
         * @member {number|Long} minHtlcMsat
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.minHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PolicyUpdateRequest minHtlcMsatSpecified.
         * @member {boolean} minHtlcMsatSpecified
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.minHtlcMsatSpecified = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * PolicyUpdateRequest scope.
         * @member {"global"|"chanPoint"|undefined} scope
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        Object.defineProperty(PolicyUpdateRequest.prototype, "scope", {
            get: $util.oneOfGetter($oneOfFields = ["global", "chanPoint"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PolicyUpdateRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest=} [properties] Properties to set
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest instance
         */
        PolicyUpdateRequest.create = function create(properties) {
            return new PolicyUpdateRequest(properties);
        };

        /**
         * Encodes the specified PolicyUpdateRequest message. Does not implicitly {@link lnrpc.PolicyUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest} message PolicyUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.global != null && Object.hasOwnProperty.call(message, "global"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.global);
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.baseFeeMsat != null && Object.hasOwnProperty.call(message, "baseFeeMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.baseFeeMsat);
            if (message.feeRate != null && Object.hasOwnProperty.call(message, "feeRate"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.feeRate);
            if (message.timeLockDelta != null && Object.hasOwnProperty.call(message, "timeLockDelta"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.timeLockDelta);
            if (message.maxHtlcMsat != null && Object.hasOwnProperty.call(message, "maxHtlcMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxHtlcMsat);
            if (message.minHtlcMsat != null && Object.hasOwnProperty.call(message, "minHtlcMsat"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.minHtlcMsat);
            if (message.minHtlcMsatSpecified != null && Object.hasOwnProperty.call(message, "minHtlcMsatSpecified"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.minHtlcMsatSpecified);
            return writer;
        };

        /**
         * Encodes the specified PolicyUpdateRequest message, length delimited. Does not implicitly {@link lnrpc.PolicyUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest} message PolicyUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PolicyUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.global = reader.bool();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.baseFeeMsat = reader.int64();
                    break;
                case 4:
                    message.feeRate = reader.double();
                    break;
                case 5:
                    message.timeLockDelta = reader.uint32();
                    break;
                case 6:
                    message.maxHtlcMsat = reader.uint64();
                    break;
                case 7:
                    message.minHtlcMsat = reader.uint64();
                    break;
                case 8:
                    message.minHtlcMsatSpecified = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyUpdateRequest message.
         * @function verify
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.global != null && message.hasOwnProperty("global")) {
                properties.scope = 1;
                if (typeof message.global !== "boolean")
                    return "global: boolean expected";
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                if (properties.scope === 1)
                    return "scope: multiple values";
                properties.scope = 1;
                {
                    let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                    if (error)
                        return "chanPoint." + error;
                }
            }
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (!$util.isInteger(message.baseFeeMsat) && !(message.baseFeeMsat && $util.isInteger(message.baseFeeMsat.low) && $util.isInteger(message.baseFeeMsat.high)))
                    return "baseFeeMsat: integer|Long expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (typeof message.feeRate !== "number")
                    return "feeRate: number expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                if (!$util.isInteger(message.maxHtlcMsat) && !(message.maxHtlcMsat && $util.isInteger(message.maxHtlcMsat.low) && $util.isInteger(message.maxHtlcMsat.high)))
                    return "maxHtlcMsat: integer|Long expected";
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (!$util.isInteger(message.minHtlcMsat) && !(message.minHtlcMsat && $util.isInteger(message.minHtlcMsat.low) && $util.isInteger(message.minHtlcMsat.high)))
                    return "minHtlcMsat: integer|Long expected";
            if (message.minHtlcMsatSpecified != null && message.hasOwnProperty("minHtlcMsatSpecified"))
                if (typeof message.minHtlcMsatSpecified !== "boolean")
                    return "minHtlcMsatSpecified: boolean expected";
            return null;
        };

        /**
         * Creates a PolicyUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         */
        PolicyUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PolicyUpdateRequest)
                return object;
            let message = new $root.lnrpc.PolicyUpdateRequest();
            if (object.global != null)
                message.global = Boolean(object.global);
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.PolicyUpdateRequest.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.baseFeeMsat != null)
                if ($util.Long)
                    (message.baseFeeMsat = $util.Long.fromValue(object.baseFeeMsat)).unsigned = false;
                else if (typeof object.baseFeeMsat === "string")
                    message.baseFeeMsat = parseInt(object.baseFeeMsat, 10);
                else if (typeof object.baseFeeMsat === "number")
                    message.baseFeeMsat = object.baseFeeMsat;
                else if (typeof object.baseFeeMsat === "object")
                    message.baseFeeMsat = new $util.LongBits(object.baseFeeMsat.low >>> 0, object.baseFeeMsat.high >>> 0).toNumber();
            if (object.feeRate != null)
                message.feeRate = Number(object.feeRate);
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            if (object.maxHtlcMsat != null)
                if ($util.Long)
                    (message.maxHtlcMsat = $util.Long.fromValue(object.maxHtlcMsat)).unsigned = true;
                else if (typeof object.maxHtlcMsat === "string")
                    message.maxHtlcMsat = parseInt(object.maxHtlcMsat, 10);
                else if (typeof object.maxHtlcMsat === "number")
                    message.maxHtlcMsat = object.maxHtlcMsat;
                else if (typeof object.maxHtlcMsat === "object")
                    message.maxHtlcMsat = new $util.LongBits(object.maxHtlcMsat.low >>> 0, object.maxHtlcMsat.high >>> 0).toNumber(true);
            if (object.minHtlcMsat != null)
                if ($util.Long)
                    (message.minHtlcMsat = $util.Long.fromValue(object.minHtlcMsat)).unsigned = true;
                else if (typeof object.minHtlcMsat === "string")
                    message.minHtlcMsat = parseInt(object.minHtlcMsat, 10);
                else if (typeof object.minHtlcMsat === "number")
                    message.minHtlcMsat = object.minHtlcMsat;
                else if (typeof object.minHtlcMsat === "object")
                    message.minHtlcMsat = new $util.LongBits(object.minHtlcMsat.low >>> 0, object.minHtlcMsat.high >>> 0).toNumber(true);
            if (object.minHtlcMsatSpecified != null)
                message.minHtlcMsatSpecified = Boolean(object.minHtlcMsatSpecified);
            return message;
        };

        /**
         * Creates a plain object from a PolicyUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.PolicyUpdateRequest} message PolicyUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.baseFeeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.baseFeeMsat = options.longs === String ? "0" : 0;
                object.feeRate = 0;
                object.timeLockDelta = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxHtlcMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlcMsat = options.longs === String ? "0" : 0;
                object.minHtlcMsatSpecified = false;
            }
            if (message.global != null && message.hasOwnProperty("global")) {
                object.global = message.global;
                if (options.oneofs)
                    object.scope = "global";
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
                if (options.oneofs)
                    object.scope = "chanPoint";
            }
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (typeof message.baseFeeMsat === "number")
                    object.baseFeeMsat = options.longs === String ? String(message.baseFeeMsat) : message.baseFeeMsat;
                else
                    object.baseFeeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.baseFeeMsat) : options.longs === Number ? new $util.LongBits(message.baseFeeMsat.low >>> 0, message.baseFeeMsat.high >>> 0).toNumber() : message.baseFeeMsat;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = options.json && !isFinite(message.feeRate) ? String(message.feeRate) : message.feeRate;
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                if (typeof message.maxHtlcMsat === "number")
                    object.maxHtlcMsat = options.longs === String ? String(message.maxHtlcMsat) : message.maxHtlcMsat;
                else
                    object.maxHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.maxHtlcMsat) : options.longs === Number ? new $util.LongBits(message.maxHtlcMsat.low >>> 0, message.maxHtlcMsat.high >>> 0).toNumber(true) : message.maxHtlcMsat;
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (typeof message.minHtlcMsat === "number")
                    object.minHtlcMsat = options.longs === String ? String(message.minHtlcMsat) : message.minHtlcMsat;
                else
                    object.minHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlcMsat) : options.longs === Number ? new $util.LongBits(message.minHtlcMsat.low >>> 0, message.minHtlcMsat.high >>> 0).toNumber(true) : message.minHtlcMsat;
            if (message.minHtlcMsatSpecified != null && message.hasOwnProperty("minHtlcMsatSpecified"))
                object.minHtlcMsatSpecified = message.minHtlcMsatSpecified;
            return object;
        };

        /**
         * Converts this PolicyUpdateRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyUpdateRequest;
    })();

    lnrpc.PolicyUpdateResponse = (function() {

        /**
         * Properties of a PolicyUpdateResponse.
         * @memberof lnrpc
         * @interface IPolicyUpdateResponse
         */

        /**
         * Constructs a new PolicyUpdateResponse.
         * @memberof lnrpc
         * @classdesc Represents a PolicyUpdateResponse.
         * @implements IPolicyUpdateResponse
         * @constructor
         * @param {lnrpc.IPolicyUpdateResponse=} [properties] Properties to set
         */
        function PolicyUpdateResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PolicyUpdateResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse=} [properties] Properties to set
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse instance
         */
        PolicyUpdateResponse.create = function create(properties) {
            return new PolicyUpdateResponse(properties);
        };

        /**
         * Encodes the specified PolicyUpdateResponse message. Does not implicitly {@link lnrpc.PolicyUpdateResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse} message PolicyUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PolicyUpdateResponse message, length delimited. Does not implicitly {@link lnrpc.PolicyUpdateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse} message PolicyUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyUpdateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PolicyUpdateResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyUpdateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyUpdateResponse message.
         * @function verify
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyUpdateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PolicyUpdateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         */
        PolicyUpdateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PolicyUpdateResponse)
                return object;
            return new $root.lnrpc.PolicyUpdateResponse();
        };

        /**
         * Creates a plain object from a PolicyUpdateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.PolicyUpdateResponse} message PolicyUpdateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyUpdateResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PolicyUpdateResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.PolicyUpdateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyUpdateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyUpdateResponse;
    })();

    lnrpc.ForwardingHistoryRequest = (function() {

        /**
         * Properties of a ForwardingHistoryRequest.
         * @memberof lnrpc
         * @interface IForwardingHistoryRequest
         * @property {number|Long|null} [startTime] ForwardingHistoryRequest startTime
         * @property {number|Long|null} [endTime] ForwardingHistoryRequest endTime
         * @property {number|null} [indexOffset] ForwardingHistoryRequest indexOffset
         * @property {number|null} [numMaxEvents] ForwardingHistoryRequest numMaxEvents
         */

        /**
         * Constructs a new ForwardingHistoryRequest.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingHistoryRequest.
         * @implements IForwardingHistoryRequest
         * @constructor
         * @param {lnrpc.IForwardingHistoryRequest=} [properties] Properties to set
         */
        function ForwardingHistoryRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ForwardingHistoryRequest startTime.
         * @member {number|Long} startTime
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingHistoryRequest endTime.
         * @member {number|Long} endTime
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingHistoryRequest indexOffset.
         * @member {number} indexOffset
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.indexOffset = 0;

        /**
         * ForwardingHistoryRequest numMaxEvents.
         * @member {number} numMaxEvents
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.numMaxEvents = 0;

        /**
         * Creates a new ForwardingHistoryRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest=} [properties] Properties to set
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest instance
         */
        ForwardingHistoryRequest.create = function create(properties) {
            return new ForwardingHistoryRequest(properties);
        };

        /**
         * Encodes the specified ForwardingHistoryRequest message. Does not implicitly {@link lnrpc.ForwardingHistoryRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest} message ForwardingHistoryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.endTime);
            if (message.indexOffset != null && Object.hasOwnProperty.call(message, "indexOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.indexOffset);
            if (message.numMaxEvents != null && Object.hasOwnProperty.call(message, "numMaxEvents"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numMaxEvents);
            return writer;
        };

        /**
         * Encodes the specified ForwardingHistoryRequest message, length delimited. Does not implicitly {@link lnrpc.ForwardingHistoryRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest} message ForwardingHistoryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingHistoryRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingHistoryRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTime = reader.uint64();
                    break;
                case 2:
                    message.endTime = reader.uint64();
                    break;
                case 3:
                    message.indexOffset = reader.uint32();
                    break;
                case 4:
                    message.numMaxEvents = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingHistoryRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingHistoryRequest message.
         * @function verify
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingHistoryRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (!$util.isInteger(message.indexOffset))
                    return "indexOffset: integer expected";
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                if (!$util.isInteger(message.numMaxEvents))
                    return "numMaxEvents: integer expected";
            return null;
        };

        /**
         * Creates a ForwardingHistoryRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         */
        ForwardingHistoryRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingHistoryRequest)
                return object;
            let message = new $root.lnrpc.ForwardingHistoryRequest();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = true;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber(true);
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = true;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber(true);
            if (object.indexOffset != null)
                message.indexOffset = object.indexOffset >>> 0;
            if (object.numMaxEvents != null)
                message.numMaxEvents = object.numMaxEvents >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ForwardingHistoryRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.ForwardingHistoryRequest} message ForwardingHistoryRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingHistoryRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
                object.indexOffset = 0;
                object.numMaxEvents = 0;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                object.indexOffset = message.indexOffset;
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                object.numMaxEvents = message.numMaxEvents;
            return object;
        };

        /**
         * Converts this ForwardingHistoryRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingHistoryRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingHistoryRequest;
    })();

    lnrpc.ForwardingEvent = (function() {

        /**
         * Properties of a ForwardingEvent.
         * @memberof lnrpc
         * @interface IForwardingEvent
         * @property {number|Long|null} [timestamp] ForwardingEvent timestamp
         * @property {number|Long|null} [chanIdIn] ForwardingEvent chanIdIn
         * @property {number|Long|null} [chanIdOut] ForwardingEvent chanIdOut
         * @property {number|Long|null} [amtIn] ForwardingEvent amtIn
         * @property {number|Long|null} [amtOut] ForwardingEvent amtOut
         * @property {number|Long|null} [fee] ForwardingEvent fee
         * @property {number|Long|null} [feeMsat] ForwardingEvent feeMsat
         * @property {number|Long|null} [amtInMsat] ForwardingEvent amtInMsat
         * @property {number|Long|null} [amtOutMsat] ForwardingEvent amtOutMsat
         */

        /**
         * Constructs a new ForwardingEvent.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingEvent.
         * @implements IForwardingEvent
         * @constructor
         * @param {lnrpc.IForwardingEvent=} [properties] Properties to set
         */
        function ForwardingEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ForwardingEvent timestamp.
         * @member {number|Long} timestamp
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent chanIdIn.
         * @member {number|Long} chanIdIn
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.chanIdIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent chanIdOut.
         * @member {number|Long} chanIdOut
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.chanIdOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent amtIn.
         * @member {number|Long} amtIn
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent amtOut.
         * @member {number|Long} amtOut
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent fee.
         * @member {number|Long} fee
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent feeMsat.
         * @member {number|Long} feeMsat
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent amtInMsat.
         * @member {number|Long} amtInMsat
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtInMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ForwardingEvent amtOutMsat.
         * @member {number|Long} amtOutMsat
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtOutMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ForwardingEvent instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent=} [properties] Properties to set
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent instance
         */
        ForwardingEvent.create = function create(properties) {
            return new ForwardingEvent(properties);
        };

        /**
         * Encodes the specified ForwardingEvent message. Does not implicitly {@link lnrpc.ForwardingEvent.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent} message ForwardingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
            if (message.chanIdIn != null && Object.hasOwnProperty.call(message, "chanIdIn"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanIdIn);
            if (message.chanIdOut != null && Object.hasOwnProperty.call(message, "chanIdOut"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.chanIdOut);
            if (message.amtIn != null && Object.hasOwnProperty.call(message, "amtIn"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.amtIn);
            if (message.amtOut != null && Object.hasOwnProperty.call(message, "amtOut"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.amtOut);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.fee);
            if (message.feeMsat != null && Object.hasOwnProperty.call(message, "feeMsat"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.feeMsat);
            if (message.amtInMsat != null && Object.hasOwnProperty.call(message, "amtInMsat"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.amtInMsat);
            if (message.amtOutMsat != null && Object.hasOwnProperty.call(message, "amtOutMsat"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.amtOutMsat);
            return writer;
        };

        /**
         * Encodes the specified ForwardingEvent message, length delimited. Does not implicitly {@link lnrpc.ForwardingEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent} message ForwardingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingEvent message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.chanIdIn = reader.uint64();
                    break;
                case 4:
                    message.chanIdOut = reader.uint64();
                    break;
                case 5:
                    message.amtIn = reader.uint64();
                    break;
                case 6:
                    message.amtOut = reader.uint64();
                    break;
                case 7:
                    message.fee = reader.uint64();
                    break;
                case 8:
                    message.feeMsat = reader.uint64();
                    break;
                case 9:
                    message.amtInMsat = reader.uint64();
                    break;
                case 10:
                    message.amtOutMsat = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingEvent message.
         * @function verify
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                if (!$util.isInteger(message.chanIdIn) && !(message.chanIdIn && $util.isInteger(message.chanIdIn.low) && $util.isInteger(message.chanIdIn.high)))
                    return "chanIdIn: integer|Long expected";
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                if (!$util.isInteger(message.chanIdOut) && !(message.chanIdOut && $util.isInteger(message.chanIdOut.low) && $util.isInteger(message.chanIdOut.high)))
                    return "chanIdOut: integer|Long expected";
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                if (!$util.isInteger(message.amtIn) && !(message.amtIn && $util.isInteger(message.amtIn.low) && $util.isInteger(message.amtIn.high)))
                    return "amtIn: integer|Long expected";
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                if (!$util.isInteger(message.amtOut) && !(message.amtOut && $util.isInteger(message.amtOut.low) && $util.isInteger(message.amtOut.high)))
                    return "amtOut: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            if (message.amtInMsat != null && message.hasOwnProperty("amtInMsat"))
                if (!$util.isInteger(message.amtInMsat) && !(message.amtInMsat && $util.isInteger(message.amtInMsat.low) && $util.isInteger(message.amtInMsat.high)))
                    return "amtInMsat: integer|Long expected";
            if (message.amtOutMsat != null && message.hasOwnProperty("amtOutMsat"))
                if (!$util.isInteger(message.amtOutMsat) && !(message.amtOutMsat && $util.isInteger(message.amtOutMsat.low) && $util.isInteger(message.amtOutMsat.high)))
                    return "amtOutMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a ForwardingEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         */
        ForwardingEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingEvent)
                return object;
            let message = new $root.lnrpc.ForwardingEvent();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.chanIdIn != null)
                if ($util.Long)
                    (message.chanIdIn = $util.Long.fromValue(object.chanIdIn)).unsigned = true;
                else if (typeof object.chanIdIn === "string")
                    message.chanIdIn = parseInt(object.chanIdIn, 10);
                else if (typeof object.chanIdIn === "number")
                    message.chanIdIn = object.chanIdIn;
                else if (typeof object.chanIdIn === "object")
                    message.chanIdIn = new $util.LongBits(object.chanIdIn.low >>> 0, object.chanIdIn.high >>> 0).toNumber(true);
            if (object.chanIdOut != null)
                if ($util.Long)
                    (message.chanIdOut = $util.Long.fromValue(object.chanIdOut)).unsigned = true;
                else if (typeof object.chanIdOut === "string")
                    message.chanIdOut = parseInt(object.chanIdOut, 10);
                else if (typeof object.chanIdOut === "number")
                    message.chanIdOut = object.chanIdOut;
                else if (typeof object.chanIdOut === "object")
                    message.chanIdOut = new $util.LongBits(object.chanIdOut.low >>> 0, object.chanIdOut.high >>> 0).toNumber(true);
            if (object.amtIn != null)
                if ($util.Long)
                    (message.amtIn = $util.Long.fromValue(object.amtIn)).unsigned = true;
                else if (typeof object.amtIn === "string")
                    message.amtIn = parseInt(object.amtIn, 10);
                else if (typeof object.amtIn === "number")
                    message.amtIn = object.amtIn;
                else if (typeof object.amtIn === "object")
                    message.amtIn = new $util.LongBits(object.amtIn.low >>> 0, object.amtIn.high >>> 0).toNumber(true);
            if (object.amtOut != null)
                if ($util.Long)
                    (message.amtOut = $util.Long.fromValue(object.amtOut)).unsigned = true;
                else if (typeof object.amtOut === "string")
                    message.amtOut = parseInt(object.amtOut, 10);
                else if (typeof object.amtOut === "number")
                    message.amtOut = object.amtOut;
                else if (typeof object.amtOut === "object")
                    message.amtOut = new $util.LongBits(object.amtOut.low >>> 0, object.amtOut.high >>> 0).toNumber(true);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = true;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber(true);
            if (object.amtInMsat != null)
                if ($util.Long)
                    (message.amtInMsat = $util.Long.fromValue(object.amtInMsat)).unsigned = true;
                else if (typeof object.amtInMsat === "string")
                    message.amtInMsat = parseInt(object.amtInMsat, 10);
                else if (typeof object.amtInMsat === "number")
                    message.amtInMsat = object.amtInMsat;
                else if (typeof object.amtInMsat === "object")
                    message.amtInMsat = new $util.LongBits(object.amtInMsat.low >>> 0, object.amtInMsat.high >>> 0).toNumber(true);
            if (object.amtOutMsat != null)
                if ($util.Long)
                    (message.amtOutMsat = $util.Long.fromValue(object.amtOutMsat)).unsigned = true;
                else if (typeof object.amtOutMsat === "string")
                    message.amtOutMsat = parseInt(object.amtOutMsat, 10);
                else if (typeof object.amtOutMsat === "number")
                    message.amtOutMsat = object.amtOutMsat;
                else if (typeof object.amtOutMsat === "object")
                    message.amtOutMsat = new $util.LongBits(object.amtOutMsat.low >>> 0, object.amtOutMsat.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ForwardingEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.ForwardingEvent} message ForwardingEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanIdIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanIdIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanIdOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanIdOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtInMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtInMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtOutMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtOutMsat = options.longs === String ? "0" : 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                if (typeof message.chanIdIn === "number")
                    object.chanIdIn = options.longs === String ? String(message.chanIdIn) : message.chanIdIn;
                else
                    object.chanIdIn = options.longs === String ? $util.Long.prototype.toString.call(message.chanIdIn) : options.longs === Number ? new $util.LongBits(message.chanIdIn.low >>> 0, message.chanIdIn.high >>> 0).toNumber(true) : message.chanIdIn;
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                if (typeof message.chanIdOut === "number")
                    object.chanIdOut = options.longs === String ? String(message.chanIdOut) : message.chanIdOut;
                else
                    object.chanIdOut = options.longs === String ? $util.Long.prototype.toString.call(message.chanIdOut) : options.longs === Number ? new $util.LongBits(message.chanIdOut.low >>> 0, message.chanIdOut.high >>> 0).toNumber(true) : message.chanIdOut;
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                if (typeof message.amtIn === "number")
                    object.amtIn = options.longs === String ? String(message.amtIn) : message.amtIn;
                else
                    object.amtIn = options.longs === String ? $util.Long.prototype.toString.call(message.amtIn) : options.longs === Number ? new $util.LongBits(message.amtIn.low >>> 0, message.amtIn.high >>> 0).toNumber(true) : message.amtIn;
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                if (typeof message.amtOut === "number")
                    object.amtOut = options.longs === String ? String(message.amtOut) : message.amtOut;
                else
                    object.amtOut = options.longs === String ? $util.Long.prototype.toString.call(message.amtOut) : options.longs === Number ? new $util.LongBits(message.amtOut.low >>> 0, message.amtOut.high >>> 0).toNumber(true) : message.amtOut;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber(true) : message.feeMsat;
            if (message.amtInMsat != null && message.hasOwnProperty("amtInMsat"))
                if (typeof message.amtInMsat === "number")
                    object.amtInMsat = options.longs === String ? String(message.amtInMsat) : message.amtInMsat;
                else
                    object.amtInMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtInMsat) : options.longs === Number ? new $util.LongBits(message.amtInMsat.low >>> 0, message.amtInMsat.high >>> 0).toNumber(true) : message.amtInMsat;
            if (message.amtOutMsat != null && message.hasOwnProperty("amtOutMsat"))
                if (typeof message.amtOutMsat === "number")
                    object.amtOutMsat = options.longs === String ? String(message.amtOutMsat) : message.amtOutMsat;
                else
                    object.amtOutMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtOutMsat) : options.longs === Number ? new $util.LongBits(message.amtOutMsat.low >>> 0, message.amtOutMsat.high >>> 0).toNumber(true) : message.amtOutMsat;
            return object;
        };

        /**
         * Converts this ForwardingEvent to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingEvent;
    })();

    lnrpc.ForwardingHistoryResponse = (function() {

        /**
         * Properties of a ForwardingHistoryResponse.
         * @memberof lnrpc
         * @interface IForwardingHistoryResponse
         * @property {Array.<lnrpc.IForwardingEvent>|null} [forwardingEvents] ForwardingHistoryResponse forwardingEvents
         * @property {number|null} [lastOffsetIndex] ForwardingHistoryResponse lastOffsetIndex
         */

        /**
         * Constructs a new ForwardingHistoryResponse.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingHistoryResponse.
         * @implements IForwardingHistoryResponse
         * @constructor
         * @param {lnrpc.IForwardingHistoryResponse=} [properties] Properties to set
         */
        function ForwardingHistoryResponse(properties) {
            this.forwardingEvents = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ForwardingHistoryResponse forwardingEvents.
         * @member {Array.<lnrpc.IForwardingEvent>} forwardingEvents
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         */
        ForwardingHistoryResponse.prototype.forwardingEvents = $util.emptyArray;

        /**
         * ForwardingHistoryResponse lastOffsetIndex.
         * @member {number} lastOffsetIndex
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         */
        ForwardingHistoryResponse.prototype.lastOffsetIndex = 0;

        /**
         * Creates a new ForwardingHistoryResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse=} [properties] Properties to set
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse instance
         */
        ForwardingHistoryResponse.create = function create(properties) {
            return new ForwardingHistoryResponse(properties);
        };

        /**
         * Encodes the specified ForwardingHistoryResponse message. Does not implicitly {@link lnrpc.ForwardingHistoryResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse} message ForwardingHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forwardingEvents != null && message.forwardingEvents.length)
                for (let i = 0; i < message.forwardingEvents.length; ++i)
                    $root.lnrpc.ForwardingEvent.encode(message.forwardingEvents[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lastOffsetIndex != null && Object.hasOwnProperty.call(message, "lastOffsetIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lastOffsetIndex);
            return writer;
        };

        /**
         * Encodes the specified ForwardingHistoryResponse message, length delimited. Does not implicitly {@link lnrpc.ForwardingHistoryResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse} message ForwardingHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingHistoryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingHistoryResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.forwardingEvents && message.forwardingEvents.length))
                        message.forwardingEvents = [];
                    message.forwardingEvents.push($root.lnrpc.ForwardingEvent.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastOffsetIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingHistoryResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingHistoryResponse message.
         * @function verify
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingHistoryResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forwardingEvents != null && message.hasOwnProperty("forwardingEvents")) {
                if (!Array.isArray(message.forwardingEvents))
                    return "forwardingEvents: array expected";
                for (let i = 0; i < message.forwardingEvents.length; ++i) {
                    let error = $root.lnrpc.ForwardingEvent.verify(message.forwardingEvents[i]);
                    if (error)
                        return "forwardingEvents." + error;
                }
            }
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                if (!$util.isInteger(message.lastOffsetIndex))
                    return "lastOffsetIndex: integer expected";
            return null;
        };

        /**
         * Creates a ForwardingHistoryResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         */
        ForwardingHistoryResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingHistoryResponse)
                return object;
            let message = new $root.lnrpc.ForwardingHistoryResponse();
            if (object.forwardingEvents) {
                if (!Array.isArray(object.forwardingEvents))
                    throw TypeError(".lnrpc.ForwardingHistoryResponse.forwardingEvents: array expected");
                message.forwardingEvents = [];
                for (let i = 0; i < object.forwardingEvents.length; ++i) {
                    if (typeof object.forwardingEvents[i] !== "object")
                        throw TypeError(".lnrpc.ForwardingHistoryResponse.forwardingEvents: object expected");
                    message.forwardingEvents[i] = $root.lnrpc.ForwardingEvent.fromObject(object.forwardingEvents[i]);
                }
            }
            if (object.lastOffsetIndex != null)
                message.lastOffsetIndex = object.lastOffsetIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ForwardingHistoryResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.ForwardingHistoryResponse} message ForwardingHistoryResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingHistoryResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.forwardingEvents = [];
            if (options.defaults)
                object.lastOffsetIndex = 0;
            if (message.forwardingEvents && message.forwardingEvents.length) {
                object.forwardingEvents = [];
                for (let j = 0; j < message.forwardingEvents.length; ++j)
                    object.forwardingEvents[j] = $root.lnrpc.ForwardingEvent.toObject(message.forwardingEvents[j], options);
            }
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                object.lastOffsetIndex = message.lastOffsetIndex;
            return object;
        };

        /**
         * Converts this ForwardingHistoryResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingHistoryResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingHistoryResponse;
    })();

    lnrpc.ExportChannelBackupRequest = (function() {

        /**
         * Properties of an ExportChannelBackupRequest.
         * @memberof lnrpc
         * @interface IExportChannelBackupRequest
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ExportChannelBackupRequest chanPoint
         */

        /**
         * Constructs a new ExportChannelBackupRequest.
         * @memberof lnrpc
         * @classdesc Represents an ExportChannelBackupRequest.
         * @implements IExportChannelBackupRequest
         * @constructor
         * @param {lnrpc.IExportChannelBackupRequest=} [properties] Properties to set
         */
        function ExportChannelBackupRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportChannelBackupRequest chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ExportChannelBackupRequest
         * @instance
         */
        ExportChannelBackupRequest.prototype.chanPoint = null;

        /**
         * Creates a new ExportChannelBackupRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.IExportChannelBackupRequest=} [properties] Properties to set
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest instance
         */
        ExportChannelBackupRequest.create = function create(properties) {
            return new ExportChannelBackupRequest(properties);
        };

        /**
         * Encodes the specified ExportChannelBackupRequest message. Does not implicitly {@link lnrpc.ExportChannelBackupRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.IExportChannelBackupRequest} message ExportChannelBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportChannelBackupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExportChannelBackupRequest message, length delimited. Does not implicitly {@link lnrpc.ExportChannelBackupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.IExportChannelBackupRequest} message ExportChannelBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportChannelBackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportChannelBackupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportChannelBackupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ExportChannelBackupRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportChannelBackupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportChannelBackupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportChannelBackupRequest message.
         * @function verify
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportChannelBackupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            return null;
        };

        /**
         * Creates an ExportChannelBackupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest
         */
        ExportChannelBackupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ExportChannelBackupRequest)
                return object;
            let message = new $root.lnrpc.ExportChannelBackupRequest();
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ExportChannelBackupRequest.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExportChannelBackupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.ExportChannelBackupRequest} message ExportChannelBackupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportChannelBackupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.chanPoint = null;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            return object;
        };

        /**
         * Converts this ExportChannelBackupRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ExportChannelBackupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportChannelBackupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExportChannelBackupRequest;
    })();

    lnrpc.ChannelBackup = (function() {

        /**
         * Properties of a ChannelBackup.
         * @memberof lnrpc
         * @interface IChannelBackup
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ChannelBackup chanPoint
         * @property {Uint8Array|null} [chanBackup] ChannelBackup chanBackup
         */

        /**
         * Constructs a new ChannelBackup.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBackup.
         * @implements IChannelBackup
         * @constructor
         * @param {lnrpc.IChannelBackup=} [properties] Properties to set
         */
        function ChannelBackup(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelBackup chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ChannelBackup
         * @instance
         */
        ChannelBackup.prototype.chanPoint = null;

        /**
         * ChannelBackup chanBackup.
         * @member {Uint8Array} chanBackup
         * @memberof lnrpc.ChannelBackup
         * @instance
         */
        ChannelBackup.prototype.chanBackup = $util.newBuffer([]);

        /**
         * Creates a new ChannelBackup instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.IChannelBackup=} [properties] Properties to set
         * @returns {lnrpc.ChannelBackup} ChannelBackup instance
         */
        ChannelBackup.create = function create(properties) {
            return new ChannelBackup(properties);
        };

        /**
         * Encodes the specified ChannelBackup message. Does not implicitly {@link lnrpc.ChannelBackup.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.IChannelBackup} message ChannelBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoint != null && Object.hasOwnProperty.call(message, "chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chanBackup != null && Object.hasOwnProperty.call(message, "chanBackup"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.chanBackup);
            return writer;
        };

        /**
         * Encodes the specified ChannelBackup message, length delimited. Does not implicitly {@link lnrpc.ChannelBackup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.IChannelBackup} message ChannelBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBackup message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBackup} ChannelBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBackup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.chanBackup = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBackup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBackup} ChannelBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBackup message.
         * @function verify
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBackup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            if (message.chanBackup != null && message.hasOwnProperty("chanBackup"))
                if (!(message.chanBackup && typeof message.chanBackup.length === "number" || $util.isString(message.chanBackup)))
                    return "chanBackup: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelBackup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBackup} ChannelBackup
         */
        ChannelBackup.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBackup)
                return object;
            let message = new $root.lnrpc.ChannelBackup();
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ChannelBackup.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.chanBackup != null)
                if (typeof object.chanBackup === "string")
                    $util.base64.decode(object.chanBackup, message.chanBackup = $util.newBuffer($util.base64.length(object.chanBackup)), 0);
                else if (object.chanBackup.length)
                    message.chanBackup = object.chanBackup;
            return message;
        };

        /**
         * Creates a plain object from a ChannelBackup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.ChannelBackup} message ChannelBackup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBackup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chanPoint = null;
                if (options.bytes === String)
                    object.chanBackup = "";
                else {
                    object.chanBackup = [];
                    if (options.bytes !== Array)
                        object.chanBackup = $util.newBuffer(object.chanBackup);
                }
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            if (message.chanBackup != null && message.hasOwnProperty("chanBackup"))
                object.chanBackup = options.bytes === String ? $util.base64.encode(message.chanBackup, 0, message.chanBackup.length) : options.bytes === Array ? Array.prototype.slice.call(message.chanBackup) : message.chanBackup;
            return object;
        };

        /**
         * Converts this ChannelBackup to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBackup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBackup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBackup;
    })();

    lnrpc.MultiChanBackup = (function() {

        /**
         * Properties of a MultiChanBackup.
         * @memberof lnrpc
         * @interface IMultiChanBackup
         * @property {Array.<lnrpc.IChannelPoint>|null} [chanPoints] MultiChanBackup chanPoints
         * @property {Uint8Array|null} [multiChanBackup] MultiChanBackup multiChanBackup
         */

        /**
         * Constructs a new MultiChanBackup.
         * @memberof lnrpc
         * @classdesc Represents a MultiChanBackup.
         * @implements IMultiChanBackup
         * @constructor
         * @param {lnrpc.IMultiChanBackup=} [properties] Properties to set
         */
        function MultiChanBackup(properties) {
            this.chanPoints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MultiChanBackup chanPoints.
         * @member {Array.<lnrpc.IChannelPoint>} chanPoints
         * @memberof lnrpc.MultiChanBackup
         * @instance
         */
        MultiChanBackup.prototype.chanPoints = $util.emptyArray;

        /**
         * MultiChanBackup multiChanBackup.
         * @member {Uint8Array} multiChanBackup
         * @memberof lnrpc.MultiChanBackup
         * @instance
         */
        MultiChanBackup.prototype.multiChanBackup = $util.newBuffer([]);

        /**
         * Creates a new MultiChanBackup instance using the specified properties.
         * @function create
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.IMultiChanBackup=} [properties] Properties to set
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup instance
         */
        MultiChanBackup.create = function create(properties) {
            return new MultiChanBackup(properties);
        };

        /**
         * Encodes the specified MultiChanBackup message. Does not implicitly {@link lnrpc.MultiChanBackup.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.IMultiChanBackup} message MultiChanBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiChanBackup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoints != null && message.chanPoints.length)
                for (let i = 0; i < message.chanPoints.length; ++i)
                    $root.lnrpc.ChannelPoint.encode(message.chanPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.multiChanBackup != null && Object.hasOwnProperty.call(message, "multiChanBackup"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.multiChanBackup);
            return writer;
        };

        /**
         * Encodes the specified MultiChanBackup message, length delimited. Does not implicitly {@link lnrpc.MultiChanBackup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.IMultiChanBackup} message MultiChanBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiChanBackup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MultiChanBackup message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiChanBackup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.MultiChanBackup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chanPoints && message.chanPoints.length))
                        message.chanPoints = [];
                    message.chanPoints.push($root.lnrpc.ChannelPoint.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.multiChanBackup = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MultiChanBackup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiChanBackup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MultiChanBackup message.
         * @function verify
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultiChanBackup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoints != null && message.hasOwnProperty("chanPoints")) {
                if (!Array.isArray(message.chanPoints))
                    return "chanPoints: array expected";
                for (let i = 0; i < message.chanPoints.length; ++i) {
                    let error = $root.lnrpc.ChannelPoint.verify(message.chanPoints[i]);
                    if (error)
                        return "chanPoints." + error;
                }
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                if (!(message.multiChanBackup && typeof message.multiChanBackup.length === "number" || $util.isString(message.multiChanBackup)))
                    return "multiChanBackup: buffer expected";
            return null;
        };

        /**
         * Creates a MultiChanBackup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup
         */
        MultiChanBackup.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.MultiChanBackup)
                return object;
            let message = new $root.lnrpc.MultiChanBackup();
            if (object.chanPoints) {
                if (!Array.isArray(object.chanPoints))
                    throw TypeError(".lnrpc.MultiChanBackup.chanPoints: array expected");
                message.chanPoints = [];
                for (let i = 0; i < object.chanPoints.length; ++i) {
                    if (typeof object.chanPoints[i] !== "object")
                        throw TypeError(".lnrpc.MultiChanBackup.chanPoints: object expected");
                    message.chanPoints[i] = $root.lnrpc.ChannelPoint.fromObject(object.chanPoints[i]);
                }
            }
            if (object.multiChanBackup != null)
                if (typeof object.multiChanBackup === "string")
                    $util.base64.decode(object.multiChanBackup, message.multiChanBackup = $util.newBuffer($util.base64.length(object.multiChanBackup)), 0);
                else if (object.multiChanBackup.length)
                    message.multiChanBackup = object.multiChanBackup;
            return message;
        };

        /**
         * Creates a plain object from a MultiChanBackup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.MultiChanBackup} message MultiChanBackup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultiChanBackup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.chanPoints = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.multiChanBackup = "";
                else {
                    object.multiChanBackup = [];
                    if (options.bytes !== Array)
                        object.multiChanBackup = $util.newBuffer(object.multiChanBackup);
                }
            if (message.chanPoints && message.chanPoints.length) {
                object.chanPoints = [];
                for (let j = 0; j < message.chanPoints.length; ++j)
                    object.chanPoints[j] = $root.lnrpc.ChannelPoint.toObject(message.chanPoints[j], options);
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                object.multiChanBackup = options.bytes === String ? $util.base64.encode(message.multiChanBackup, 0, message.multiChanBackup.length) : options.bytes === Array ? Array.prototype.slice.call(message.multiChanBackup) : message.multiChanBackup;
            return object;
        };

        /**
         * Converts this MultiChanBackup to JSON.
         * @function toJSON
         * @memberof lnrpc.MultiChanBackup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultiChanBackup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MultiChanBackup;
    })();

    lnrpc.ChanBackupExportRequest = (function() {

        /**
         * Properties of a ChanBackupExportRequest.
         * @memberof lnrpc
         * @interface IChanBackupExportRequest
         */

        /**
         * Constructs a new ChanBackupExportRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChanBackupExportRequest.
         * @implements IChanBackupExportRequest
         * @constructor
         * @param {lnrpc.IChanBackupExportRequest=} [properties] Properties to set
         */
        function ChanBackupExportRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChanBackupExportRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.IChanBackupExportRequest=} [properties] Properties to set
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest instance
         */
        ChanBackupExportRequest.create = function create(properties) {
            return new ChanBackupExportRequest(properties);
        };

        /**
         * Encodes the specified ChanBackupExportRequest message. Does not implicitly {@link lnrpc.ChanBackupExportRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.IChanBackupExportRequest} message ChanBackupExportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupExportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChanBackupExportRequest message, length delimited. Does not implicitly {@link lnrpc.ChanBackupExportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.IChanBackupExportRequest} message ChanBackupExportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupExportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanBackupExportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupExportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanBackupExportRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanBackupExportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupExportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanBackupExportRequest message.
         * @function verify
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanBackupExportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChanBackupExportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest
         */
        ChanBackupExportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanBackupExportRequest)
                return object;
            return new $root.lnrpc.ChanBackupExportRequest();
        };

        /**
         * Creates a plain object from a ChanBackupExportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.ChanBackupExportRequest} message ChanBackupExportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanBackupExportRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChanBackupExportRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanBackupExportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanBackupExportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanBackupExportRequest;
    })();

    lnrpc.ChanBackupSnapshot = (function() {

        /**
         * Properties of a ChanBackupSnapshot.
         * @memberof lnrpc
         * @interface IChanBackupSnapshot
         * @property {lnrpc.IChannelBackups|null} [singleChanBackups] ChanBackupSnapshot singleChanBackups
         * @property {lnrpc.IMultiChanBackup|null} [multiChanBackup] ChanBackupSnapshot multiChanBackup
         */

        /**
         * Constructs a new ChanBackupSnapshot.
         * @memberof lnrpc
         * @classdesc Represents a ChanBackupSnapshot.
         * @implements IChanBackupSnapshot
         * @constructor
         * @param {lnrpc.IChanBackupSnapshot=} [properties] Properties to set
         */
        function ChanBackupSnapshot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChanBackupSnapshot singleChanBackups.
         * @member {lnrpc.IChannelBackups|null|undefined} singleChanBackups
         * @memberof lnrpc.ChanBackupSnapshot
         * @instance
         */
        ChanBackupSnapshot.prototype.singleChanBackups = null;

        /**
         * ChanBackupSnapshot multiChanBackup.
         * @member {lnrpc.IMultiChanBackup|null|undefined} multiChanBackup
         * @memberof lnrpc.ChanBackupSnapshot
         * @instance
         */
        ChanBackupSnapshot.prototype.multiChanBackup = null;

        /**
         * Creates a new ChanBackupSnapshot instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.IChanBackupSnapshot=} [properties] Properties to set
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot instance
         */
        ChanBackupSnapshot.create = function create(properties) {
            return new ChanBackupSnapshot(properties);
        };

        /**
         * Encodes the specified ChanBackupSnapshot message. Does not implicitly {@link lnrpc.ChanBackupSnapshot.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.IChanBackupSnapshot} message ChanBackupSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupSnapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.singleChanBackups != null && Object.hasOwnProperty.call(message, "singleChanBackups"))
                $root.lnrpc.ChannelBackups.encode(message.singleChanBackups, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.multiChanBackup != null && Object.hasOwnProperty.call(message, "multiChanBackup"))
                $root.lnrpc.MultiChanBackup.encode(message.multiChanBackup, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChanBackupSnapshot message, length delimited. Does not implicitly {@link lnrpc.ChanBackupSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.IChanBackupSnapshot} message ChanBackupSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanBackupSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupSnapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanBackupSnapshot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.singleChanBackups = $root.lnrpc.ChannelBackups.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.multiChanBackup = $root.lnrpc.MultiChanBackup.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanBackupSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupSnapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanBackupSnapshot message.
         * @function verify
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanBackupSnapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.singleChanBackups != null && message.hasOwnProperty("singleChanBackups")) {
                let error = $root.lnrpc.ChannelBackups.verify(message.singleChanBackups);
                if (error)
                    return "singleChanBackups." + error;
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup")) {
                let error = $root.lnrpc.MultiChanBackup.verify(message.multiChanBackup);
                if (error)
                    return "multiChanBackup." + error;
            }
            return null;
        };

        /**
         * Creates a ChanBackupSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot
         */
        ChanBackupSnapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanBackupSnapshot)
                return object;
            let message = new $root.lnrpc.ChanBackupSnapshot();
            if (object.singleChanBackups != null) {
                if (typeof object.singleChanBackups !== "object")
                    throw TypeError(".lnrpc.ChanBackupSnapshot.singleChanBackups: object expected");
                message.singleChanBackups = $root.lnrpc.ChannelBackups.fromObject(object.singleChanBackups);
            }
            if (object.multiChanBackup != null) {
                if (typeof object.multiChanBackup !== "object")
                    throw TypeError(".lnrpc.ChanBackupSnapshot.multiChanBackup: object expected");
                message.multiChanBackup = $root.lnrpc.MultiChanBackup.fromObject(object.multiChanBackup);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChanBackupSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.ChanBackupSnapshot} message ChanBackupSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanBackupSnapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.singleChanBackups = null;
                object.multiChanBackup = null;
            }
            if (message.singleChanBackups != null && message.hasOwnProperty("singleChanBackups"))
                object.singleChanBackups = $root.lnrpc.ChannelBackups.toObject(message.singleChanBackups, options);
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                object.multiChanBackup = $root.lnrpc.MultiChanBackup.toObject(message.multiChanBackup, options);
            return object;
        };

        /**
         * Converts this ChanBackupSnapshot to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanBackupSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanBackupSnapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanBackupSnapshot;
    })();

    lnrpc.ChannelBackups = (function() {

        /**
         * Properties of a ChannelBackups.
         * @memberof lnrpc
         * @interface IChannelBackups
         * @property {Array.<lnrpc.IChannelBackup>|null} [chanBackups] ChannelBackups chanBackups
         */

        /**
         * Constructs a new ChannelBackups.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBackups.
         * @implements IChannelBackups
         * @constructor
         * @param {lnrpc.IChannelBackups=} [properties] Properties to set
         */
        function ChannelBackups(properties) {
            this.chanBackups = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelBackups chanBackups.
         * @member {Array.<lnrpc.IChannelBackup>} chanBackups
         * @memberof lnrpc.ChannelBackups
         * @instance
         */
        ChannelBackups.prototype.chanBackups = $util.emptyArray;

        /**
         * Creates a new ChannelBackups instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.IChannelBackups=} [properties] Properties to set
         * @returns {lnrpc.ChannelBackups} ChannelBackups instance
         */
        ChannelBackups.create = function create(properties) {
            return new ChannelBackups(properties);
        };

        /**
         * Encodes the specified ChannelBackups message. Does not implicitly {@link lnrpc.ChannelBackups.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.IChannelBackups} message ChannelBackups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanBackups != null && message.chanBackups.length)
                for (let i = 0; i < message.chanBackups.length; ++i)
                    $root.lnrpc.ChannelBackup.encode(message.chanBackups[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelBackups message, length delimited. Does not implicitly {@link lnrpc.ChannelBackups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.IChannelBackups} message ChannelBackups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBackups message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBackups} ChannelBackups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBackups();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chanBackups && message.chanBackups.length))
                        message.chanBackups = [];
                    message.chanBackups.push($root.lnrpc.ChannelBackup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBackups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBackups} ChannelBackups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBackups message.
         * @function verify
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBackups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups")) {
                if (!Array.isArray(message.chanBackups))
                    return "chanBackups: array expected";
                for (let i = 0; i < message.chanBackups.length; ++i) {
                    let error = $root.lnrpc.ChannelBackup.verify(message.chanBackups[i]);
                    if (error)
                        return "chanBackups." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChannelBackups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBackups} ChannelBackups
         */
        ChannelBackups.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBackups)
                return object;
            let message = new $root.lnrpc.ChannelBackups();
            if (object.chanBackups) {
                if (!Array.isArray(object.chanBackups))
                    throw TypeError(".lnrpc.ChannelBackups.chanBackups: array expected");
                message.chanBackups = [];
                for (let i = 0; i < object.chanBackups.length; ++i) {
                    if (typeof object.chanBackups[i] !== "object")
                        throw TypeError(".lnrpc.ChannelBackups.chanBackups: object expected");
                    message.chanBackups[i] = $root.lnrpc.ChannelBackup.fromObject(object.chanBackups[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelBackups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.ChannelBackups} message ChannelBackups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBackups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.chanBackups = [];
            if (message.chanBackups && message.chanBackups.length) {
                object.chanBackups = [];
                for (let j = 0; j < message.chanBackups.length; ++j)
                    object.chanBackups[j] = $root.lnrpc.ChannelBackup.toObject(message.chanBackups[j], options);
            }
            return object;
        };

        /**
         * Converts this ChannelBackups to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBackups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBackups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBackups;
    })();

    lnrpc.RestoreChanBackupRequest = (function() {

        /**
         * Properties of a RestoreChanBackupRequest.
         * @memberof lnrpc
         * @interface IRestoreChanBackupRequest
         * @property {lnrpc.IChannelBackups|null} [chanBackups] RestoreChanBackupRequest chanBackups
         * @property {Uint8Array|null} [multiChanBackup] RestoreChanBackupRequest multiChanBackup
         */

        /**
         * Constructs a new RestoreChanBackupRequest.
         * @memberof lnrpc
         * @classdesc Represents a RestoreChanBackupRequest.
         * @implements IRestoreChanBackupRequest
         * @constructor
         * @param {lnrpc.IRestoreChanBackupRequest=} [properties] Properties to set
         */
        function RestoreChanBackupRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RestoreChanBackupRequest chanBackups.
         * @member {lnrpc.IChannelBackups|null|undefined} chanBackups
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         */
        RestoreChanBackupRequest.prototype.chanBackups = null;

        /**
         * RestoreChanBackupRequest multiChanBackup.
         * @member {Uint8Array|null|undefined} multiChanBackup
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         */
        RestoreChanBackupRequest.prototype.multiChanBackup = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * RestoreChanBackupRequest backup.
         * @member {"chanBackups"|"multiChanBackup"|undefined} backup
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         */
        Object.defineProperty(RestoreChanBackupRequest.prototype, "backup", {
            get: $util.oneOfGetter($oneOfFields = ["chanBackups", "multiChanBackup"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RestoreChanBackupRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.IRestoreChanBackupRequest=} [properties] Properties to set
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest instance
         */
        RestoreChanBackupRequest.create = function create(properties) {
            return new RestoreChanBackupRequest(properties);
        };

        /**
         * Encodes the specified RestoreChanBackupRequest message. Does not implicitly {@link lnrpc.RestoreChanBackupRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.IRestoreChanBackupRequest} message RestoreChanBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreChanBackupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanBackups != null && Object.hasOwnProperty.call(message, "chanBackups"))
                $root.lnrpc.ChannelBackups.encode(message.chanBackups, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.multiChanBackup != null && Object.hasOwnProperty.call(message, "multiChanBackup"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.multiChanBackup);
            return writer;
        };

        /**
         * Encodes the specified RestoreChanBackupRequest message, length delimited. Does not implicitly {@link lnrpc.RestoreChanBackupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.IRestoreChanBackupRequest} message RestoreChanBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreChanBackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreChanBackupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreChanBackupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RestoreChanBackupRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanBackups = $root.lnrpc.ChannelBackups.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.multiChanBackup = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreChanBackupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreChanBackupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreChanBackupRequest message.
         * @function verify
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreChanBackupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups")) {
                properties.backup = 1;
                {
                    let error = $root.lnrpc.ChannelBackups.verify(message.chanBackups);
                    if (error)
                        return "chanBackups." + error;
                }
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup")) {
                if (properties.backup === 1)
                    return "backup: multiple values";
                properties.backup = 1;
                if (!(message.multiChanBackup && typeof message.multiChanBackup.length === "number" || $util.isString(message.multiChanBackup)))
                    return "multiChanBackup: buffer expected";
            }
            return null;
        };

        /**
         * Creates a RestoreChanBackupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest
         */
        RestoreChanBackupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RestoreChanBackupRequest)
                return object;
            let message = new $root.lnrpc.RestoreChanBackupRequest();
            if (object.chanBackups != null) {
                if (typeof object.chanBackups !== "object")
                    throw TypeError(".lnrpc.RestoreChanBackupRequest.chanBackups: object expected");
                message.chanBackups = $root.lnrpc.ChannelBackups.fromObject(object.chanBackups);
            }
            if (object.multiChanBackup != null)
                if (typeof object.multiChanBackup === "string")
                    $util.base64.decode(object.multiChanBackup, message.multiChanBackup = $util.newBuffer($util.base64.length(object.multiChanBackup)), 0);
                else if (object.multiChanBackup.length)
                    message.multiChanBackup = object.multiChanBackup;
            return message;
        };

        /**
         * Creates a plain object from a RestoreChanBackupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.RestoreChanBackupRequest} message RestoreChanBackupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreChanBackupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups")) {
                object.chanBackups = $root.lnrpc.ChannelBackups.toObject(message.chanBackups, options);
                if (options.oneofs)
                    object.backup = "chanBackups";
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup")) {
                object.multiChanBackup = options.bytes === String ? $util.base64.encode(message.multiChanBackup, 0, message.multiChanBackup.length) : options.bytes === Array ? Array.prototype.slice.call(message.multiChanBackup) : message.multiChanBackup;
                if (options.oneofs)
                    object.backup = "multiChanBackup";
            }
            return object;
        };

        /**
         * Converts this RestoreChanBackupRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreChanBackupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RestoreChanBackupRequest;
    })();

    lnrpc.RestoreBackupResponse = (function() {

        /**
         * Properties of a RestoreBackupResponse.
         * @memberof lnrpc
         * @interface IRestoreBackupResponse
         */

        /**
         * Constructs a new RestoreBackupResponse.
         * @memberof lnrpc
         * @classdesc Represents a RestoreBackupResponse.
         * @implements IRestoreBackupResponse
         * @constructor
         * @param {lnrpc.IRestoreBackupResponse=} [properties] Properties to set
         */
        function RestoreBackupResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RestoreBackupResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.IRestoreBackupResponse=} [properties] Properties to set
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse instance
         */
        RestoreBackupResponse.create = function create(properties) {
            return new RestoreBackupResponse(properties);
        };

        /**
         * Encodes the specified RestoreBackupResponse message. Does not implicitly {@link lnrpc.RestoreBackupResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.IRestoreBackupResponse} message RestoreBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreBackupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RestoreBackupResponse message, length delimited. Does not implicitly {@link lnrpc.RestoreBackupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.IRestoreBackupResponse} message RestoreBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreBackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreBackupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreBackupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RestoreBackupResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreBackupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreBackupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreBackupResponse message.
         * @function verify
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreBackupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RestoreBackupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse
         */
        RestoreBackupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RestoreBackupResponse)
                return object;
            return new $root.lnrpc.RestoreBackupResponse();
        };

        /**
         * Creates a plain object from a RestoreBackupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.RestoreBackupResponse} message RestoreBackupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreBackupResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RestoreBackupResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.RestoreBackupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreBackupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RestoreBackupResponse;
    })();

    lnrpc.ChannelBackupSubscription = (function() {

        /**
         * Properties of a ChannelBackupSubscription.
         * @memberof lnrpc
         * @interface IChannelBackupSubscription
         */

        /**
         * Constructs a new ChannelBackupSubscription.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBackupSubscription.
         * @implements IChannelBackupSubscription
         * @constructor
         * @param {lnrpc.IChannelBackupSubscription=} [properties] Properties to set
         */
        function ChannelBackupSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelBackupSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.IChannelBackupSubscription=} [properties] Properties to set
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription instance
         */
        ChannelBackupSubscription.create = function create(properties) {
            return new ChannelBackupSubscription(properties);
        };

        /**
         * Encodes the specified ChannelBackupSubscription message. Does not implicitly {@link lnrpc.ChannelBackupSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.IChannelBackupSubscription} message ChannelBackupSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackupSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelBackupSubscription message, length delimited. Does not implicitly {@link lnrpc.ChannelBackupSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.IChannelBackupSubscription} message ChannelBackupSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackupSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBackupSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackupSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBackupSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBackupSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackupSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBackupSubscription message.
         * @function verify
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBackupSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelBackupSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription
         */
        ChannelBackupSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBackupSubscription)
                return object;
            return new $root.lnrpc.ChannelBackupSubscription();
        };

        /**
         * Creates a plain object from a ChannelBackupSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.ChannelBackupSubscription} message ChannelBackupSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBackupSubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelBackupSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBackupSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBackupSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBackupSubscription;
    })();

    lnrpc.VerifyChanBackupResponse = (function() {

        /**
         * Properties of a VerifyChanBackupResponse.
         * @memberof lnrpc
         * @interface IVerifyChanBackupResponse
         */

        /**
         * Constructs a new VerifyChanBackupResponse.
         * @memberof lnrpc
         * @classdesc Represents a VerifyChanBackupResponse.
         * @implements IVerifyChanBackupResponse
         * @constructor
         * @param {lnrpc.IVerifyChanBackupResponse=} [properties] Properties to set
         */
        function VerifyChanBackupResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new VerifyChanBackupResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.IVerifyChanBackupResponse=} [properties] Properties to set
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse instance
         */
        VerifyChanBackupResponse.create = function create(properties) {
            return new VerifyChanBackupResponse(properties);
        };

        /**
         * Encodes the specified VerifyChanBackupResponse message. Does not implicitly {@link lnrpc.VerifyChanBackupResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.IVerifyChanBackupResponse} message VerifyChanBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyChanBackupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified VerifyChanBackupResponse message, length delimited. Does not implicitly {@link lnrpc.VerifyChanBackupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.IVerifyChanBackupResponse} message VerifyChanBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyChanBackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyChanBackupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyChanBackupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyChanBackupResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyChanBackupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyChanBackupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyChanBackupResponse message.
         * @function verify
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyChanBackupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a VerifyChanBackupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse
         */
        VerifyChanBackupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyChanBackupResponse)
                return object;
            return new $root.lnrpc.VerifyChanBackupResponse();
        };

        /**
         * Creates a plain object from a VerifyChanBackupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.VerifyChanBackupResponse} message VerifyChanBackupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyChanBackupResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this VerifyChanBackupResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyChanBackupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyChanBackupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyChanBackupResponse;
    })();

    lnrpc.MacaroonPermission = (function() {

        /**
         * Properties of a MacaroonPermission.
         * @memberof lnrpc
         * @interface IMacaroonPermission
         * @property {string|null} [entity] MacaroonPermission entity
         * @property {string|null} [action] MacaroonPermission action
         */

        /**
         * Constructs a new MacaroonPermission.
         * @memberof lnrpc
         * @classdesc Represents a MacaroonPermission.
         * @implements IMacaroonPermission
         * @constructor
         * @param {lnrpc.IMacaroonPermission=} [properties] Properties to set
         */
        function MacaroonPermission(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MacaroonPermission entity.
         * @member {string} entity
         * @memberof lnrpc.MacaroonPermission
         * @instance
         */
        MacaroonPermission.prototype.entity = "";

        /**
         * MacaroonPermission action.
         * @member {string} action
         * @memberof lnrpc.MacaroonPermission
         * @instance
         */
        MacaroonPermission.prototype.action = "";

        /**
         * Creates a new MacaroonPermission instance using the specified properties.
         * @function create
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {lnrpc.IMacaroonPermission=} [properties] Properties to set
         * @returns {lnrpc.MacaroonPermission} MacaroonPermission instance
         */
        MacaroonPermission.create = function create(properties) {
            return new MacaroonPermission(properties);
        };

        /**
         * Encodes the specified MacaroonPermission message. Does not implicitly {@link lnrpc.MacaroonPermission.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {lnrpc.IMacaroonPermission} message MacaroonPermission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MacaroonPermission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.entity);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.action);
            return writer;
        };

        /**
         * Encodes the specified MacaroonPermission message, length delimited. Does not implicitly {@link lnrpc.MacaroonPermission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {lnrpc.IMacaroonPermission} message MacaroonPermission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MacaroonPermission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MacaroonPermission message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.MacaroonPermission} MacaroonPermission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MacaroonPermission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.MacaroonPermission();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity = reader.string();
                    break;
                case 2:
                    message.action = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MacaroonPermission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.MacaroonPermission} MacaroonPermission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MacaroonPermission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MacaroonPermission message.
         * @function verify
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MacaroonPermission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isString(message.entity))
                    return "entity: string expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isString(message.action))
                    return "action: string expected";
            return null;
        };

        /**
         * Creates a MacaroonPermission message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.MacaroonPermission} MacaroonPermission
         */
        MacaroonPermission.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.MacaroonPermission)
                return object;
            let message = new $root.lnrpc.MacaroonPermission();
            if (object.entity != null)
                message.entity = String(object.entity);
            if (object.action != null)
                message.action = String(object.action);
            return message;
        };

        /**
         * Creates a plain object from a MacaroonPermission message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.MacaroonPermission
         * @static
         * @param {lnrpc.MacaroonPermission} message MacaroonPermission
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MacaroonPermission.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.entity = "";
                object.action = "";
            }
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            return object;
        };

        /**
         * Converts this MacaroonPermission to JSON.
         * @function toJSON
         * @memberof lnrpc.MacaroonPermission
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MacaroonPermission.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MacaroonPermission;
    })();

    lnrpc.BakeMacaroonRequest = (function() {

        /**
         * Properties of a BakeMacaroonRequest.
         * @memberof lnrpc
         * @interface IBakeMacaroonRequest
         * @property {Array.<lnrpc.IMacaroonPermission>|null} [permissions] BakeMacaroonRequest permissions
         * @property {number|Long|null} [rootKeyId] BakeMacaroonRequest rootKeyId
         */

        /**
         * Constructs a new BakeMacaroonRequest.
         * @memberof lnrpc
         * @classdesc Represents a BakeMacaroonRequest.
         * @implements IBakeMacaroonRequest
         * @constructor
         * @param {lnrpc.IBakeMacaroonRequest=} [properties] Properties to set
         */
        function BakeMacaroonRequest(properties) {
            this.permissions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BakeMacaroonRequest permissions.
         * @member {Array.<lnrpc.IMacaroonPermission>} permissions
         * @memberof lnrpc.BakeMacaroonRequest
         * @instance
         */
        BakeMacaroonRequest.prototype.permissions = $util.emptyArray;

        /**
         * BakeMacaroonRequest rootKeyId.
         * @member {number|Long} rootKeyId
         * @memberof lnrpc.BakeMacaroonRequest
         * @instance
         */
        BakeMacaroonRequest.prototype.rootKeyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new BakeMacaroonRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {lnrpc.IBakeMacaroonRequest=} [properties] Properties to set
         * @returns {lnrpc.BakeMacaroonRequest} BakeMacaroonRequest instance
         */
        BakeMacaroonRequest.create = function create(properties) {
            return new BakeMacaroonRequest(properties);
        };

        /**
         * Encodes the specified BakeMacaroonRequest message. Does not implicitly {@link lnrpc.BakeMacaroonRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {lnrpc.IBakeMacaroonRequest} message BakeMacaroonRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BakeMacaroonRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.permissions != null && message.permissions.length)
                for (let i = 0; i < message.permissions.length; ++i)
                    $root.lnrpc.MacaroonPermission.encode(message.permissions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rootKeyId != null && Object.hasOwnProperty.call(message, "rootKeyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rootKeyId);
            return writer;
        };

        /**
         * Encodes the specified BakeMacaroonRequest message, length delimited. Does not implicitly {@link lnrpc.BakeMacaroonRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {lnrpc.IBakeMacaroonRequest} message BakeMacaroonRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BakeMacaroonRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BakeMacaroonRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.BakeMacaroonRequest} BakeMacaroonRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BakeMacaroonRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.BakeMacaroonRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.permissions && message.permissions.length))
                        message.permissions = [];
                    message.permissions.push($root.lnrpc.MacaroonPermission.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.rootKeyId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BakeMacaroonRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.BakeMacaroonRequest} BakeMacaroonRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BakeMacaroonRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BakeMacaroonRequest message.
         * @function verify
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BakeMacaroonRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                if (!Array.isArray(message.permissions))
                    return "permissions: array expected";
                for (let i = 0; i < message.permissions.length; ++i) {
                    let error = $root.lnrpc.MacaroonPermission.verify(message.permissions[i]);
                    if (error)
                        return "permissions." + error;
                }
            }
            if (message.rootKeyId != null && message.hasOwnProperty("rootKeyId"))
                if (!$util.isInteger(message.rootKeyId) && !(message.rootKeyId && $util.isInteger(message.rootKeyId.low) && $util.isInteger(message.rootKeyId.high)))
                    return "rootKeyId: integer|Long expected";
            return null;
        };

        /**
         * Creates a BakeMacaroonRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.BakeMacaroonRequest} BakeMacaroonRequest
         */
        BakeMacaroonRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.BakeMacaroonRequest)
                return object;
            let message = new $root.lnrpc.BakeMacaroonRequest();
            if (object.permissions) {
                if (!Array.isArray(object.permissions))
                    throw TypeError(".lnrpc.BakeMacaroonRequest.permissions: array expected");
                message.permissions = [];
                for (let i = 0; i < object.permissions.length; ++i) {
                    if (typeof object.permissions[i] !== "object")
                        throw TypeError(".lnrpc.BakeMacaroonRequest.permissions: object expected");
                    message.permissions[i] = $root.lnrpc.MacaroonPermission.fromObject(object.permissions[i]);
                }
            }
            if (object.rootKeyId != null)
                if ($util.Long)
                    (message.rootKeyId = $util.Long.fromValue(object.rootKeyId)).unsigned = true;
                else if (typeof object.rootKeyId === "string")
                    message.rootKeyId = parseInt(object.rootKeyId, 10);
                else if (typeof object.rootKeyId === "number")
                    message.rootKeyId = object.rootKeyId;
                else if (typeof object.rootKeyId === "object")
                    message.rootKeyId = new $util.LongBits(object.rootKeyId.low >>> 0, object.rootKeyId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a BakeMacaroonRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.BakeMacaroonRequest
         * @static
         * @param {lnrpc.BakeMacaroonRequest} message BakeMacaroonRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BakeMacaroonRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.permissions = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.rootKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rootKeyId = options.longs === String ? "0" : 0;
            if (message.permissions && message.permissions.length) {
                object.permissions = [];
                for (let j = 0; j < message.permissions.length; ++j)
                    object.permissions[j] = $root.lnrpc.MacaroonPermission.toObject(message.permissions[j], options);
            }
            if (message.rootKeyId != null && message.hasOwnProperty("rootKeyId"))
                if (typeof message.rootKeyId === "number")
                    object.rootKeyId = options.longs === String ? String(message.rootKeyId) : message.rootKeyId;
                else
                    object.rootKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.rootKeyId) : options.longs === Number ? new $util.LongBits(message.rootKeyId.low >>> 0, message.rootKeyId.high >>> 0).toNumber(true) : message.rootKeyId;
            return object;
        };

        /**
         * Converts this BakeMacaroonRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.BakeMacaroonRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BakeMacaroonRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BakeMacaroonRequest;
    })();

    lnrpc.BakeMacaroonResponse = (function() {

        /**
         * Properties of a BakeMacaroonResponse.
         * @memberof lnrpc
         * @interface IBakeMacaroonResponse
         * @property {string|null} [macaroon] BakeMacaroonResponse macaroon
         */

        /**
         * Constructs a new BakeMacaroonResponse.
         * @memberof lnrpc
         * @classdesc Represents a BakeMacaroonResponse.
         * @implements IBakeMacaroonResponse
         * @constructor
         * @param {lnrpc.IBakeMacaroonResponse=} [properties] Properties to set
         */
        function BakeMacaroonResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BakeMacaroonResponse macaroon.
         * @member {string} macaroon
         * @memberof lnrpc.BakeMacaroonResponse
         * @instance
         */
        BakeMacaroonResponse.prototype.macaroon = "";

        /**
         * Creates a new BakeMacaroonResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {lnrpc.IBakeMacaroonResponse=} [properties] Properties to set
         * @returns {lnrpc.BakeMacaroonResponse} BakeMacaroonResponse instance
         */
        BakeMacaroonResponse.create = function create(properties) {
            return new BakeMacaroonResponse(properties);
        };

        /**
         * Encodes the specified BakeMacaroonResponse message. Does not implicitly {@link lnrpc.BakeMacaroonResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {lnrpc.IBakeMacaroonResponse} message BakeMacaroonResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BakeMacaroonResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.macaroon != null && Object.hasOwnProperty.call(message, "macaroon"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.macaroon);
            return writer;
        };

        /**
         * Encodes the specified BakeMacaroonResponse message, length delimited. Does not implicitly {@link lnrpc.BakeMacaroonResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {lnrpc.IBakeMacaroonResponse} message BakeMacaroonResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BakeMacaroonResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BakeMacaroonResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.BakeMacaroonResponse} BakeMacaroonResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BakeMacaroonResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.BakeMacaroonResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.macaroon = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BakeMacaroonResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.BakeMacaroonResponse} BakeMacaroonResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BakeMacaroonResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BakeMacaroonResponse message.
         * @function verify
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BakeMacaroonResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.macaroon != null && message.hasOwnProperty("macaroon"))
                if (!$util.isString(message.macaroon))
                    return "macaroon: string expected";
            return null;
        };

        /**
         * Creates a BakeMacaroonResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.BakeMacaroonResponse} BakeMacaroonResponse
         */
        BakeMacaroonResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.BakeMacaroonResponse)
                return object;
            let message = new $root.lnrpc.BakeMacaroonResponse();
            if (object.macaroon != null)
                message.macaroon = String(object.macaroon);
            return message;
        };

        /**
         * Creates a plain object from a BakeMacaroonResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.BakeMacaroonResponse
         * @static
         * @param {lnrpc.BakeMacaroonResponse} message BakeMacaroonResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BakeMacaroonResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.macaroon = "";
            if (message.macaroon != null && message.hasOwnProperty("macaroon"))
                object.macaroon = message.macaroon;
            return object;
        };

        /**
         * Converts this BakeMacaroonResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.BakeMacaroonResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BakeMacaroonResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BakeMacaroonResponse;
    })();

    lnrpc.ListMacaroonIDsRequest = (function() {

        /**
         * Properties of a ListMacaroonIDsRequest.
         * @memberof lnrpc
         * @interface IListMacaroonIDsRequest
         */

        /**
         * Constructs a new ListMacaroonIDsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListMacaroonIDsRequest.
         * @implements IListMacaroonIDsRequest
         * @constructor
         * @param {lnrpc.IListMacaroonIDsRequest=} [properties] Properties to set
         */
        function ListMacaroonIDsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ListMacaroonIDsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {lnrpc.IListMacaroonIDsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListMacaroonIDsRequest} ListMacaroonIDsRequest instance
         */
        ListMacaroonIDsRequest.create = function create(properties) {
            return new ListMacaroonIDsRequest(properties);
        };

        /**
         * Encodes the specified ListMacaroonIDsRequest message. Does not implicitly {@link lnrpc.ListMacaroonIDsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {lnrpc.IListMacaroonIDsRequest} message ListMacaroonIDsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMacaroonIDsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ListMacaroonIDsRequest message, length delimited. Does not implicitly {@link lnrpc.ListMacaroonIDsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {lnrpc.IListMacaroonIDsRequest} message ListMacaroonIDsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMacaroonIDsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListMacaroonIDsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListMacaroonIDsRequest} ListMacaroonIDsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMacaroonIDsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListMacaroonIDsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListMacaroonIDsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListMacaroonIDsRequest} ListMacaroonIDsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMacaroonIDsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListMacaroonIDsRequest message.
         * @function verify
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListMacaroonIDsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ListMacaroonIDsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListMacaroonIDsRequest} ListMacaroonIDsRequest
         */
        ListMacaroonIDsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListMacaroonIDsRequest)
                return object;
            return new $root.lnrpc.ListMacaroonIDsRequest();
        };

        /**
         * Creates a plain object from a ListMacaroonIDsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @static
         * @param {lnrpc.ListMacaroonIDsRequest} message ListMacaroonIDsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListMacaroonIDsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ListMacaroonIDsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListMacaroonIDsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListMacaroonIDsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListMacaroonIDsRequest;
    })();

    lnrpc.ListMacaroonIDsResponse = (function() {

        /**
         * Properties of a ListMacaroonIDsResponse.
         * @memberof lnrpc
         * @interface IListMacaroonIDsResponse
         * @property {Array.<number|Long>|null} [rootKeyIds] ListMacaroonIDsResponse rootKeyIds
         */

        /**
         * Constructs a new ListMacaroonIDsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListMacaroonIDsResponse.
         * @implements IListMacaroonIDsResponse
         * @constructor
         * @param {lnrpc.IListMacaroonIDsResponse=} [properties] Properties to set
         */
        function ListMacaroonIDsResponse(properties) {
            this.rootKeyIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListMacaroonIDsResponse rootKeyIds.
         * @member {Array.<number|Long>} rootKeyIds
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @instance
         */
        ListMacaroonIDsResponse.prototype.rootKeyIds = $util.emptyArray;

        /**
         * Creates a new ListMacaroonIDsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {lnrpc.IListMacaroonIDsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListMacaroonIDsResponse} ListMacaroonIDsResponse instance
         */
        ListMacaroonIDsResponse.create = function create(properties) {
            return new ListMacaroonIDsResponse(properties);
        };

        /**
         * Encodes the specified ListMacaroonIDsResponse message. Does not implicitly {@link lnrpc.ListMacaroonIDsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {lnrpc.IListMacaroonIDsResponse} message ListMacaroonIDsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMacaroonIDsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rootKeyIds != null && message.rootKeyIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.rootKeyIds.length; ++i)
                    writer.uint64(message.rootKeyIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ListMacaroonIDsResponse message, length delimited. Does not implicitly {@link lnrpc.ListMacaroonIDsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {lnrpc.IListMacaroonIDsResponse} message ListMacaroonIDsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListMacaroonIDsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListMacaroonIDsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListMacaroonIDsResponse} ListMacaroonIDsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMacaroonIDsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListMacaroonIDsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rootKeyIds && message.rootKeyIds.length))
                        message.rootKeyIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rootKeyIds.push(reader.uint64());
                    } else
                        message.rootKeyIds.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListMacaroonIDsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListMacaroonIDsResponse} ListMacaroonIDsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListMacaroonIDsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListMacaroonIDsResponse message.
         * @function verify
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListMacaroonIDsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rootKeyIds != null && message.hasOwnProperty("rootKeyIds")) {
                if (!Array.isArray(message.rootKeyIds))
                    return "rootKeyIds: array expected";
                for (let i = 0; i < message.rootKeyIds.length; ++i)
                    if (!$util.isInteger(message.rootKeyIds[i]) && !(message.rootKeyIds[i] && $util.isInteger(message.rootKeyIds[i].low) && $util.isInteger(message.rootKeyIds[i].high)))
                        return "rootKeyIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a ListMacaroonIDsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListMacaroonIDsResponse} ListMacaroonIDsResponse
         */
        ListMacaroonIDsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListMacaroonIDsResponse)
                return object;
            let message = new $root.lnrpc.ListMacaroonIDsResponse();
            if (object.rootKeyIds) {
                if (!Array.isArray(object.rootKeyIds))
                    throw TypeError(".lnrpc.ListMacaroonIDsResponse.rootKeyIds: array expected");
                message.rootKeyIds = [];
                for (let i = 0; i < object.rootKeyIds.length; ++i)
                    if ($util.Long)
                        (message.rootKeyIds[i] = $util.Long.fromValue(object.rootKeyIds[i])).unsigned = true;
                    else if (typeof object.rootKeyIds[i] === "string")
                        message.rootKeyIds[i] = parseInt(object.rootKeyIds[i], 10);
                    else if (typeof object.rootKeyIds[i] === "number")
                        message.rootKeyIds[i] = object.rootKeyIds[i];
                    else if (typeof object.rootKeyIds[i] === "object")
                        message.rootKeyIds[i] = new $util.LongBits(object.rootKeyIds[i].low >>> 0, object.rootKeyIds[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a ListMacaroonIDsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @static
         * @param {lnrpc.ListMacaroonIDsResponse} message ListMacaroonIDsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListMacaroonIDsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.rootKeyIds = [];
            if (message.rootKeyIds && message.rootKeyIds.length) {
                object.rootKeyIds = [];
                for (let j = 0; j < message.rootKeyIds.length; ++j)
                    if (typeof message.rootKeyIds[j] === "number")
                        object.rootKeyIds[j] = options.longs === String ? String(message.rootKeyIds[j]) : message.rootKeyIds[j];
                    else
                        object.rootKeyIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.rootKeyIds[j]) : options.longs === Number ? new $util.LongBits(message.rootKeyIds[j].low >>> 0, message.rootKeyIds[j].high >>> 0).toNumber(true) : message.rootKeyIds[j];
            }
            return object;
        };

        /**
         * Converts this ListMacaroonIDsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListMacaroonIDsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListMacaroonIDsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListMacaroonIDsResponse;
    })();

    lnrpc.DeleteMacaroonIDRequest = (function() {

        /**
         * Properties of a DeleteMacaroonIDRequest.
         * @memberof lnrpc
         * @interface IDeleteMacaroonIDRequest
         * @property {number|Long|null} [rootKeyId] DeleteMacaroonIDRequest rootKeyId
         */

        /**
         * Constructs a new DeleteMacaroonIDRequest.
         * @memberof lnrpc
         * @classdesc Represents a DeleteMacaroonIDRequest.
         * @implements IDeleteMacaroonIDRequest
         * @constructor
         * @param {lnrpc.IDeleteMacaroonIDRequest=} [properties] Properties to set
         */
        function DeleteMacaroonIDRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteMacaroonIDRequest rootKeyId.
         * @member {number|Long} rootKeyId
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @instance
         */
        DeleteMacaroonIDRequest.prototype.rootKeyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new DeleteMacaroonIDRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {lnrpc.IDeleteMacaroonIDRequest=} [properties] Properties to set
         * @returns {lnrpc.DeleteMacaroonIDRequest} DeleteMacaroonIDRequest instance
         */
        DeleteMacaroonIDRequest.create = function create(properties) {
            return new DeleteMacaroonIDRequest(properties);
        };

        /**
         * Encodes the specified DeleteMacaroonIDRequest message. Does not implicitly {@link lnrpc.DeleteMacaroonIDRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {lnrpc.IDeleteMacaroonIDRequest} message DeleteMacaroonIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMacaroonIDRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rootKeyId != null && Object.hasOwnProperty.call(message, "rootKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rootKeyId);
            return writer;
        };

        /**
         * Encodes the specified DeleteMacaroonIDRequest message, length delimited. Does not implicitly {@link lnrpc.DeleteMacaroonIDRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {lnrpc.IDeleteMacaroonIDRequest} message DeleteMacaroonIDRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMacaroonIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteMacaroonIDRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteMacaroonIDRequest} DeleteMacaroonIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMacaroonIDRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteMacaroonIDRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rootKeyId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteMacaroonIDRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteMacaroonIDRequest} DeleteMacaroonIDRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMacaroonIDRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteMacaroonIDRequest message.
         * @function verify
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteMacaroonIDRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rootKeyId != null && message.hasOwnProperty("rootKeyId"))
                if (!$util.isInteger(message.rootKeyId) && !(message.rootKeyId && $util.isInteger(message.rootKeyId.low) && $util.isInteger(message.rootKeyId.high)))
                    return "rootKeyId: integer|Long expected";
            return null;
        };

        /**
         * Creates a DeleteMacaroonIDRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteMacaroonIDRequest} DeleteMacaroonIDRequest
         */
        DeleteMacaroonIDRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteMacaroonIDRequest)
                return object;
            let message = new $root.lnrpc.DeleteMacaroonIDRequest();
            if (object.rootKeyId != null)
                if ($util.Long)
                    (message.rootKeyId = $util.Long.fromValue(object.rootKeyId)).unsigned = true;
                else if (typeof object.rootKeyId === "string")
                    message.rootKeyId = parseInt(object.rootKeyId, 10);
                else if (typeof object.rootKeyId === "number")
                    message.rootKeyId = object.rootKeyId;
                else if (typeof object.rootKeyId === "object")
                    message.rootKeyId = new $util.LongBits(object.rootKeyId.low >>> 0, object.rootKeyId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a DeleteMacaroonIDRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @static
         * @param {lnrpc.DeleteMacaroonIDRequest} message DeleteMacaroonIDRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteMacaroonIDRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.rootKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rootKeyId = options.longs === String ? "0" : 0;
            if (message.rootKeyId != null && message.hasOwnProperty("rootKeyId"))
                if (typeof message.rootKeyId === "number")
                    object.rootKeyId = options.longs === String ? String(message.rootKeyId) : message.rootKeyId;
                else
                    object.rootKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.rootKeyId) : options.longs === Number ? new $util.LongBits(message.rootKeyId.low >>> 0, message.rootKeyId.high >>> 0).toNumber(true) : message.rootKeyId;
            return object;
        };

        /**
         * Converts this DeleteMacaroonIDRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteMacaroonIDRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteMacaroonIDRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteMacaroonIDRequest;
    })();

    lnrpc.DeleteMacaroonIDResponse = (function() {

        /**
         * Properties of a DeleteMacaroonIDResponse.
         * @memberof lnrpc
         * @interface IDeleteMacaroonIDResponse
         * @property {boolean|null} [deleted] DeleteMacaroonIDResponse deleted
         */

        /**
         * Constructs a new DeleteMacaroonIDResponse.
         * @memberof lnrpc
         * @classdesc Represents a DeleteMacaroonIDResponse.
         * @implements IDeleteMacaroonIDResponse
         * @constructor
         * @param {lnrpc.IDeleteMacaroonIDResponse=} [properties] Properties to set
         */
        function DeleteMacaroonIDResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteMacaroonIDResponse deleted.
         * @member {boolean} deleted
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @instance
         */
        DeleteMacaroonIDResponse.prototype.deleted = false;

        /**
         * Creates a new DeleteMacaroonIDResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {lnrpc.IDeleteMacaroonIDResponse=} [properties] Properties to set
         * @returns {lnrpc.DeleteMacaroonIDResponse} DeleteMacaroonIDResponse instance
         */
        DeleteMacaroonIDResponse.create = function create(properties) {
            return new DeleteMacaroonIDResponse(properties);
        };

        /**
         * Encodes the specified DeleteMacaroonIDResponse message. Does not implicitly {@link lnrpc.DeleteMacaroonIDResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {lnrpc.IDeleteMacaroonIDResponse} message DeleteMacaroonIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMacaroonIDResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deleted);
            return writer;
        };

        /**
         * Encodes the specified DeleteMacaroonIDResponse message, length delimited. Does not implicitly {@link lnrpc.DeleteMacaroonIDResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {lnrpc.IDeleteMacaroonIDResponse} message DeleteMacaroonIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteMacaroonIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteMacaroonIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteMacaroonIDResponse} DeleteMacaroonIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMacaroonIDResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteMacaroonIDResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deleted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteMacaroonIDResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteMacaroonIDResponse} DeleteMacaroonIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteMacaroonIDResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteMacaroonIDResponse message.
         * @function verify
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteMacaroonIDResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deleted != null && message.hasOwnProperty("deleted"))
                if (typeof message.deleted !== "boolean")
                    return "deleted: boolean expected";
            return null;
        };

        /**
         * Creates a DeleteMacaroonIDResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteMacaroonIDResponse} DeleteMacaroonIDResponse
         */
        DeleteMacaroonIDResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteMacaroonIDResponse)
                return object;
            let message = new $root.lnrpc.DeleteMacaroonIDResponse();
            if (object.deleted != null)
                message.deleted = Boolean(object.deleted);
            return message;
        };

        /**
         * Creates a plain object from a DeleteMacaroonIDResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @static
         * @param {lnrpc.DeleteMacaroonIDResponse} message DeleteMacaroonIDResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteMacaroonIDResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.deleted = false;
            if (message.deleted != null && message.hasOwnProperty("deleted"))
                object.deleted = message.deleted;
            return object;
        };

        /**
         * Converts this DeleteMacaroonIDResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteMacaroonIDResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteMacaroonIDResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteMacaroonIDResponse;
    })();

    lnrpc.MacaroonPermissionList = (function() {

        /**
         * Properties of a MacaroonPermissionList.
         * @memberof lnrpc
         * @interface IMacaroonPermissionList
         * @property {Array.<lnrpc.IMacaroonPermission>|null} [permissions] MacaroonPermissionList permissions
         */

        /**
         * Constructs a new MacaroonPermissionList.
         * @memberof lnrpc
         * @classdesc Represents a MacaroonPermissionList.
         * @implements IMacaroonPermissionList
         * @constructor
         * @param {lnrpc.IMacaroonPermissionList=} [properties] Properties to set
         */
        function MacaroonPermissionList(properties) {
            this.permissions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MacaroonPermissionList permissions.
         * @member {Array.<lnrpc.IMacaroonPermission>} permissions
         * @memberof lnrpc.MacaroonPermissionList
         * @instance
         */
        MacaroonPermissionList.prototype.permissions = $util.emptyArray;

        /**
         * Creates a new MacaroonPermissionList instance using the specified properties.
         * @function create
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {lnrpc.IMacaroonPermissionList=} [properties] Properties to set
         * @returns {lnrpc.MacaroonPermissionList} MacaroonPermissionList instance
         */
        MacaroonPermissionList.create = function create(properties) {
            return new MacaroonPermissionList(properties);
        };

        /**
         * Encodes the specified MacaroonPermissionList message. Does not implicitly {@link lnrpc.MacaroonPermissionList.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {lnrpc.IMacaroonPermissionList} message MacaroonPermissionList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MacaroonPermissionList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.permissions != null && message.permissions.length)
                for (let i = 0; i < message.permissions.length; ++i)
                    $root.lnrpc.MacaroonPermission.encode(message.permissions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MacaroonPermissionList message, length delimited. Does not implicitly {@link lnrpc.MacaroonPermissionList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {lnrpc.IMacaroonPermissionList} message MacaroonPermissionList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MacaroonPermissionList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MacaroonPermissionList message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.MacaroonPermissionList} MacaroonPermissionList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MacaroonPermissionList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.MacaroonPermissionList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.permissions && message.permissions.length))
                        message.permissions = [];
                    message.permissions.push($root.lnrpc.MacaroonPermission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MacaroonPermissionList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.MacaroonPermissionList} MacaroonPermissionList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MacaroonPermissionList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MacaroonPermissionList message.
         * @function verify
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MacaroonPermissionList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                if (!Array.isArray(message.permissions))
                    return "permissions: array expected";
                for (let i = 0; i < message.permissions.length; ++i) {
                    let error = $root.lnrpc.MacaroonPermission.verify(message.permissions[i]);
                    if (error)
                        return "permissions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MacaroonPermissionList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.MacaroonPermissionList} MacaroonPermissionList
         */
        MacaroonPermissionList.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.MacaroonPermissionList)
                return object;
            let message = new $root.lnrpc.MacaroonPermissionList();
            if (object.permissions) {
                if (!Array.isArray(object.permissions))
                    throw TypeError(".lnrpc.MacaroonPermissionList.permissions: array expected");
                message.permissions = [];
                for (let i = 0; i < object.permissions.length; ++i) {
                    if (typeof object.permissions[i] !== "object")
                        throw TypeError(".lnrpc.MacaroonPermissionList.permissions: object expected");
                    message.permissions[i] = $root.lnrpc.MacaroonPermission.fromObject(object.permissions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MacaroonPermissionList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.MacaroonPermissionList
         * @static
         * @param {lnrpc.MacaroonPermissionList} message MacaroonPermissionList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MacaroonPermissionList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.permissions = [];
            if (message.permissions && message.permissions.length) {
                object.permissions = [];
                for (let j = 0; j < message.permissions.length; ++j)
                    object.permissions[j] = $root.lnrpc.MacaroonPermission.toObject(message.permissions[j], options);
            }
            return object;
        };

        /**
         * Converts this MacaroonPermissionList to JSON.
         * @function toJSON
         * @memberof lnrpc.MacaroonPermissionList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MacaroonPermissionList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MacaroonPermissionList;
    })();

    lnrpc.ListPermissionsRequest = (function() {

        /**
         * Properties of a ListPermissionsRequest.
         * @memberof lnrpc
         * @interface IListPermissionsRequest
         */

        /**
         * Constructs a new ListPermissionsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPermissionsRequest.
         * @implements IListPermissionsRequest
         * @constructor
         * @param {lnrpc.IListPermissionsRequest=} [properties] Properties to set
         */
        function ListPermissionsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ListPermissionsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {lnrpc.IListPermissionsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPermissionsRequest} ListPermissionsRequest instance
         */
        ListPermissionsRequest.create = function create(properties) {
            return new ListPermissionsRequest(properties);
        };

        /**
         * Encodes the specified ListPermissionsRequest message. Does not implicitly {@link lnrpc.ListPermissionsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {lnrpc.IListPermissionsRequest} message ListPermissionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPermissionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ListPermissionsRequest message, length delimited. Does not implicitly {@link lnrpc.ListPermissionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {lnrpc.IListPermissionsRequest} message ListPermissionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPermissionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPermissionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPermissionsRequest} ListPermissionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPermissionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPermissionsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPermissionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPermissionsRequest} ListPermissionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPermissionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPermissionsRequest message.
         * @function verify
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPermissionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ListPermissionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPermissionsRequest} ListPermissionsRequest
         */
        ListPermissionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPermissionsRequest)
                return object;
            return new $root.lnrpc.ListPermissionsRequest();
        };

        /**
         * Creates a plain object from a ListPermissionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPermissionsRequest
         * @static
         * @param {lnrpc.ListPermissionsRequest} message ListPermissionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPermissionsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ListPermissionsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPermissionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPermissionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPermissionsRequest;
    })();

    lnrpc.ListPermissionsResponse = (function() {

        /**
         * Properties of a ListPermissionsResponse.
         * @memberof lnrpc
         * @interface IListPermissionsResponse
         * @property {Object.<string,lnrpc.IMacaroonPermissionList>|null} [methodPermissions] ListPermissionsResponse methodPermissions
         */

        /**
         * Constructs a new ListPermissionsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPermissionsResponse.
         * @implements IListPermissionsResponse
         * @constructor
         * @param {lnrpc.IListPermissionsResponse=} [properties] Properties to set
         */
        function ListPermissionsResponse(properties) {
            this.methodPermissions = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPermissionsResponse methodPermissions.
         * @member {Object.<string,lnrpc.IMacaroonPermissionList>} methodPermissions
         * @memberof lnrpc.ListPermissionsResponse
         * @instance
         */
        ListPermissionsResponse.prototype.methodPermissions = $util.emptyObject;

        /**
         * Creates a new ListPermissionsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {lnrpc.IListPermissionsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPermissionsResponse} ListPermissionsResponse instance
         */
        ListPermissionsResponse.create = function create(properties) {
            return new ListPermissionsResponse(properties);
        };

        /**
         * Encodes the specified ListPermissionsResponse message. Does not implicitly {@link lnrpc.ListPermissionsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {lnrpc.IListPermissionsResponse} message ListPermissionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPermissionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.methodPermissions != null && Object.hasOwnProperty.call(message, "methodPermissions"))
                for (let keys = Object.keys(message.methodPermissions), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.lnrpc.MacaroonPermissionList.encode(message.methodPermissions[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified ListPermissionsResponse message, length delimited. Does not implicitly {@link lnrpc.ListPermissionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {lnrpc.IListPermissionsResponse} message ListPermissionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPermissionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPermissionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPermissionsResponse} ListPermissionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPermissionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPermissionsResponse(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.methodPermissions === $util.emptyObject)
                        message.methodPermissions = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.lnrpc.MacaroonPermissionList.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.methodPermissions[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPermissionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPermissionsResponse} ListPermissionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPermissionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPermissionsResponse message.
         * @function verify
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPermissionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.methodPermissions != null && message.hasOwnProperty("methodPermissions")) {
                if (!$util.isObject(message.methodPermissions))
                    return "methodPermissions: object expected";
                let key = Object.keys(message.methodPermissions);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.lnrpc.MacaroonPermissionList.verify(message.methodPermissions[key[i]]);
                    if (error)
                        return "methodPermissions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPermissionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPermissionsResponse} ListPermissionsResponse
         */
        ListPermissionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPermissionsResponse)
                return object;
            let message = new $root.lnrpc.ListPermissionsResponse();
            if (object.methodPermissions) {
                if (typeof object.methodPermissions !== "object")
                    throw TypeError(".lnrpc.ListPermissionsResponse.methodPermissions: object expected");
                message.methodPermissions = {};
                for (let keys = Object.keys(object.methodPermissions), i = 0; i < keys.length; ++i) {
                    if (typeof object.methodPermissions[keys[i]] !== "object")
                        throw TypeError(".lnrpc.ListPermissionsResponse.methodPermissions: object expected");
                    message.methodPermissions[keys[i]] = $root.lnrpc.MacaroonPermissionList.fromObject(object.methodPermissions[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPermissionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPermissionsResponse
         * @static
         * @param {lnrpc.ListPermissionsResponse} message ListPermissionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPermissionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.methodPermissions = {};
            let keys2;
            if (message.methodPermissions && (keys2 = Object.keys(message.methodPermissions)).length) {
                object.methodPermissions = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.methodPermissions[keys2[j]] = $root.lnrpc.MacaroonPermissionList.toObject(message.methodPermissions[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this ListPermissionsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPermissionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPermissionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPermissionsResponse;
    })();

    lnrpc.Failure = (function() {

        /**
         * Properties of a Failure.
         * @memberof lnrpc
         * @interface IFailure
         * @property {lnrpc.Failure.FailureCode|null} [code] Failure code
         * @property {lnrpc.IChannelUpdate|null} [channelUpdate] Failure channelUpdate
         * @property {number|Long|null} [htlcMsat] Failure htlcMsat
         * @property {Uint8Array|null} [onionSha_256] Failure onionSha_256
         * @property {number|null} [cltvExpiry] Failure cltvExpiry
         * @property {number|null} [flags] Failure flags
         * @property {number|null} [failureSourceIndex] Failure failureSourceIndex
         * @property {number|null} [height] Failure height
         */

        /**
         * Constructs a new Failure.
         * @memberof lnrpc
         * @classdesc Represents a Failure.
         * @implements IFailure
         * @constructor
         * @param {lnrpc.IFailure=} [properties] Properties to set
         */
        function Failure(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Failure code.
         * @member {lnrpc.Failure.FailureCode} code
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.code = 0;

        /**
         * Failure channelUpdate.
         * @member {lnrpc.IChannelUpdate|null|undefined} channelUpdate
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.channelUpdate = null;

        /**
         * Failure htlcMsat.
         * @member {number|Long} htlcMsat
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.htlcMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Failure onionSha_256.
         * @member {Uint8Array} onionSha_256
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.onionSha_256 = $util.newBuffer([]);

        /**
         * Failure cltvExpiry.
         * @member {number} cltvExpiry
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.cltvExpiry = 0;

        /**
         * Failure flags.
         * @member {number} flags
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.flags = 0;

        /**
         * Failure failureSourceIndex.
         * @member {number} failureSourceIndex
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.failureSourceIndex = 0;

        /**
         * Failure height.
         * @member {number} height
         * @memberof lnrpc.Failure
         * @instance
         */
        Failure.prototype.height = 0;

        /**
         * Creates a new Failure instance using the specified properties.
         * @function create
         * @memberof lnrpc.Failure
         * @static
         * @param {lnrpc.IFailure=} [properties] Properties to set
         * @returns {lnrpc.Failure} Failure instance
         */
        Failure.create = function create(properties) {
            return new Failure(properties);
        };

        /**
         * Encodes the specified Failure message. Does not implicitly {@link lnrpc.Failure.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Failure
         * @static
         * @param {lnrpc.IFailure} message Failure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Failure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            if (message.channelUpdate != null && Object.hasOwnProperty.call(message, "channelUpdate"))
                $root.lnrpc.ChannelUpdate.encode(message.channelUpdate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.htlcMsat != null && Object.hasOwnProperty.call(message, "htlcMsat"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.htlcMsat);
            if (message.onionSha_256 != null && Object.hasOwnProperty.call(message, "onionSha_256"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.onionSha_256);
            if (message.cltvExpiry != null && Object.hasOwnProperty.call(message, "cltvExpiry"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.cltvExpiry);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.flags);
            if (message.failureSourceIndex != null && Object.hasOwnProperty.call(message, "failureSourceIndex"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.failureSourceIndex);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.height);
            return writer;
        };

        /**
         * Encodes the specified Failure message, length delimited. Does not implicitly {@link lnrpc.Failure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Failure
         * @static
         * @param {lnrpc.IFailure} message Failure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Failure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Failure message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Failure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Failure} Failure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Failure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Failure();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 3:
                    message.channelUpdate = $root.lnrpc.ChannelUpdate.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.htlcMsat = reader.uint64();
                    break;
                case 5:
                    message.onionSha_256 = reader.bytes();
                    break;
                case 6:
                    message.cltvExpiry = reader.uint32();
                    break;
                case 7:
                    message.flags = reader.uint32();
                    break;
                case 8:
                    message.failureSourceIndex = reader.uint32();
                    break;
                case 9:
                    message.height = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Failure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Failure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Failure} Failure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Failure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Failure message.
         * @function verify
         * @memberof lnrpc.Failure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Failure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                switch (message.code) {
                default:
                    return "code: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 997:
                case 998:
                case 999:
                    break;
                }
            if (message.channelUpdate != null && message.hasOwnProperty("channelUpdate")) {
                let error = $root.lnrpc.ChannelUpdate.verify(message.channelUpdate);
                if (error)
                    return "channelUpdate." + error;
            }
            if (message.htlcMsat != null && message.hasOwnProperty("htlcMsat"))
                if (!$util.isInteger(message.htlcMsat) && !(message.htlcMsat && $util.isInteger(message.htlcMsat.low) && $util.isInteger(message.htlcMsat.high)))
                    return "htlcMsat: integer|Long expected";
            if (message.onionSha_256 != null && message.hasOwnProperty("onionSha_256"))
                if (!(message.onionSha_256 && typeof message.onionSha_256.length === "number" || $util.isString(message.onionSha_256)))
                    return "onionSha_256: buffer expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry))
                    return "cltvExpiry: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.failureSourceIndex != null && message.hasOwnProperty("failureSourceIndex"))
                if (!$util.isInteger(message.failureSourceIndex))
                    return "failureSourceIndex: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            return null;
        };

        /**
         * Creates a Failure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Failure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Failure} Failure
         */
        Failure.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Failure)
                return object;
            let message = new $root.lnrpc.Failure();
            switch (object.code) {
            case "RESERVED":
            case 0:
                message.code = 0;
                break;
            case "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS":
            case 1:
                message.code = 1;
                break;
            case "INCORRECT_PAYMENT_AMOUNT":
            case 2:
                message.code = 2;
                break;
            case "FINAL_INCORRECT_CLTV_EXPIRY":
            case 3:
                message.code = 3;
                break;
            case "FINAL_INCORRECT_HTLC_AMOUNT":
            case 4:
                message.code = 4;
                break;
            case "FINAL_EXPIRY_TOO_SOON":
            case 5:
                message.code = 5;
                break;
            case "INVALID_REALM":
            case 6:
                message.code = 6;
                break;
            case "EXPIRY_TOO_SOON":
            case 7:
                message.code = 7;
                break;
            case "INVALID_ONION_VERSION":
            case 8:
                message.code = 8;
                break;
            case "INVALID_ONION_HMAC":
            case 9:
                message.code = 9;
                break;
            case "INVALID_ONION_KEY":
            case 10:
                message.code = 10;
                break;
            case "AMOUNT_BELOW_MINIMUM":
            case 11:
                message.code = 11;
                break;
            case "FEE_INSUFFICIENT":
            case 12:
                message.code = 12;
                break;
            case "INCORRECT_CLTV_EXPIRY":
            case 13:
                message.code = 13;
                break;
            case "CHANNEL_DISABLED":
            case 14:
                message.code = 14;
                break;
            case "TEMPORARY_CHANNEL_FAILURE":
            case 15:
                message.code = 15;
                break;
            case "REQUIRED_NODE_FEATURE_MISSING":
            case 16:
                message.code = 16;
                break;
            case "REQUIRED_CHANNEL_FEATURE_MISSING":
            case 17:
                message.code = 17;
                break;
            case "UNKNOWN_NEXT_PEER":
            case 18:
                message.code = 18;
                break;
            case "TEMPORARY_NODE_FAILURE":
            case 19:
                message.code = 19;
                break;
            case "PERMANENT_NODE_FAILURE":
            case 20:
                message.code = 20;
                break;
            case "PERMANENT_CHANNEL_FAILURE":
            case 21:
                message.code = 21;
                break;
            case "EXPIRY_TOO_FAR":
            case 22:
                message.code = 22;
                break;
            case "MPP_TIMEOUT":
            case 23:
                message.code = 23;
                break;
            case "INTERNAL_FAILURE":
            case 997:
                message.code = 997;
                break;
            case "UNKNOWN_FAILURE":
            case 998:
                message.code = 998;
                break;
            case "UNREADABLE_FAILURE":
            case 999:
                message.code = 999;
                break;
            }
            if (object.channelUpdate != null) {
                if (typeof object.channelUpdate !== "object")
                    throw TypeError(".lnrpc.Failure.channelUpdate: object expected");
                message.channelUpdate = $root.lnrpc.ChannelUpdate.fromObject(object.channelUpdate);
            }
            if (object.htlcMsat != null)
                if ($util.Long)
                    (message.htlcMsat = $util.Long.fromValue(object.htlcMsat)).unsigned = true;
                else if (typeof object.htlcMsat === "string")
                    message.htlcMsat = parseInt(object.htlcMsat, 10);
                else if (typeof object.htlcMsat === "number")
                    message.htlcMsat = object.htlcMsat;
                else if (typeof object.htlcMsat === "object")
                    message.htlcMsat = new $util.LongBits(object.htlcMsat.low >>> 0, object.htlcMsat.high >>> 0).toNumber(true);
            if (object.onionSha_256 != null)
                if (typeof object.onionSha_256 === "string")
                    $util.base64.decode(object.onionSha_256, message.onionSha_256 = $util.newBuffer($util.base64.length(object.onionSha_256)), 0);
                else if (object.onionSha_256.length)
                    message.onionSha_256 = object.onionSha_256;
            if (object.cltvExpiry != null)
                message.cltvExpiry = object.cltvExpiry >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.failureSourceIndex != null)
                message.failureSourceIndex = object.failureSourceIndex >>> 0;
            if (object.height != null)
                message.height = object.height >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Failure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Failure
         * @static
         * @param {lnrpc.Failure} message Failure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Failure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.code = options.enums === String ? "RESERVED" : 0;
                object.channelUpdate = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.htlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.htlcMsat = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.onionSha_256 = "";
                else {
                    object.onionSha_256 = [];
                    if (options.bytes !== Array)
                        object.onionSha_256 = $util.newBuffer(object.onionSha_256);
                }
                object.cltvExpiry = 0;
                object.flags = 0;
                object.failureSourceIndex = 0;
                object.height = 0;
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.enums === String ? $root.lnrpc.Failure.FailureCode[message.code] : message.code;
            if (message.channelUpdate != null && message.hasOwnProperty("channelUpdate"))
                object.channelUpdate = $root.lnrpc.ChannelUpdate.toObject(message.channelUpdate, options);
            if (message.htlcMsat != null && message.hasOwnProperty("htlcMsat"))
                if (typeof message.htlcMsat === "number")
                    object.htlcMsat = options.longs === String ? String(message.htlcMsat) : message.htlcMsat;
                else
                    object.htlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.htlcMsat) : options.longs === Number ? new $util.LongBits(message.htlcMsat.low >>> 0, message.htlcMsat.high >>> 0).toNumber(true) : message.htlcMsat;
            if (message.onionSha_256 != null && message.hasOwnProperty("onionSha_256"))
                object.onionSha_256 = options.bytes === String ? $util.base64.encode(message.onionSha_256, 0, message.onionSha_256.length) : options.bytes === Array ? Array.prototype.slice.call(message.onionSha_256) : message.onionSha_256;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                object.cltvExpiry = message.cltvExpiry;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.failureSourceIndex != null && message.hasOwnProperty("failureSourceIndex"))
                object.failureSourceIndex = message.failureSourceIndex;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            return object;
        };

        /**
         * Converts this Failure to JSON.
         * @function toJSON
         * @memberof lnrpc.Failure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Failure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * FailureCode enum.
         * @name lnrpc.Failure.FailureCode
         * @enum {number}
         * @property {number} RESERVED=0 RESERVED value
         * @property {number} INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS=1 INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS value
         * @property {number} INCORRECT_PAYMENT_AMOUNT=2 INCORRECT_PAYMENT_AMOUNT value
         * @property {number} FINAL_INCORRECT_CLTV_EXPIRY=3 FINAL_INCORRECT_CLTV_EXPIRY value
         * @property {number} FINAL_INCORRECT_HTLC_AMOUNT=4 FINAL_INCORRECT_HTLC_AMOUNT value
         * @property {number} FINAL_EXPIRY_TOO_SOON=5 FINAL_EXPIRY_TOO_SOON value
         * @property {number} INVALID_REALM=6 INVALID_REALM value
         * @property {number} EXPIRY_TOO_SOON=7 EXPIRY_TOO_SOON value
         * @property {number} INVALID_ONION_VERSION=8 INVALID_ONION_VERSION value
         * @property {number} INVALID_ONION_HMAC=9 INVALID_ONION_HMAC value
         * @property {number} INVALID_ONION_KEY=10 INVALID_ONION_KEY value
         * @property {number} AMOUNT_BELOW_MINIMUM=11 AMOUNT_BELOW_MINIMUM value
         * @property {number} FEE_INSUFFICIENT=12 FEE_INSUFFICIENT value
         * @property {number} INCORRECT_CLTV_EXPIRY=13 INCORRECT_CLTV_EXPIRY value
         * @property {number} CHANNEL_DISABLED=14 CHANNEL_DISABLED value
         * @property {number} TEMPORARY_CHANNEL_FAILURE=15 TEMPORARY_CHANNEL_FAILURE value
         * @property {number} REQUIRED_NODE_FEATURE_MISSING=16 REQUIRED_NODE_FEATURE_MISSING value
         * @property {number} REQUIRED_CHANNEL_FEATURE_MISSING=17 REQUIRED_CHANNEL_FEATURE_MISSING value
         * @property {number} UNKNOWN_NEXT_PEER=18 UNKNOWN_NEXT_PEER value
         * @property {number} TEMPORARY_NODE_FAILURE=19 TEMPORARY_NODE_FAILURE value
         * @property {number} PERMANENT_NODE_FAILURE=20 PERMANENT_NODE_FAILURE value
         * @property {number} PERMANENT_CHANNEL_FAILURE=21 PERMANENT_CHANNEL_FAILURE value
         * @property {number} EXPIRY_TOO_FAR=22 EXPIRY_TOO_FAR value
         * @property {number} MPP_TIMEOUT=23 MPP_TIMEOUT value
         * @property {number} INTERNAL_FAILURE=997 INTERNAL_FAILURE value
         * @property {number} UNKNOWN_FAILURE=998 UNKNOWN_FAILURE value
         * @property {number} UNREADABLE_FAILURE=999 UNREADABLE_FAILURE value
         */
        Failure.FailureCode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RESERVED"] = 0;
            values[valuesById[1] = "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS"] = 1;
            values[valuesById[2] = "INCORRECT_PAYMENT_AMOUNT"] = 2;
            values[valuesById[3] = "FINAL_INCORRECT_CLTV_EXPIRY"] = 3;
            values[valuesById[4] = "FINAL_INCORRECT_HTLC_AMOUNT"] = 4;
            values[valuesById[5] = "FINAL_EXPIRY_TOO_SOON"] = 5;
            values[valuesById[6] = "INVALID_REALM"] = 6;
            values[valuesById[7] = "EXPIRY_TOO_SOON"] = 7;
            values[valuesById[8] = "INVALID_ONION_VERSION"] = 8;
            values[valuesById[9] = "INVALID_ONION_HMAC"] = 9;
            values[valuesById[10] = "INVALID_ONION_KEY"] = 10;
            values[valuesById[11] = "AMOUNT_BELOW_MINIMUM"] = 11;
            values[valuesById[12] = "FEE_INSUFFICIENT"] = 12;
            values[valuesById[13] = "INCORRECT_CLTV_EXPIRY"] = 13;
            values[valuesById[14] = "CHANNEL_DISABLED"] = 14;
            values[valuesById[15] = "TEMPORARY_CHANNEL_FAILURE"] = 15;
            values[valuesById[16] = "REQUIRED_NODE_FEATURE_MISSING"] = 16;
            values[valuesById[17] = "REQUIRED_CHANNEL_FEATURE_MISSING"] = 17;
            values[valuesById[18] = "UNKNOWN_NEXT_PEER"] = 18;
            values[valuesById[19] = "TEMPORARY_NODE_FAILURE"] = 19;
            values[valuesById[20] = "PERMANENT_NODE_FAILURE"] = 20;
            values[valuesById[21] = "PERMANENT_CHANNEL_FAILURE"] = 21;
            values[valuesById[22] = "EXPIRY_TOO_FAR"] = 22;
            values[valuesById[23] = "MPP_TIMEOUT"] = 23;
            values[valuesById[997] = "INTERNAL_FAILURE"] = 997;
            values[valuesById[998] = "UNKNOWN_FAILURE"] = 998;
            values[valuesById[999] = "UNREADABLE_FAILURE"] = 999;
            return values;
        })();

        return Failure;
    })();

    lnrpc.ChannelUpdate = (function() {

        /**
         * Properties of a ChannelUpdate.
         * @memberof lnrpc
         * @interface IChannelUpdate
         * @property {Uint8Array|null} [signature] ChannelUpdate signature
         * @property {Uint8Array|null} [chainHash] ChannelUpdate chainHash
         * @property {number|Long|null} [chanId] ChannelUpdate chanId
         * @property {number|null} [timestamp] ChannelUpdate timestamp
         * @property {number|null} [messageFlags] ChannelUpdate messageFlags
         * @property {number|null} [channelFlags] ChannelUpdate channelFlags
         * @property {number|null} [timeLockDelta] ChannelUpdate timeLockDelta
         * @property {number|Long|null} [htlcMinimumMsat] ChannelUpdate htlcMinimumMsat
         * @property {number|null} [baseFee] ChannelUpdate baseFee
         * @property {number|null} [feeRate] ChannelUpdate feeRate
         * @property {number|Long|null} [htlcMaximumMsat] ChannelUpdate htlcMaximumMsat
         * @property {Uint8Array|null} [extraOpaqueData] ChannelUpdate extraOpaqueData
         */

        /**
         * Constructs a new ChannelUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelUpdate.
         * @implements IChannelUpdate
         * @constructor
         * @param {lnrpc.IChannelUpdate=} [properties] Properties to set
         */
        function ChannelUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelUpdate signature.
         * @member {Uint8Array} signature
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.signature = $util.newBuffer([]);

        /**
         * ChannelUpdate chainHash.
         * @member {Uint8Array} chainHash
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.chainHash = $util.newBuffer([]);

        /**
         * ChannelUpdate chanId.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelUpdate timestamp.
         * @member {number} timestamp
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.timestamp = 0;

        /**
         * ChannelUpdate messageFlags.
         * @member {number} messageFlags
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.messageFlags = 0;

        /**
         * ChannelUpdate channelFlags.
         * @member {number} channelFlags
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.channelFlags = 0;

        /**
         * ChannelUpdate timeLockDelta.
         * @member {number} timeLockDelta
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.timeLockDelta = 0;

        /**
         * ChannelUpdate htlcMinimumMsat.
         * @member {number|Long} htlcMinimumMsat
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.htlcMinimumMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelUpdate baseFee.
         * @member {number} baseFee
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.baseFee = 0;

        /**
         * ChannelUpdate feeRate.
         * @member {number} feeRate
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.feeRate = 0;

        /**
         * ChannelUpdate htlcMaximumMsat.
         * @member {number|Long} htlcMaximumMsat
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.htlcMaximumMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelUpdate extraOpaqueData.
         * @member {Uint8Array} extraOpaqueData
         * @memberof lnrpc.ChannelUpdate
         * @instance
         */
        ChannelUpdate.prototype.extraOpaqueData = $util.newBuffer([]);

        /**
         * Creates a new ChannelUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {lnrpc.IChannelUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelUpdate} ChannelUpdate instance
         */
        ChannelUpdate.create = function create(properties) {
            return new ChannelUpdate(properties);
        };

        /**
         * Encodes the specified ChannelUpdate message. Does not implicitly {@link lnrpc.ChannelUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {lnrpc.IChannelUpdate} message ChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
            if (message.chainHash != null && Object.hasOwnProperty.call(message, "chainHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.chainHash);
            if (message.chanId != null && Object.hasOwnProperty.call(message, "chanId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.chanId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timestamp);
            if (message.channelFlags != null && Object.hasOwnProperty.call(message, "channelFlags"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.channelFlags);
            if (message.timeLockDelta != null && Object.hasOwnProperty.call(message, "timeLockDelta"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.timeLockDelta);
            if (message.htlcMinimumMsat != null && Object.hasOwnProperty.call(message, "htlcMinimumMsat"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.htlcMinimumMsat);
            if (message.baseFee != null && Object.hasOwnProperty.call(message, "baseFee"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.baseFee);
            if (message.feeRate != null && Object.hasOwnProperty.call(message, "feeRate"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.feeRate);
            if (message.messageFlags != null && Object.hasOwnProperty.call(message, "messageFlags"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.messageFlags);
            if (message.htlcMaximumMsat != null && Object.hasOwnProperty.call(message, "htlcMaximumMsat"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.htlcMaximumMsat);
            if (message.extraOpaqueData != null && Object.hasOwnProperty.call(message, "extraOpaqueData"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.extraOpaqueData);
            return writer;
        };

        /**
         * Encodes the specified ChannelUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {lnrpc.IChannelUpdate} message ChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelUpdate} ChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = reader.bytes();
                    break;
                case 2:
                    message.chainHash = reader.bytes();
                    break;
                case 3:
                    message.chanId = reader.uint64();
                    break;
                case 4:
                    message.timestamp = reader.uint32();
                    break;
                case 10:
                    message.messageFlags = reader.uint32();
                    break;
                case 5:
                    message.channelFlags = reader.uint32();
                    break;
                case 6:
                    message.timeLockDelta = reader.uint32();
                    break;
                case 7:
                    message.htlcMinimumMsat = reader.uint64();
                    break;
                case 8:
                    message.baseFee = reader.uint32();
                    break;
                case 9:
                    message.feeRate = reader.uint32();
                    break;
                case 11:
                    message.htlcMaximumMsat = reader.uint64();
                    break;
                case 12:
                    message.extraOpaqueData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelUpdate} ChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                if (!(message.chainHash && typeof message.chainHash.length === "number" || $util.isString(message.chainHash)))
                    return "chainHash: buffer expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.messageFlags != null && message.hasOwnProperty("messageFlags"))
                if (!$util.isInteger(message.messageFlags))
                    return "messageFlags: integer expected";
            if (message.channelFlags != null && message.hasOwnProperty("channelFlags"))
                if (!$util.isInteger(message.channelFlags))
                    return "channelFlags: integer expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            if (message.htlcMinimumMsat != null && message.hasOwnProperty("htlcMinimumMsat"))
                if (!$util.isInteger(message.htlcMinimumMsat) && !(message.htlcMinimumMsat && $util.isInteger(message.htlcMinimumMsat.low) && $util.isInteger(message.htlcMinimumMsat.high)))
                    return "htlcMinimumMsat: integer|Long expected";
            if (message.baseFee != null && message.hasOwnProperty("baseFee"))
                if (!$util.isInteger(message.baseFee))
                    return "baseFee: integer expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (!$util.isInteger(message.feeRate))
                    return "feeRate: integer expected";
            if (message.htlcMaximumMsat != null && message.hasOwnProperty("htlcMaximumMsat"))
                if (!$util.isInteger(message.htlcMaximumMsat) && !(message.htlcMaximumMsat && $util.isInteger(message.htlcMaximumMsat.low) && $util.isInteger(message.htlcMaximumMsat.high)))
                    return "htlcMaximumMsat: integer|Long expected";
            if (message.extraOpaqueData != null && message.hasOwnProperty("extraOpaqueData"))
                if (!(message.extraOpaqueData && typeof message.extraOpaqueData.length === "number" || $util.isString(message.extraOpaqueData)))
                    return "extraOpaqueData: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelUpdate} ChannelUpdate
         */
        ChannelUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelUpdate)
                return object;
            let message = new $root.lnrpc.ChannelUpdate();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.chainHash != null)
                if (typeof object.chainHash === "string")
                    $util.base64.decode(object.chainHash, message.chainHash = $util.newBuffer($util.base64.length(object.chainHash)), 0);
                else if (object.chainHash.length)
                    message.chainHash = object.chainHash;
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.messageFlags != null)
                message.messageFlags = object.messageFlags >>> 0;
            if (object.channelFlags != null)
                message.channelFlags = object.channelFlags >>> 0;
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            if (object.htlcMinimumMsat != null)
                if ($util.Long)
                    (message.htlcMinimumMsat = $util.Long.fromValue(object.htlcMinimumMsat)).unsigned = true;
                else if (typeof object.htlcMinimumMsat === "string")
                    message.htlcMinimumMsat = parseInt(object.htlcMinimumMsat, 10);
                else if (typeof object.htlcMinimumMsat === "number")
                    message.htlcMinimumMsat = object.htlcMinimumMsat;
                else if (typeof object.htlcMinimumMsat === "object")
                    message.htlcMinimumMsat = new $util.LongBits(object.htlcMinimumMsat.low >>> 0, object.htlcMinimumMsat.high >>> 0).toNumber(true);
            if (object.baseFee != null)
                message.baseFee = object.baseFee >>> 0;
            if (object.feeRate != null)
                message.feeRate = object.feeRate >>> 0;
            if (object.htlcMaximumMsat != null)
                if ($util.Long)
                    (message.htlcMaximumMsat = $util.Long.fromValue(object.htlcMaximumMsat)).unsigned = true;
                else if (typeof object.htlcMaximumMsat === "string")
                    message.htlcMaximumMsat = parseInt(object.htlcMaximumMsat, 10);
                else if (typeof object.htlcMaximumMsat === "number")
                    message.htlcMaximumMsat = object.htlcMaximumMsat;
                else if (typeof object.htlcMaximumMsat === "object")
                    message.htlcMaximumMsat = new $util.LongBits(object.htlcMaximumMsat.low >>> 0, object.htlcMaximumMsat.high >>> 0).toNumber(true);
            if (object.extraOpaqueData != null)
                if (typeof object.extraOpaqueData === "string")
                    $util.base64.decode(object.extraOpaqueData, message.extraOpaqueData = $util.newBuffer($util.base64.length(object.extraOpaqueData)), 0);
                else if (object.extraOpaqueData.length)
                    message.extraOpaqueData = object.extraOpaqueData;
            return message;
        };

        /**
         * Creates a plain object from a ChannelUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelUpdate
         * @static
         * @param {lnrpc.ChannelUpdate} message ChannelUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if (options.bytes === String)
                    object.chainHash = "";
                else {
                    object.chainHash = [];
                    if (options.bytes !== Array)
                        object.chainHash = $util.newBuffer(object.chainHash);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.timestamp = 0;
                object.channelFlags = 0;
                object.timeLockDelta = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.htlcMinimumMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.htlcMinimumMsat = options.longs === String ? "0" : 0;
                object.baseFee = 0;
                object.feeRate = 0;
                object.messageFlags = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.htlcMaximumMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.htlcMaximumMsat = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.extraOpaqueData = "";
                else {
                    object.extraOpaqueData = [];
                    if (options.bytes !== Array)
                        object.extraOpaqueData = $util.newBuffer(object.extraOpaqueData);
                }
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                object.chainHash = options.bytes === String ? $util.base64.encode(message.chainHash, 0, message.chainHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainHash) : message.chainHash;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.channelFlags != null && message.hasOwnProperty("channelFlags"))
                object.channelFlags = message.channelFlags;
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            if (message.htlcMinimumMsat != null && message.hasOwnProperty("htlcMinimumMsat"))
                if (typeof message.htlcMinimumMsat === "number")
                    object.htlcMinimumMsat = options.longs === String ? String(message.htlcMinimumMsat) : message.htlcMinimumMsat;
                else
                    object.htlcMinimumMsat = options.longs === String ? $util.Long.prototype.toString.call(message.htlcMinimumMsat) : options.longs === Number ? new $util.LongBits(message.htlcMinimumMsat.low >>> 0, message.htlcMinimumMsat.high >>> 0).toNumber(true) : message.htlcMinimumMsat;
            if (message.baseFee != null && message.hasOwnProperty("baseFee"))
                object.baseFee = message.baseFee;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = message.feeRate;
            if (message.messageFlags != null && message.hasOwnProperty("messageFlags"))
                object.messageFlags = message.messageFlags;
            if (message.htlcMaximumMsat != null && message.hasOwnProperty("htlcMaximumMsat"))
                if (typeof message.htlcMaximumMsat === "number")
                    object.htlcMaximumMsat = options.longs === String ? String(message.htlcMaximumMsat) : message.htlcMaximumMsat;
                else
                    object.htlcMaximumMsat = options.longs === String ? $util.Long.prototype.toString.call(message.htlcMaximumMsat) : options.longs === Number ? new $util.LongBits(message.htlcMaximumMsat.low >>> 0, message.htlcMaximumMsat.high >>> 0).toNumber(true) : message.htlcMaximumMsat;
            if (message.extraOpaqueData != null && message.hasOwnProperty("extraOpaqueData"))
                object.extraOpaqueData = options.bytes === String ? $util.base64.encode(message.extraOpaqueData, 0, message.extraOpaqueData.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraOpaqueData) : message.extraOpaqueData;
            return object;
        };

        /**
         * Converts this ChannelUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelUpdate;
    })();

    lnrpc.MacaroonId = (function() {

        /**
         * Properties of a MacaroonId.
         * @memberof lnrpc
         * @interface IMacaroonId
         * @property {Uint8Array|null} [nonce] MacaroonId nonce
         * @property {Uint8Array|null} [storageId] MacaroonId storageId
         * @property {Array.<lnrpc.IOp>|null} [ops] MacaroonId ops
         */

        /**
         * Constructs a new MacaroonId.
         * @memberof lnrpc
         * @classdesc Represents a MacaroonId.
         * @implements IMacaroonId
         * @constructor
         * @param {lnrpc.IMacaroonId=} [properties] Properties to set
         */
        function MacaroonId(properties) {
            this.ops = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MacaroonId nonce.
         * @member {Uint8Array} nonce
         * @memberof lnrpc.MacaroonId
         * @instance
         */
        MacaroonId.prototype.nonce = $util.newBuffer([]);

        /**
         * MacaroonId storageId.
         * @member {Uint8Array} storageId
         * @memberof lnrpc.MacaroonId
         * @instance
         */
        MacaroonId.prototype.storageId = $util.newBuffer([]);

        /**
         * MacaroonId ops.
         * @member {Array.<lnrpc.IOp>} ops
         * @memberof lnrpc.MacaroonId
         * @instance
         */
        MacaroonId.prototype.ops = $util.emptyArray;

        /**
         * Creates a new MacaroonId instance using the specified properties.
         * @function create
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {lnrpc.IMacaroonId=} [properties] Properties to set
         * @returns {lnrpc.MacaroonId} MacaroonId instance
         */
        MacaroonId.create = function create(properties) {
            return new MacaroonId(properties);
        };

        /**
         * Encodes the specified MacaroonId message. Does not implicitly {@link lnrpc.MacaroonId.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {lnrpc.IMacaroonId} message MacaroonId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MacaroonId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
            if (message.storageId != null && Object.hasOwnProperty.call(message, "storageId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.storageId);
            if (message.ops != null && message.ops.length)
                for (let i = 0; i < message.ops.length; ++i)
                    $root.lnrpc.Op.encode(message.ops[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MacaroonId message, length delimited. Does not implicitly {@link lnrpc.MacaroonId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {lnrpc.IMacaroonId} message MacaroonId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MacaroonId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MacaroonId message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.MacaroonId} MacaroonId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MacaroonId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.MacaroonId();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nonce = reader.bytes();
                    break;
                case 2:
                    message.storageId = reader.bytes();
                    break;
                case 3:
                    if (!(message.ops && message.ops.length))
                        message.ops = [];
                    message.ops.push($root.lnrpc.Op.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MacaroonId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.MacaroonId} MacaroonId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MacaroonId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MacaroonId message.
         * @function verify
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MacaroonId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                    return "nonce: buffer expected";
            if (message.storageId != null && message.hasOwnProperty("storageId"))
                if (!(message.storageId && typeof message.storageId.length === "number" || $util.isString(message.storageId)))
                    return "storageId: buffer expected";
            if (message.ops != null && message.hasOwnProperty("ops")) {
                if (!Array.isArray(message.ops))
                    return "ops: array expected";
                for (let i = 0; i < message.ops.length; ++i) {
                    let error = $root.lnrpc.Op.verify(message.ops[i]);
                    if (error)
                        return "ops." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MacaroonId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.MacaroonId} MacaroonId
         */
        MacaroonId.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.MacaroonId)
                return object;
            let message = new $root.lnrpc.MacaroonId();
            if (object.nonce != null)
                if (typeof object.nonce === "string")
                    $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                else if (object.nonce.length)
                    message.nonce = object.nonce;
            if (object.storageId != null)
                if (typeof object.storageId === "string")
                    $util.base64.decode(object.storageId, message.storageId = $util.newBuffer($util.base64.length(object.storageId)), 0);
                else if (object.storageId.length)
                    message.storageId = object.storageId;
            if (object.ops) {
                if (!Array.isArray(object.ops))
                    throw TypeError(".lnrpc.MacaroonId.ops: array expected");
                message.ops = [];
                for (let i = 0; i < object.ops.length; ++i) {
                    if (typeof object.ops[i] !== "object")
                        throw TypeError(".lnrpc.MacaroonId.ops: object expected");
                    message.ops[i] = $root.lnrpc.Op.fromObject(object.ops[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MacaroonId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.MacaroonId
         * @static
         * @param {lnrpc.MacaroonId} message MacaroonId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MacaroonId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ops = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.nonce = "";
                else {
                    object.nonce = [];
                    if (options.bytes !== Array)
                        object.nonce = $util.newBuffer(object.nonce);
                }
                if (options.bytes === String)
                    object.storageId = "";
                else {
                    object.storageId = [];
                    if (options.bytes !== Array)
                        object.storageId = $util.newBuffer(object.storageId);
                }
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
            if (message.storageId != null && message.hasOwnProperty("storageId"))
                object.storageId = options.bytes === String ? $util.base64.encode(message.storageId, 0, message.storageId.length) : options.bytes === Array ? Array.prototype.slice.call(message.storageId) : message.storageId;
            if (message.ops && message.ops.length) {
                object.ops = [];
                for (let j = 0; j < message.ops.length; ++j)
                    object.ops[j] = $root.lnrpc.Op.toObject(message.ops[j], options);
            }
            return object;
        };

        /**
         * Converts this MacaroonId to JSON.
         * @function toJSON
         * @memberof lnrpc.MacaroonId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MacaroonId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MacaroonId;
    })();

    lnrpc.Op = (function() {

        /**
         * Properties of an Op.
         * @memberof lnrpc
         * @interface IOp
         * @property {string|null} [entity] Op entity
         * @property {Array.<string>|null} [actions] Op actions
         */

        /**
         * Constructs a new Op.
         * @memberof lnrpc
         * @classdesc Represents an Op.
         * @implements IOp
         * @constructor
         * @param {lnrpc.IOp=} [properties] Properties to set
         */
        function Op(properties) {
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Op entity.
         * @member {string} entity
         * @memberof lnrpc.Op
         * @instance
         */
        Op.prototype.entity = "";

        /**
         * Op actions.
         * @member {Array.<string>} actions
         * @memberof lnrpc.Op
         * @instance
         */
        Op.prototype.actions = $util.emptyArray;

        /**
         * Creates a new Op instance using the specified properties.
         * @function create
         * @memberof lnrpc.Op
         * @static
         * @param {lnrpc.IOp=} [properties] Properties to set
         * @returns {lnrpc.Op} Op instance
         */
        Op.create = function create(properties) {
            return new Op(properties);
        };

        /**
         * Encodes the specified Op message. Does not implicitly {@link lnrpc.Op.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Op
         * @static
         * @param {lnrpc.IOp} message Op message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Op.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.entity);
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.actions[i]);
            return writer;
        };

        /**
         * Encodes the specified Op message, length delimited. Does not implicitly {@link lnrpc.Op.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Op
         * @static
         * @param {lnrpc.IOp} message Op message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Op.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Op message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Op
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Op} Op
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Op.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Op();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity = reader.string();
                    break;
                case 2:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Op message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Op
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Op} Op
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Op.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Op message.
         * @function verify
         * @memberof lnrpc.Op
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Op.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity"))
                if (!$util.isString(message.entity))
                    return "entity: string expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i)
                    if (!$util.isString(message.actions[i]))
                        return "actions: string[] expected";
            }
            return null;
        };

        /**
         * Creates an Op message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Op
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Op} Op
         */
        Op.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Op)
                return object;
            let message = new $root.lnrpc.Op();
            if (object.entity != null)
                message.entity = String(object.entity);
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".lnrpc.Op.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i)
                    message.actions[i] = String(object.actions[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an Op message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Op
         * @static
         * @param {lnrpc.Op} message Op
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Op.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (options.defaults)
                object.entity = "";
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = message.entity;
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = message.actions[j];
            }
            return object;
        };

        /**
         * Converts this Op to JSON.
         * @function toJSON
         * @memberof lnrpc.Op
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Op.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Op;
    })();

    return lnrpc;
})();

export { $root as default };
